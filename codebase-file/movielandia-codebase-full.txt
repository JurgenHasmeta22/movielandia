Directory structure:
└── movielandia/
    ├── README.md
    ├── next.config.ts
    ├── package.json
    ├── tsconfig.json
    ├── .eslintrc.json
    ├── .prettierrc
    ├── emails/
    │   ├── NewsletterEmail.tsx
    │   ├── RegistrationEmail.tsx
    │   └── ResetPasswordEmail.tsx
    ├── prisma/
    │   ├── config/
    │   │   └── prisma.ts
    │   └── schema/
    │       ├── actor.prisma
    │       ├── auth.prisma
    │       ├── crew.prisma
    │       ├── episode.prisma
    │       ├── genre.prisma
    │       ├── movie.prisma
    │       ├── schema.prisma
    │       ├── season.prisma
    │       ├── serie.prisma
    │       └── user.prisma
    ├── public/
    └── src/
        ├── middleware.ts
        ├── actions/
        │   ├── actor.actions.ts
        │   ├── auth.actions.ts
        │   ├── crew.actions.ts
        │   ├── episode.actions.ts
        │   ├── genre.actions.ts
        │   ├── movie.actions.ts
        │   ├── season.actions.ts
        │   ├── serie.actions.ts
        │   ├── review/
        │   │   └── reviewVotes.actions.ts
        │   └── user/
        │       ├── user.actions.ts
        │       ├── userBookmarks.actions.ts
        │       ├── userDownvotes.actions.ts
        │       ├── userFollow.actions.ts
        │       ├── userMessages.actions.ts
        │       ├── userProfile.actions.ts
        │       ├── userReviews.actions.ts
        │       └── userUpvotes.actions.ts
        ├── app/
        │   ├── global-error.tsx
        │   ├── globals.css
        │   ├── robots.ts
        │   ├── sitemap.ts
        │   ├── (admin)/
        │   │   ├── error.tsx
        │   │   ├── layout.tsx
        │   │   ├── loading.tsx
        │   │   └── admin/
        │   │       ├── page.tsx
        │   │       ├── actors/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── ActorAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── ActorsAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddActorAdminPage.tsx
        │   │       ├── crews/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── CrewAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── CrewsAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddCrewAdminPage.tsx
        │   │       ├── dashboard/
        │   │       │   ├── page.tsx
        │   │       │   ├── _actions/
        │   │       │   │   └── getDashboardStats.ts
        │   │       │   └── _components/
        │   │       │       ├── DashboardAdminPage.tsx
        │   │       │       ├── DashboardProgressCircle.tsx
        │   │       │       └── DashboardStatBox.tsx
        │   │       ├── episodes/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── EpisodeAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── EpisodesAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddEpisodeAdminPage.tsx
        │   │       ├── genres/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── GenreAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── GenresAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddGenreAdminPage.tsx
        │   │       ├── movies/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── MovieAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── MoviesAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddMovieAdminPage.tsx
        │   │       ├── seasons/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── SeasonAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── SeasonsAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddSeasonAdminPage.tsx
        │   │       ├── series/
        │   │       │   ├── page.tsx
        │   │       │   ├── [id]/
        │   │       │   │   ├── page.tsx
        │   │       │   │   └── _components/
        │   │       │   │       └── SerieAdminPage.tsx
        │   │       │   ├── _components/
        │   │       │   │   └── SeriesAdminPage.tsx
        │   │       │   └── create/
        │   │       │       ├── page.tsx
        │   │       │       └── _components/
        │   │       │           └── AddSerieAdminPage.tsx
        │   │       └── users/
        │   │           ├── page.tsx
        │   │           ├── [id]/
        │   │           │   ├── page.tsx
        │   │           │   └── _components/
        │   │           │       └── UserAdminPage.tsx
        │   │           ├── _components/
        │   │           │   └── UsersAdminPage.tsx
        │   │           └── create/
        │   │               ├── page.tsx
        │   │               └── _components/
        │   │                   └── AddUserAdminPage.tsx
        │   ├── (root)/
        │   │   ├── error.tsx
        │   │   ├── layout.tsx
        │   │   ├── loading.tsx
        │   │   ├── not-found.tsx
        │   │   ├── page.tsx
        │   │   ├── template.tsx
        │   │   ├── (auth)/
        │   │   │   ├── change-password/
        │   │   │   │   ├── page.tsx
        │   │   │   │   └── _components/
        │   │   │   │       └── ChangePasswordForm.tsx
        │   │   │   ├── login/
        │   │   │   │   ├── page.tsx
        │   │   │   │   └── _components/
        │   │   │   │       └── LoginForm.tsx
        │   │   │   └── register/
        │   │   │       ├── page.tsx
        │   │   │       └── _components/
        │   │   │           └── RegisterForm.tsx
        │   │   ├── (home)/
        │   │   │   └── _components/
        │   │   │       ├── HomeHero.tsx
        │   │   │       ├── ListHomeSection.tsx
        │   │   │       ├── MarketingSection.tsx
        │   │   │       └── NewsletterSection.tsx
        │   │   ├── [...not-found]/
        │   │   │   └── page.tsx
        │   │   ├── about-us/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       └── AboutUsContent.tsx
        │   │   ├── actors/
        │   │   │   ├── page.tsx
        │   │   │   ├── [actorId]/
        │   │   │   │   └── [actorFullname]/
        │   │   │   │       ├── page.tsx
        │   │   │   │       ├── _components/
        │   │   │   │       │   └── ActorPageContent.tsx
        │   │   │   │       └── reviews/
        │   │   │   │           └── [reviewId]/
        │   │   │   │               ├── downvotes/
        │   │   │   │               │   ├── page.tsx
        │   │   │   │               │   └── _components/
        │   │   │   │               │       └── ActorReviewDownvotesPageContent.tsx
        │   │   │   │               └── upvotes/
        │   │   │   │                   ├── page.tsx
        │   │   │   │                   └── _components/
        │   │   │   │                       └── ActorReviewUpvotesPageContent.tsx
        │   │   │   └── _components/
        │   │   │       └── ActorsPageContent.tsx
        │   │   ├── contact-us/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       └── ContactUsContent.tsx
        │   │   ├── crew/
        │   │   │   ├── page.tsx
        │   │   │   ├── [crewId]/
        │   │   │   │   └── [crewFullname]/
        │   │   │   │       ├── page.tsx
        │   │   │   │       ├── _components/
        │   │   │   │       │   └── CrewPageContent.tsx
        │   │   │   │       └── reviews/
        │   │   │   │           └── [reviewId]/
        │   │   │   │               ├── downvotes/
        │   │   │   │               │   ├── page.tsx
        │   │   │   │               │   └── _components/
        │   │   │   │               │       └── CrewReviewDownvotesPageContent.tsx
        │   │   │   │               └── upvotes/
        │   │   │   │                   ├── page.tsx
        │   │   │   │                   └── _components/
        │   │   │   │                       └── CrewReviewUpvotesPageContent.tsx
        │   │   │   └── _components/
        │   │   │       └── CrewAllPageContent.tsx
        │   │   ├── genres/
        │   │   │   ├── page.tsx
        │   │   │   └── [genreId]/
        │   │   │       └── [genreName]/
        │   │   │           ├── page.tsx
        │   │   │           └── _components/
        │   │   │               ├── GenreList.tsx
        │   │   │               ├── GenrePageContent.tsx
        │   │   │               └── GenreTabs.tsx
        │   │   ├── messages/
        │   │   │   ├── page.tsx
        │   │   │   ├── [messageId]/
        │   │   │   │   ├── page.tsx
        │   │   │   │   └── _components/
        │   │   │   │       └── MessagePageContent.tsx
        │   │   │   └── _components/
        │   │   │       ├── MessageCompose.tsx
        │   │   │       ├── MessagedSidebar.tsx
        │   │   │       ├── MessagesList.tsx
        │   │   │       └── MessagesPageContent.tsx
        │   │   ├── movies/
        │   │   │   ├── page.tsx
        │   │   │   ├── [movieId]/
        │   │   │   │   └── [movieTitle]/
        │   │   │   │       ├── page.tsx
        │   │   │   │       ├── _components/
        │   │   │   │       │   └── MoviePageContent.tsx
        │   │   │   │       └── reviews/
        │   │   │   │           └── [reviewId]/
        │   │   │   │               ├── downvotes/
        │   │   │   │               │   ├── page.tsx
        │   │   │   │               │   └── _components/
        │   │   │   │               │       └── MovieReviewDownvotesPageContent.tsx
        │   │   │   │               └── upvotes/
        │   │   │   │                   ├── page.tsx
        │   │   │   │                   └── _components/
        │   │   │   │                       └── MovieReviewUpvotesPageContent.tsx
        │   │   │   └── _components/
        │   │   │       └── MoviesPageContent.tsx
        │   │   ├── notifications/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       └── NotificationsPageContent.tsx
        │   │   ├── privacy/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       └── PrivacyContentPage.tsx
        │   │   ├── register-verification-sent/
        │   │   │   └── page.tsx
        │   │   ├── reset-password/
        │   │   │   └── page.tsx
        │   │   ├── reset-password-verification-sent/
        │   │   │   └── page.tsx
        │   │   ├── search/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       ├── SearchList.tsx
        │   │   │       ├── SearchPageContent.tsx
        │   │   │       └── SearchTabs.tsx
        │   │   ├── series/
        │   │   │   ├── page.tsx
        │   │   │   ├── [serieId]/
        │   │   │   │   └── [serieTitle]/
        │   │   │   │       ├── page.tsx
        │   │   │   │       ├── _components/
        │   │   │   │       │   └── SeriePageContent.tsx
        │   │   │   │       ├── reviews/
        │   │   │   │       │   └── [reviewId]/
        │   │   │   │       │       ├── downvotes/
        │   │   │   │       │       │   ├── page.tsx
        │   │   │   │       │       │   └── _components/
        │   │   │   │       │       │       └── SerieReviewDownvotesPageContent.tsx
        │   │   │   │       │       └── upvotes/
        │   │   │   │       │           ├── page.tsx
        │   │   │   │       │           └── _components/
        │   │   │   │       │               └── SerieReviewUpvotesPageContent.tsx
        │   │   │   │       └── seasons/
        │   │   │   │           └── [seasonId]/
        │   │   │   │               └── [seasonTitle]/
        │   │   │   │                   ├── page.tsx
        │   │   │   │                   ├── _components/
        │   │   │   │                   │   └── SeasonPageContent.tsx
        │   │   │   │                   ├── episodes/
        │   │   │   │                   │   └── [episodeId]/
        │   │   │   │                   │       └── [episodeTitle]/
        │   │   │   │                   │           ├── page.tsx
        │   │   │   │                   │           ├── _components/
        │   │   │   │                   │           │   └── EpisodePageContent.tsx
        │   │   │   │                   │           └── reviews/
        │   │   │   │                   │               └── [reviewId]/
        │   │   │   │                   │                   ├── downvotes/
        │   │   │   │                   │                   │   ├── page.tsx
        │   │   │   │                   │                   │   └── _components/
        │   │   │   │                   │                   │       └── EpisodeReviewDownvotesPageContent.tsx
        │   │   │   │                   │                   └── upvotes/
        │   │   │   │                   │                       ├── page.tsx
        │   │   │   │                   │                       └── _components/
        │   │   │   │                   │                           └── EpisodeReviewUpvotesPageContent.tsx
        │   │   │   │                   └── reviews/
        │   │   │   │                       └── [reviewId]/
        │   │   │   │                           ├── downvotes/
        │   │   │   │                           │   ├── page.tsx
        │   │   │   │                           │   └── _components/
        │   │   │   │                           │       └── SeasonReviewDownvotesPageContent.tsx
        │   │   │   │                           └── upvotes/
        │   │   │   │                               ├── page.tsx
        │   │   │   │                               └── _components/
        │   │   │   │                                   └── SeasonReviewUpvotesPageContent.tsx
        │   │   │   └── _components/
        │   │   │       └── SeriesPageContent.tsx
        │   │   ├── terms/
        │   │   │   ├── page.tsx
        │   │   │   └── _components/
        │   │   │       └── TermsContentPage.tsx
        │   │   ├── users/
        │   │   │   └── [userId]/
        │   │   │       └── [userName]/
        │   │   │           ├── page.tsx
        │   │   │           ├── _components/
        │   │   │           │   ├── CardItemProfile.tsx
        │   │   │           │   ├── PrivateProfileMessage.tsx
        │   │   │           │   ├── ProfileHeader.tsx
        │   │   │           │   ├── ProfileInfo.tsx
        │   │   │           │   ├── ProfileSearchBar.tsx
        │   │   │           │   ├── ProfileStats.tsx
        │   │   │           │   ├── ProfileTabs.tsx
        │   │   │           │   ├── ReviewItemProfile.tsx
        │   │   │           │   ├── SocialSection.tsx
        │   │   │           │   ├── TabContent.tsx
        │   │   │           │   ├── UserListItem.tsx
        │   │   │           │   └── UserPageContent.tsx
        │   │   │           ├── followers/
        │   │   │           │   ├── page.tsx
        │   │   │           │   └── _components/
        │   │   │           │       └── FollowersPageContent.tsx
        │   │   │           ├── followersRequests/
        │   │   │           │   ├── page.tsx
        │   │   │           │   └── _components/
        │   │   │           │       └── FollowersRequestsPageContent.tsx
        │   │   │           └── following/
        │   │   │               ├── page.tsx
        │   │   │               └── _components/
        │   │   │                   └── FollowingPageContent.tsx
        │   │   ├── verify-register/
        │   │   │   └── page.tsx
        │   │   └── verify-reset-password/
        │   │       └── page.tsx
        │   ├── _components/
        │   │   └── NotFoundGlobalPage.tsx
        │   └── api/
        │       ├── route.ts
        │       ├── auth/
        │       │   └── [...nextauth]/
        │       │       └── route.ts
        │       ├── changePassword/
        │       │   └── route.ts
        │       ├── genres/
        │       │   └── route.ts
        │       ├── notifications/
        │       │   └── route.ts
        │       ├── search/
        │       │   └── all/
        │       │       └── route.ts
        │       ├── verifyRegister/
        │       │   └── route.ts
        │       └── verifyResetPassword/
        │           └── route.ts
        ├── components/
        │   ├── admin/
        │   │   ├── breadcrumb/
        │   │   │   └── Breadcrumb.tsx
        │   │   ├── form/
        │   │   │   └── Form.tsx
        │   │   ├── headerDashboard/
        │   │   │   └── HeaderDashboard.tsx
        │   │   ├── modal/
        │   │   │   └── Modal.tsx
        │   │   ├── rightPanel/
        │   │   │   └── RightPanel.tsx
        │   │   ├── sidebar/
        │   │   │   ├── Sidebar.tsx
        │   │   │   └── components/
        │   │   │       ├── SidebarItem.tsx
        │   │   │       └── SidebarItems.tsx
        │   │   ├── tableAdmin/
        │   │   │   ├── TableAdmin.tsx
        │   │   │   ├── components/
        │   │   │   │   ├── ExportMenu.tsx
        │   │   │   │   ├── TableToolbar.tsx
        │   │   │   │   ├── ToolbarActions.tsx
        │   │   │   │   └── ToolbarFilters.tsx
        │   │   │   └── utils/
        │   │   │       ├── tableColumns.ts
        │   │   │       └── tableDelete.ts
        │   │   └── topBar/
        │   │       └── TopBar.tsx
        │   └── root/
        │       ├── authButtons/
        │       │   └── AuthButtons.tsx
        │       ├── cardItem/
        │       │   └── CardItem.tsx
        │       ├── carousel/
        │       │   └── Carousel.tsx
        │       ├── detailsPageCard/
        │       │   ├── DetailsPageCard.tsx
        │       │   ├── PaginationPersonControl.tsx
        │       │   └── PersonRoleCard.tsx
        │       ├── footer/
        │       │   └── Footer.tsx
        │       ├── genreItem/
        │       │   └── GenreItem.tsx
        │       ├── header/
        │       │   ├── Header.tsx
        │       │   ├── HeaderContent.tsx
        │       │   ├── HeaderLinks.tsx
        │       │   └── MessageCounter.tsx
        │       ├── headerMobile/
        │       │   └── HeaderMobile.tsx
        │       ├── latestList/
        │       │   └── LatestList.tsx
        │       ├── listDetail/
        │       │   └── ListDetail.tsx
        │       ├── loadingSpinner/
        │       │   └── LoadingSpinner.tsx
        │       ├── muiNextLink/
        │       │   └── MuiNextLink.tsx
        │       ├── notificationMenu/
        │       │   └── NotificationMenu.tsx
        │       ├── paginationControl/
        │       │   └── PaginationControl.tsx
        │       ├── review/
        │       │   └── Review.tsx
        │       ├── reviewsHeader/
        │       │   └── ReviewsHeader.tsx
        │       ├── scrollToTop/
        │       │   └── ScrollToTop.tsx
        │       ├── searchField/
        │       │   ├── SearchAutocomplete.tsx
        │       │   ├── SearchField.tsx
        │       │   └── SearchResultCard.tsx
        │       ├── sortSelect/
        │       │   ├── SortSelect.tsx
        │       │   └── getSortingOptions.tsx
        │       ├── tabPanel/
        │       │   └── TabPanel.tsx
        │       ├── textEditor/
        │       │   └── TextEditor.tsx
        │       ├── textEditorButtons/
        │       │   └── TextEditorButtons.tsx
        │       ├── textEditorForm/
        │       │   └── TextEditorForm.tsx
        │       └── themeToggleButton/
        │           └── ThemeToggleButton.tsx
        ├── constants/
        │   └── Constants.ts
        ├── hooks/
        │   ├── useDebounce.ts
        │   ├── usePageDetailsData.ts
        │   └── useSorting.ts
        ├── layouts/
        │   ├── AdminLayout.tsx
        │   └── MainLayout.tsx
        ├── providers/
        │   ├── AuthProvider.tsx
        │   ├── ModalProvider.tsx
        │   ├── RightPanelProvider.tsx
        │   ├── ThemeProvider.tsx
        │   └── ToastProvider.tsx
        ├── schemas/
        │   ├── actor.schema.ts
        │   ├── auth.schema.ts
        │   ├── crew.schema.ts
        │   ├── episode.schema.ts
        │   ├── genre.schema.ts
        │   ├── movie.schema.ts
        │   ├── season.schema.ts
        │   ├── serie.schema.ts
        │   └── user.schema.ts
        ├── store/
        │   └── store.ts
        ├── types/
        │   ├── IStore.ts
        │   ├── filterOperators.ts
        │   └── next-auth.d.ts
        └── utils/
            ├── features/
            │   ├── actorFeaturesUtils.ts
            │   ├── crewFeaturesUtils.ts
            │   ├── episodeFeaturesUtils.ts
            │   ├── movieFeaturesUtils.ts
            │   ├── seasonFeaturesUtils.ts
            │   └── serieFeaturesUtils.ts
            ├── helpers/
            │   ├── toast.ts
            │   └── utils.ts
            └── theme/
                └── theme.tsx

================================================
File: README.md
================================================
<div align="center">
  <h1 style="color: #30969f;">🎬 MovieLandia24</h1>

  <p align="center" style="font-size: 1.1em; color: #777; line-height: 1.5;">
    <strong>MovieLandia24</strong> is a dynamic, full-stack social platform crafted for cinema enthusiasts. It empowers users to explore, rate, review, bookmark, and connect around a rich database of movies, TV series, actors, crew members, seasons, and episodes. Enjoy a seamless experience with interactive features that enhance your engagement with the world of cinema.
  </p>

  <p align="center" style="font-size: 1.05em; color: #555;">
    <a href="#tech-stack" style="margin: 0 10px; color: #30969f; text-decoration: none;">Tech Stack</a> •
    <a href="#key-features" style="margin: 0 10px; color: #30969f; text-decoration: none;">Features</a> •
    <a href="#getting-started" style="margin: 0 10px; color: #30969f; text-decoration: none;">Getting Started</a> •
    <a href="#project-structure" style="margin: 0 10px; color: #30969f; text-decoration: none;">Structure</a> •
     <a href="#performance-improvements" style="margin: 0 10px; color: #30969f; text-decoration: none;">Performance</a>
  </p>

  <p align="center">
    <img src="https://img.shields.io/badge/Next.js-15-black?style=flat-square&logo=next.js" alt="Next.js" style="margin: 0 5px;"/>
    <img src="https://img.shields.io/badge/React-19-blue?style=flat-square&logo=react" alt="React" style="margin: 0 5px;"/>
    <img src="https://img.shields.io/badge/TypeScript-5-blue?style=flat-square&logo=typescript" alt="TypeScript" style="margin: 0 5px;"/>
    <img src="https://img.shields.io/badge/MUI-6-blue?style=flat-square&logo=mui" alt="Material UI" style="margin: 0 5px;"/>
  </p>
</div>

---

<h2 style="color:#30969f;" id="tech-stack">⚡ Tech Stack</h2>
<p style="font-size:1.1em;">
  MovieLandia24 is meticulously crafted using a powerful combination of technologies. Next.js App Router and React form its foundation, which provides seamless navigation and a reactive user experience. Styling is provided via Material UI, ensuring a consistent and aesthetically pleasing platform, enhanced by Emotion. Core logic is handled by Zustand, while UI animations are managed with Framer Motion. For Email communications, MovieLandia24 uses React Email and Resend.
</p>
  <ul style="list-style-type: none; padding-left: 0;">
        <li><strong>Framework:</strong> <a href="https://nextjs.org/" style="color:#30969f;" target="_blank">Next.js 15</a> (App Router)</li>
        <li><strong>UI Components:</strong> <a href="https://mui.com/" style="color:#30969f;" target="_blank">Material-UI v6</a> with Emotion</li>
        <li><strong>State Management:</strong> <a href="https://github.com/pmndrs/zustand" style="color:#30969f;" target="_blank">Zustand</a></li>
        <li><strong>Database:</strong> PostgreSQL + <a href="https://www.prisma.io/" style="color:#30969f;" target="_blank">Prisma ORM</a></li>
        <li><strong>Authentication:</strong> <a href="https://next-auth.js.org/" style="color:#30969f;" target="_blank">NextAuth.js</a> with Google & Credentials</li>
        <li><strong>Forms & Validation:</strong> <a href="https://react-hook-form.com/" style="color:#30969f;" target="_blank">React Hook Form</a> + <a href="https://zod.dev/" style="color:#30969f;" target="_blank">Zod</a></li>
         <li><strong>Rich Text Editor:</strong> <a href="https://github.com/zenoamaro/react-quill" style="color:#30969f;" target="_blank">React Quill</a> with <a href="https://www.npmjs.com/package/quill-resize-image" style="color:#30969f;" target="_blank">quill-resize-image</a></li>
        <li><strong>Email System:</strong> <a href="https://react.email/" style="color:#30969f;" target="_blank">React Email</a> + <a href="https://resend.com/" style="color:#30969f;" target="_blank">Resend</a></li>
        <li><strong>DataTables:</strong> <a href="https://www.material-react-table.com/" style="color:#30969f;" target="_blank">Material React Table V3</a></li>
        <li><strong>Animations:</strong> <a href="https://www.framer.com/motion/" style="color:#30969f;" target="_blank">Framer Motion</a></li>
        <li><strong>PDF Generation:</strong> <a href="https://github.com/parallax/jsPDF" style="color:#30969f;" target="_blank">jsPDF</a> + <a href="https://github.com/simonbengtsson/jsPDF-AutoTable" style="color:#30969f;" target="_blank">AutoTable</a></li>
        <li><strong>Carousel:</strong> <a href="https://react-slick.neostack.com/" style="color:#30969f;" target="_blank">React Slick</a></li>
        <li><strong>Notifications:</strong> <a href="https://fkhadra.github.io/react-toastify/" style="color:#30969f;" target="_blank">React Toastify</a></li>
         <li><strong>URL State:</strong> <a href="https://www.npmjs.com/package/nuqs" style="color:#30969f;" target="_blank">nuqs</a></li>
  </ul>

<h2 style="color:#30969f;" id="key-features">🚀 Key Features</h2>

<h3 style="color:#30969f;">📺 Content Management</h3>
 <ul style="list-style-type: disc; padding-left: 20px;">
    <li>Browse and view details for Movies, TV Series, Seasons, and Episodes.</li>
    <li>Discover comprehensive information about Actors and Crew Members.</li>
    <li>Explore content by different Genres.</li>
    <li>Leverage IMDb ratings for content evaluation.</li>
      <li>Enjoy rich media support with images and trailers.</li>
 </ul>

<h3 style="color:#30969f;">👤 User Features</h3>
 <ul style="list-style-type: disc; padding-left: 20px;">
        <li>Multi-provider authentication with Google OAuth and email/password credentials, managed with NextAuth.js.</li>
        <li>Personalize your experience by customizing your user profile.</li>
        <li>Save and access favorite content through the bookmarking functionality.</li>
        <li>Rate and submit reviews to share your thoughts about movies, series, and actors.</li>
        <li>Connect with other users using the follow/unfollow mechanism.</li>
        <li>Securely recover account passwords through a password reset flow.</li>
          <li>Activate your account through email verification to access more features.</li>
 </ul>

<h3 style="color:#30969f;">🛠 Admin Dashboard</h3>
  <ul style="list-style-type: disc; padding-left: 20px;">
        <li>Utilizes Material React Table for dynamic data displays.</li>
        <li>Enables advanced Create, Read, Update, Delete (CRUD) operations.</li>
        <li>Offers robust user management with customizable roles.</li>
        <li>Provides content moderation tools to control user-generated content.</li>
        <li>Exports data to PDF, CSV, and Excel for data reporting and sharing.</li>
  </ul>
  
 <h3 style="color:#30969f;">🎯 Advanced Features</h3>
  <ul style="list-style-type: disc; padding-left: 20px;">
      <li>Use of rich text editor powered by react-quill to format text when submitting data.</li>
        <li>Use a serverless API endpoint to search across various content types.</li>
      <li>Smart sorting and filtering provides a dynamic view of results.</li>
       <li>Responsive layouts ensure compatibility across various devices.</li>
        <li>Image optimization uses `next/image` to deliver smaller optimized sizes images.</li>
     <li>SEO optimization to ensure that your site is easily discoverable.</li>
       <li>Utilize client side validation with `zod` and server side validation.</li>
  </ul>

 <h3 style="color:#30969f;">💻 Developer Experience</h3>
  <ul style="list-style-type: disc; padding-left: 20px;">
      <li>TypeScript is used for static typing, catching bugs earlier and improving overall code quality.</li>
      <li>ESLint is used to maintain consistent and clean code using predefined rules.</li>
      <li>Prettier is used to format the code automatically.</li>
       <li>Includes development tools that enhance the developer experience
         <ul>
             <li>Turbo Mode: Enables faster build times and incremental changes in the codebase.</li>
             <li>Hot Reload: To update the view when a change is made without requiring a full reload.</li>
              <li>React Dev Tools: To view the react component tree, and inspect props and state within your components.</li>
              <li>Performance Monitoring: Browser based performance insights which can show the current performance bottlenecks.</li>
         </ul>
       </li>
        <li>A modular architecture to enable better separation of concerns, better organization and promote code reusability.</li>
       <li>Code splitting to help decrease bundle size and improve performance.</li>
      <li>Nextjs `Route groups` for better organization of routes.</li>
     <li>Server actions enable performing server actions from client components, while still running the function on server side.</li>
    <li> API routes for custom backend logic.</li>
  </ul>

 <h3 style="color:#30969f;">🔒 Security Features</h3>
  <ul style="list-style-type: disc; padding-left: 20px;">
      <li>JWT authentication to secure the API routes and user sessions.</li>
        <li>Secure password hashing to prevent user passwords from being stolen.</li>
        <li>Protected routes for user and admin only pages.</li>
       <li>Role based access to enable different authorization levels for users with different roles.</li>
       <li>Input validation through `zod` to prevent malicious user provided data.</li>
  </ul>

<h2 style="color:#30969f;" id="getting-started">🏁 Getting Started</h2>

<ol style="padding-left: 20px;">
  <li><strong>Clone & Install:</strong>
    <pre style="overflow: auto; background-color:#f0f0f0; padding:10px;"><code>git clone https://github.com/JurgenHasmeta22/movielandia.git
cd movielandia
npm install</code></pre>
  </li>
   <li><strong>Environment Setup:</strong>
    <p>
        Create a <code>.env.local</code> with the following variables:
        </p>
       <pre style="background-color:#f0f0f0; padding:10px; overflow:auto"><code>
        DATABASE_URL=""
        NEXTAUTH_URL=""
        NEXTAUTH_SECRET=""
        GOOGLE_CLIENT_ID=""
        GOOGLE_CLIENT_SECRET=""
        RESEND_API_KEY=""
        POSTGRES_URL=""
        POSTGRES_PRISMA_URL=""
        POSTGRES_URL_NO_SSL=""
        POSTGRES_URL_NON_POOLING=""
        POSTGRES_HOST=""
        POSTGRES_PASSWORD=""
        POSTGRES_DATABASE=""
    </code></pre>
  </li>
   <li><strong>Database Initialization:</strong>
    <pre style="overflow: auto; background-color:#f0f0f0; padding:10px;"><code>npx prisma generate
npx prisma migrate dev</code></pre>
  </li>
   <li><strong>Development Server:</strong>
     <pre style="overflow: auto; background-color:#f0f0f0; padding:10px;"><code>npm run dev</code></pre>
    <p>Visit <a href="http://localhost:4000" style="color:#30969f;" target="_blank">http://localhost:4000</a></p>
  </li>
 </ol>
 <h2 style="color:#30969f;" id="project-structure">📁 Project Structure</h2>

<pre style="overflow: auto; background-color: #f0f0f0; padding: 10px;"><code>
movielandia/
├── src/
│   ├── actions/         # Server actions for data mutations
│   ├── app/            # Next.js app router pages & layouts
│   │   ├── (admin)/    # Admin dashboard routes
│   │   └── (root)/     # Main app routes
│   ├── components/     # Reusable UI components
│   ├── constants/      # Global constants
│   ├── hooks/          # Custom React hooks
│   ├── layouts/        # Layout components
│   ├── middleware.ts   # Auth & routing middleware
│   ├── providers/      # Context providers
│   ├── store/          # Zustand store
│   ├── types/          # TypeScript definitions
│   └── utils/          # Helper functions
├── prisma/
│   ├── migrations/     # Database migrations
│   ├── schema/         # Database models
│   |── seed/           # Seed data scripts
|   |── config/         # Prisma config file
└── emails/             # Email templates
</code></pre>

---

<div align="center">
  <p style="color: #777; font-size: 1em;">Developed with ❤️ by <a href="https://github.com/JurgenHasmeta22" style="color:#30969f;">JurgenHasmeta22</a></p>
</div>


================================================
File: next.config.ts
================================================
/** @type {import('next').NextConfig} */

const nextConfig = {
    images: {
        remotePatterns: [
            {
                hostname: "localhost",
                port: "4000",
            },
            {
                protocol: "https",
                hostname: "movielandia-avenger22s-projects.vercel.app",
            },
        ],
    },
    typescript: {
        ignoreBuildErrors: true,
    },
    eslint: {
        ignoreDuringBuilds: true,
    },
};

export default nextConfig;


================================================
File: package.json
================================================
{
    "name": "movielandia",
    "version": "1.0.0",
    "private": true,
    "scripts": {
        "dev": "next dev --port 4000 --turbo",
        "build": "prisma generate && next build",
        "buildDev": "next build",
        "email": "email dev",
        "start": "next start",
        "startDev": "next start --port 4000",
        "seed": "npx prisma migrate dev && tsx prisma/seed/seed.ts",
        "lint": "next lint",
        "scan": "next dev & npx react-scan@latest localhost:4000",
        "format": "prettier --write src/**/*.{js,jsx,ts,tsx,css,md,json,scss} --config ./.prettierrc"
    },
    "dependencies": {
        "@emotion/cache": "^11.14.0",
        "@emotion/react": "^11.14.0",
        "@emotion/styled": "^11.14.0",
        "@hookform/resolvers": "^3.9.1",
        "@mui/icons-material": "^6.3.0",
        "@mui/material": "^6.3.0",
        "@mui/material-nextjs": "^6.3.0",
        "@mui/x-date-pickers": "^7.23.3",
        "@next-auth/prisma-adapter": "^1.0.7",
        "@next/bundle-analyzer": "^15.1.3",
        "@prisma/client": "^6.1.0",
        "@react-email/components": "0.0.31",
        "@vercel/postgres": "^0.10.0",
        "bcrypt": "^5.1.1",
        "date-fns": "^4.1.0",
        "dotenv": "^16.4.7",
        "framer-motion": "^12.0.0-alpha.1",
        "jspdf": "^2.5.2",
        "jspdf-autotable": "^3.8.4",
        "material-react-table": "^3.1.0",
        "next": "^15.1.3",
        "next-auth": "^4.24.11",
        "nuqs": "^2.2.3",
        "prisma": "^6.1.0",
        "quill-resize-image": "^1.0.5",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-email": "3.0.4",
        "react-hook-form": "^7.54.2",
        "react-quill-new": "^3.3.3",
        "react-slick": "^0.30.3",
        "react-toastify": "^11.0.2",
        "resend": "^4.0.1",
        "sharp": "^0.33.5",
        "slick-carousel": "^1.8.1",
        "xlsx": "^0.18.5",
        "zod": "^3.24.1",
        "zustand": "^5.0.2"
    },
    "devDependencies": {
        "@types/bcrypt": "^5.0.2",
        "@types/node": "^22.10.2",
        "@types/react": "^19.0.2",
        "@types/react-dom": "^19.0.2",
        "@types/react-slick": "^0.23.13",
        "eslint": "^8",
        "eslint-config-next": "^15.1.3",
        "prettier": "^3.4.2",
        "prisma-dbml-generator": "^0.12.0",
        "prisma-erd-generator": "^1.11.2",
        "tsx": "^4.19.2",
        "typescript": "^5.7.2"
    }
}


================================================
File: tsconfig.json
================================================
{
    "compilerOptions": {
        "lib": ["dom", "dom.iterable", "esnext"],
        "allowJs": true,
        "skipLibCheck": true,
        "strict": true,
        "noEmit": true,
        "esModuleInterop": true,
        "module": "esnext",
        "moduleResolution": "bundler",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "jsx": "preserve",
        "incremental": true,
        "plugins": [
            {
                "name": "next"
            }
        ],
        "paths": {
            "@/*": ["./src/*"]
        },
        "target": "ES2017"
    },
    "include": ["next-env.d.ts", "prisma/seed.ts", "src/types/**/*.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
    "exclude": ["node_modules"]
}


================================================
File: .eslintrc.json
================================================
{
    "extends": ["next/core-web-vitals"],
    "rules": {
        "no-unused-vars": "off",
        "no-unused-expressions": "off",
        "react-hooks/exhaustive-deps": "off"
    }
}


================================================
File: .prettierrc
================================================
{
    "semi": true,
    "tabWidth": 4,
    "printWidth": 120,
    "singleQuote": false,
    "trailingComma": "all",
    "jsxSingleQuote": false,
    "bracketSpacing": true
}


================================================
File: emails/NewsletterEmail.tsx
================================================
import React from "react";
import {
    Html,
    Head,
    Preview,
    Body,
    Container,
    Heading,
    Text,
    Img,
    Section,
} from "@react-email/components";

interface NewsletterEmailProps {
    userName: string;
}

const baseUrl = process.env.NEXT_PUBLIC_APP_URL;

const NewsletterEmail: React.FC<NewsletterEmailProps> = ({ userName }) => {
    const main = {
        backgroundColor: "#f6f9fc",
        fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
    };

    const container = {
        backgroundColor: "#ffffff",
        margin: "0 auto",
        padding: "32px",
        borderRadius: "12px",
        boxShadow: "0 4px 6px rgba(0, 0, 0, 0.05)",
        maxWidth: "600px",
    };

    const logo = {
        margin: "0 auto",
        width: "150px",
        height: "auto",
    };

    const heading = {
        fontSize: "24px",
        letterSpacing: "-0.5px",
        lineHeight: "1.3",
        fontWeight: "700",
        color: "#484848",
        padding: "17px 0 0",
    };

    const paragraph = {
        margin: "0 0 15px",
        fontSize: "15px",
        lineHeight: "1.6",
        color: "#3c4149",
    };

    const footer = {
        color: "#706a7b",
        fontSize: "12px",
        lineHeight: "16px",
        textAlign: "center" as const,
        marginTop: "32px",
    };

    return (
        <Html>
            <Head />
            <Preview>Welcome to MovieLandia24 Newsletter 🎬</Preview>
            <Body style={main}>
                <Container style={container}>
                    <Section style={{ textAlign: "center" as const }}>
                        <Img
                            src={`${baseUrl}/icons/movielandia24-logo.png`}
                            width="150"
                            height="auto"
                            alt="MovieLandia24"
                            style={logo}
                        />
                    </Section>
                    <Heading style={heading}>
                        Welcome, {userName}! 👋
                    </Heading>
                    <Text style={paragraph}>
                        Thank you for subscribing to our newsletter! Get ready for exclusive movie updates,
                        recommendations, and insider content delivered straight to your inbox.
                    </Text>
                    <Text style={paragraph}>
                        Stay tuned for:
                        <br />• Latest movie releases and reviews
                        <br />• Exclusive behind-the-scenes content
                        <br />• Special features and interviews
                        <br />• Community highlights and discussions
                    </Text>
                    <Text style={{ ...paragraph, marginTop: "24px" }}>
                        Best regards,
                        <br />
                        The MovieLandia24 Team 🎥
                    </Text>
                    <Text style={footer}>
                        &copy; 2024 MovieLandia24. All rights reserved.
                    </Text>
                </Container>
            </Body>
        </Html>
    );
};

export default NewsletterEmail;


================================================
File: emails/RegistrationEmail.tsx
================================================
import {
    Html,
    Head,
    Preview,
    Body,
    Container,
    Heading,
    Text,
    Button,
    Link,
    Section,
    Img,
} from "@react-email/components";

interface RegistrationEmailProps {
    userName: string;
    email: string;
    token: string;
}

const baseUrl = process.env.NEXT_PUBLIC_APP_URL;

const RegistrationEmail: React.FC<RegistrationEmailProps> = ({ userName, email, token }) => {
    const verificationLink = `${baseUrl}/verify-register?token=${token}&email=${email}`;

    const main = {
        backgroundColor: "#f6f9fc",
        fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
    };

    const container = {
        backgroundColor: "#ffffff",
        margin: "0 auto",
        padding: "32px",
        borderRadius: "12px",
        boxShadow: "0 4px 6px rgba(0, 0, 0, 0.05)",
        maxWidth: "600px",
    };

    const logo = {
        margin: "0 auto",
        width: "150px",
        height: "auto",
    };

    const heading = {
        fontSize: "24px",
        letterSpacing: "-0.5px",
        lineHeight: "1.3",
        fontWeight: "700",
        color: "#484848",
        padding: "17px 0 0",
        textAlign: "center" as const,
    };

    const paragraph = {
        margin: "0 0 15px",
        fontSize: "15px",
        lineHeight: "1.6",
        color: "#3c4149",
        textAlign: "center" as const,
    };

    const buttonContainer = {
        textAlign: "center" as const,
        margin: "24px 0",
    };

    const button = {
        backgroundColor: "#6366f1",
        borderRadius: "6px",
        color: "#fff",
        fontSize: "16px",
        fontWeight: "600",
        textDecoration: "none",
        textAlign: "center" as const,
        padding: "12px 24px",
        transition: "background-color 0.2s",
        display: "inline-block",
    };

    const link = {
        color: "#6366f1",
        fontSize: "14px",
        textDecoration: "underline",
        wordBreak: "break-all" as const,
        display: "inline-block",
        maxWidth: "100%",
    };

    const footer = {
        color: "#706a7b",
        fontSize: "12px",
        lineHeight: "16px",
        textAlign: "center" as const,
        marginTop: "32px",
        padding: "0 24px",
    };

    return (
        <Html>
            <Head />
            <Preview>Welcome to MovieLandia24! Verify your email to get started 🎬</Preview>
            <Body style={main}>
                <Container style={container}>
                    <Section style={{ textAlign: "center" as const }}>
                        <Img
                            src={`${baseUrl}/icons/movielandia24-logo.png`}
                            width="150"
                            height="auto"
                            alt="MovieLandia24"
                            style={logo}
                        />
                    </Section>
                    <Heading style={heading}>
                        Welcome to MovieLandia24, {userName}! 👋
                    </Heading>
                    <Text style={paragraph}>
                        Thank you for joining our community of movie enthusiasts! To start exploring, please verify your email address by clicking the button below.
                    </Text>
                    <Section style={buttonContainer}>
                        <Button href={verificationLink} style={button}>
                            Verify Your Email
                        </Button>
                    </Section>
                    <Text style={{ ...paragraph, fontSize: "14px", color: "#666666" }}>
                        If the button doesn&apos;t work, you can copy and paste this link into your browser:
                    </Text>
                    <Text style={{ ...paragraph, margin: "8px 0 24px" }}>
                        <Link href={verificationLink} style={link}>
                            {verificationLink}
                        </Link>
                    </Text>
                    <Text style={footer}>
                        If you didn&apos;t create an account with MovieLandia24, you can safely ignore this email.
                        <br />
                        <br />
                        2024 MovieLandia24. All rights reserved.
                    </Text>
                </Container>
            </Body>
        </Html>
    );
};

export default RegistrationEmail;


================================================
File: emails/ResetPasswordEmail.tsx
================================================
import {
    Html,
    Head,
    Preview,
    Body,
    Container,
    Heading,
    Text,
    Button,
    Link,
    Section,
    Img,
} from "@react-email/components";

interface ResetPasswordEmailProps {
    userName: string;
    email: string;
    token: string;
}

const baseUrl = process.env.NEXT_PUBLIC_APP_URL;

const ResetPasswordEmail: React.FC<ResetPasswordEmailProps> = ({ userName, email, token }) => {
    const verificationLink = `${baseUrl}/verify-reset-password?token=${token}&email=${email}`;

    const main = {
        backgroundColor: "#f6f9fc",
        fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
    };

    const container = {
        backgroundColor: "#ffffff",
        margin: "40px auto",
        padding: "32px",
        borderRadius: "12px",
        boxShadow: "0 4px 6px rgba(0, 0, 0, 0.05)",
        maxWidth: "600px",
    };

    const logo = {
        margin: "0 auto",
        width: "150px",
        height: "auto",
    };

    const heading = {
        fontSize: "24px",
        letterSpacing: "-0.5px",
        lineHeight: "1.3",
        fontWeight: "700",
        color: "#484848",
        padding: "17px 0 0",
        textAlign: "center" as const,
    };

    const paragraph = {
        margin: "0 0 15px",
        fontSize: "15px",
        lineHeight: "1.6",
        color: "#3c4149",
        textAlign: "center" as const,
    };

    const buttonContainer = {
        textAlign: "center" as const,
        margin: "24px 0",
    };

    const button = {
        backgroundColor: "#6366f1",
        borderRadius: "6px",
        color: "#fff",
        fontSize: "16px",
        fontWeight: "600",
        textDecoration: "none",
        textAlign: "center" as const,
        padding: "12px 24px",
        transition: "background-color 0.2s",
        display: "inline-block",
    };

    const divider = {
        borderTop: "1px solid #e9ecef",
        margin: "32px 0 20px",
    };

    const link = {
        color: "#6366f1",
        fontSize: "14px",
        textDecoration: "underline",
        wordBreak: "break-all" as const,
        display: "inline-block",
        maxWidth: "100%",
    };

    const footer = {
        color: "#706a7b",
        fontSize: "12px",
        lineHeight: "16px",
        textAlign: "center" as const,
        marginTop: "32px",
        padding: "0 24px",
    };

    return (
        <Html>
            <Head />
            <Preview>Reset your MovieLandia24 password 🔐</Preview>
            <Body style={main}>
                <Container style={container}>
                    <Section style={{ textAlign: "center" as const }}>
                        <Img
                            src={`${baseUrl}/icons/movielandia24-logo.png`}
                            width="150"
                            height="auto"
                            alt="MovieLandia24"
                            style={logo}
                        />
                    </Section>
                    <Heading style={heading}>Reset Your Password</Heading>
                    <Text style={paragraph}>
                        Hi {userName}, we received a request to reset your password. Click the button below to create a
                        new password for your MovieLandia24 account.
                    </Text>
                    <Section style={buttonContainer}>
                        <Button href={verificationLink} style={button}>
                            Reset Password
                        </Button>
                    </Section>
                    <Text style={paragraph}>
                        If you didn&apos;t request a password reset, you can safely ignore this email. Your password
                        will remain unchanged.
                    </Text>
                    <Section style={divider} />
                    <Text style={{ ...paragraph, fontSize: "14px", color: "#666666" }}>
                        If the button doesn&apos;t work, you can copy and paste this link into your browser:
                    </Text>
                    <Text style={{ ...paragraph, margin: "8px 0 24px" }}>
                        <Link href={verificationLink} style={link}>
                            {verificationLink}
                        </Link>
                    </Text>
                    <Text style={footer}>
                        &copy; 2024 MovieLandia24. All rights reserved.
                        <br />
                        This is an automated message, please do not reply.
                    </Text>
                </Container>
            </Body>
        </Html>
    );
};

export default ResetPasswordEmail;


================================================
File: prisma/config/prisma.ts
================================================
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
    globalForPrisma.prisma ||
    new PrismaClient({
        log: ["query", "info", "warn", "error"],
        errorFormat: "pretty",
    });

if (process.env.VERCEL_ENV !== "production") globalForPrisma.prisma = prisma;
// if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;


================================================
File: prisma/schema/actor.prisma
================================================
model Actor {
  id                   Int                   @id @default(autoincrement())
  fullname             String
  photoSrc             String                @default("")
  photoSrcProd         String                @default("")
  description          String                @default("")
  debut                String                @default("")
  starredMovies        CastMovie[]
  starredSeries        CastSerie[]
  reviews              ActorReview[]
  usersWhoRatedIt      UserActorRating[]
  usersWhoBookmarkedIt UserActorFavorite[]
  upvoteActorReviews   UpvoteActorReview[]
  downvoteActorReviews DownvoteActorReview[]
}

model ActorReview {
  id        Int                   @id @default(autoincrement())
  content   String                @default("")
  rating    Float?
  createdAt DateTime              @default(now())
  updatedAt DateTime?
  userId    Int
  actorId   Int
  user      User                  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  actor     Actor                 @relation(fields: [actorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteActorReview[]
  downvotes DownvoteActorReview[]
}

model UpvoteActorReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  actorId       Int
  actorReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  actor         Actor        @relation(fields: [actorId], references: [id], onDelete: Cascade)
  actorReview   ActorReview? @relation(fields: [actorReviewId], references: [id], onDelete: Cascade)
}

model DownvoteActorReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  actorId       Int
  actorReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  actor         Actor        @relation(fields: [actorId], references: [id], onDelete: Cascade)
  actorReview   ActorReview? @relation(fields: [actorReviewId], references: [id], onDelete: Cascade)
}


================================================
File: prisma/schema/auth.prisma
================================================
model Account {
  id                String  @id @default(cuid())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}


================================================
File: prisma/schema/crew.prisma
================================================
model Crew {
  id                   Int                  @id @default(autoincrement())
  fullname             String
  photoSrc             String               @default("")
  role                 String               @default("")
  photoSrcProd         String               @default("")
  description          String               @default("")
  debut                String               @default("")
  producedMovies       CrewMovie[]
  producedSeries       CrewSerie[]
  reviews              CrewReview[]
  usersWhoRatedIt      UserCrewRating[]
  usersWhoBookmarkedIt UserCrewFavorite[]
  upvoteCrewReviews    UpvoteCrewReview[]
  downvoteCrewReviews  DownvoteCrewReview[]
}

model CrewReview {
  id        Int                  @id @default(autoincrement())
  content   String               @default("")
  rating    Float?
  createdAt DateTime             @default(now())
  updatedAt DateTime?
  userId    Int
  crewId    Int
  user      User                 @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  crew      Crew                 @relation(fields: [crewId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteCrewReview[]
  downvotes DownvoteCrewReview[]
}

model UpvoteCrewReview {
  id           Int         @id @default(autoincrement())
  userId       Int
  crewId       Int
  crewReviewId Int
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  crew         Crew        @relation(fields: [crewId], references: [id], onDelete: Cascade)
  crewReview   CrewReview? @relation(fields: [crewReviewId], references: [id], onDelete: Cascade)
}

model DownvoteCrewReview {
  id           Int         @id @default(autoincrement())
  userId       Int
  crewId       Int
  crewReviewId Int
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  crew         Crew        @relation(fields: [crewId], references: [id], onDelete: Cascade)
  crewReview   CrewReview? @relation(fields: [crewReviewId], references: [id], onDelete: Cascade)
}


================================================
File: prisma/schema/episode.prisma
================================================
model Episode {
  id                     Int                     @id @default(autoincrement())
  title                  String                  @default("")
  photoSrc               String                  @default("")
  photoSrcProd           String                  @default("")
  trailerSrc             String                  @default("")
  description            String                  @default("")
  duration               Int                     @default(20)
  dateAired              String                  @default("01/01/1990")
  ratingImdb             Float                   @default(5.0)
  seasonId               Int
  season                 Season                  @relation(fields: [seasonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  usersWhoBookmarkedIt   UserEpisodeFavorite[]
  usersWhoRatedIt        UserEpisodeRating[]
  reviews                EpisodeReview[]
  upvoteEpisodeReviews   UpvoteEpisodeReview[]
  downvoteEpisodeReviews DownvoteEpisodeReview[]
}

model EpisodeReview {
  id        Int                     @id @default(autoincrement())
  content   String                  @default("")
  rating    Float?
  createdAt DateTime                @default(now())
  updatedAt DateTime?
  userId    Int
  episodeId Int
  user      User                    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  episode   Episode                 @relation(fields: [episodeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteEpisodeReview[]
  downvotes DownvoteEpisodeReview[]
}

model UpvoteEpisodeReview {
  id              Int            @id @default(autoincrement())
  userId          Int
  episodeId       Int
  episodeReviewId Int
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode         Episode        @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  episodeReview   EpisodeReview? @relation(fields: [episodeReviewId], references: [id], onDelete: Cascade)
}

model DownvoteEpisodeReview {
  id              Int            @id @default(autoincrement())
  userId          Int
  episodeId       Int
  episodeReviewId Int
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode         Episode        @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  episodeReview   EpisodeReview? @relation(fields: [episodeReviewId], references: [id], onDelete: Cascade)
}


================================================
File: prisma/schema/genre.prisma
================================================
model Genre {
  id                   Int                 @id @default(autoincrement())
  name                 String              @default("")
  movies               MovieGenre[]
  series               SerieGenre[]
  usersWhoBookmarkedIt UserGenreFavorite[]
}


================================================
File: prisma/schema/movie.prisma
================================================
model Movie {
  id                   Int                   @id @default(autoincrement())
  title                String                @default("")
  photoSrc             String                @default("")
  photoSrcProd         String                @default("")
  trailerSrc           String                @default("")
  duration             Int                   @default(100)
  ratingImdb           Float                 @default(5.0)
  dateAired            String                @default("11/12/2005")
  description          String                @default("")
  cast                 CastMovie[]
  crew                 CrewMovie[]
  genres               MovieGenre[]
  reviews              MovieReview[]
  usersWhoBookmarkedIt UserMovieFavorite[]
  usersWhoRatedIt      UserMovieRating[]
  upvoteMovieReviews   UpvoteMovieReview[]
  downvoteMovieReviews DownvoteMovieReview[]
}

model MovieReview {
  id        Int                   @id @default(autoincrement())
  content   String                @default("")
  rating    Float?
  createdAt DateTime              @default(now())
  updatedAt DateTime?
  userId    Int
  movieId   Int
  user      User                  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  movie     Movie                 @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteMovieReview[]
  downvotes DownvoteMovieReview[]
}

model UpvoteMovieReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  movieId       Int
  movieReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  movie         Movie        @relation(fields: [movieId], references: [id], onDelete: Cascade)
  movieReview   MovieReview? @relation(fields: [movieReviewId], references: [id], onDelete: Cascade)
}

model DownvoteMovieReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  movieId       Int
  movieReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  movie         Movie        @relation(fields: [movieId], references: [id], onDelete: Cascade)
  movieReview   MovieReview? @relation(fields: [movieReviewId], references: [id], onDelete: Cascade)
}

model CastMovie {
  id      Int   @id @default(autoincrement())
  movieId Int
  actorId Int
  movie   Movie @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  actor   Actor @relation(fields: [actorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model CrewMovie {
  id      Int   @id @default(autoincrement())
  movieId Int
  crewId  Int
  movie   Movie @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  crew    Crew  @relation(fields: [crewId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model MovieGenre {
  id      Int   @id @default(autoincrement())
  movieId Int
  genreId Int
  movie   Movie @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  genre   Genre @relation(fields: [genreId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}


================================================
File: prisma/schema/schema.prisma
================================================
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres", "prismaSchemaFolder"]
}

// generator erd {
//     provider = "prisma-erd-generator"
// }

// generator dbml {
//     provider = "prisma-dbml-generator"
// }

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  // url       = env("POSTGRES_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}


================================================
File: prisma/schema/season.prisma
================================================
model Season {
  id                   Int                    @id @default(autoincrement())
  title                String                 @default("")
  photoSrc             String                 @default("")
  photoSrcProd         String                 @default("")
  trailerSrc           String                 @default("")
  description          String                 @default("")
  dateAired            String                 @default("01/01/1990")
  ratingImdb           Float                  @default(5.0)
  serieId              Int                    @default(1)
  serie                Serie                  @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  episodes             Episode[]
  usersWhoBookmarkedIt UserSeasonFavorite[]
  usersWhoRatedIt      UserSeasonRating[]
  reviews              SeasonReview[]
  UpvoteSeasonReview   UpvoteSeasonReview[]
  DownvoteSeasonReview DownvoteSeasonReview[]
}

model SeasonReview {
  id        Int                    @id @default(autoincrement())
  content   String                 @default("")
  rating    Float?
  createdAt DateTime               @default(now())
  updatedAt DateTime?
  userId    Int
  seasonId  Int
  user      User                   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  season    Season                 @relation(fields: [seasonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteSeasonReview[]
  downvotes DownvoteSeasonReview[]
}

model UpvoteSeasonReview {
  id             Int           @id @default(autoincrement())
  userId         Int
  seasonId       Int
  seasonReviewId Int
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  season         Season        @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  seasonReview   SeasonReview? @relation(fields: [seasonReviewId], references: [id], onDelete: Cascade)
}

model DownvoteSeasonReview {
  id             Int           @id @default(autoincrement())
  userId         Int
  seasonId       Int
  seasonReviewId Int
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  season         Season        @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  seasonReview   SeasonReview? @relation(fields: [seasonReviewId], references: [id], onDelete: Cascade)
}


================================================
File: prisma/schema/serie.prisma
================================================
model Serie {
  id                   Int                   @id @default(autoincrement())
  title                String                @default("")
  photoSrc             String                @default("")
  photoSrcProd         String                @default("")
  trailerSrc           String                @default("")
  description          String                @default("")
  dateAired            String                @default("01/01/2020")
  ratingImdb           Float                 @default(5.0)
  cast                 CastSerie[]
  crew                 CrewSerie[]
  seasons              Season[]
  reviews              SerieReview[]
  genres               SerieGenre[]
  usersWhoBookmarkedIt UserSerieFavorite[]
  usersWhoRatedIt      UserSerieRating[]
  upvoteSerieReviews   UpvoteSerieReview[]
  downvoteSerieReviews DownvoteSerieReview[]
}

model UpvoteSerieReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  serieId       Int
  serieReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  serie         Serie        @relation(fields: [serieId], references: [id], onDelete: Cascade)
  serieReview   SerieReview? @relation(fields: [serieReviewId], references: [id], onDelete: Cascade)
}

model DownvoteSerieReview {
  id            Int          @id @default(autoincrement())
  userId        Int
  serieId       Int
  serieReviewId Int
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  serie         Serie        @relation(fields: [serieId], references: [id], onDelete: Cascade)
  serieReview   SerieReview? @relation(fields: [serieReviewId], references: [id], onDelete: Cascade)
}

model SerieReview {
  id        Int                   @id @default(autoincrement())
  content   String                @default("")
  rating    Float?
  createdAt DateTime              @default(now())
  updatedAt DateTime?
  userId    Int
  serieId   Int
  user      User                  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  serie     Serie                 @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  upvotes   UpvoteSerieReview[]
  downvotes DownvoteSerieReview[]
}

model SerieGenre {
  id      Int   @id @default(autoincrement())
  serieId Int
  genreId Int
  serie   Serie @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  genre   Genre @relation(fields: [genreId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model CastSerie {
  id      Int   @id @default(autoincrement())
  serieId Int
  actorId Int
  serie   Serie @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  actor   Actor @relation(fields: [actorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model CrewSerie {
  id      Int   @id @default(autoincrement())
  serieId Int
  crewId  Int
  serie   Serie @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  crew    Crew  @relation(fields: [crewId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}


================================================
File: prisma/schema/user.prisma
================================================
model User {
  id                      Int                     @id @default(autoincrement())
  userName                String
  email                   String                  @unique
  password                String?
  role                    String                  @default("User")
  bio                     String                  @default("")
  active                  Boolean                 @default(false)
  canResetPassword        Boolean                 @default(false)
  subscribed              Boolean                 @default(false)
  resetPassowrdTokens     ResetPasswordToken[]
  activateTokens          ActivateToken[]
  favMovies               UserMovieFavorite[]
  favSeries               UserSerieFavorite[]
  favGenres               UserGenreFavorite[]
  favSeasons              UserSeasonFavorite[]
  favEpisodes             UserEpisodeFavorite[]
  favActors               UserActorFavorite[]
  favCrew                 UserCrewFavorite[]
  ratingsInMovie          UserMovieRating[]
  ratingsInSerie          UserSerieRating[]
  ratingsInSeason         UserSeasonRating[]
  ratingsInEpisode        UserEpisodeRating[]
  ratingsInActor          UserActorRating[]
  ratingsInCrew           UserCrewRating[]
  movieReviews            MovieReview[]
  serieReviews            SerieReview[]
  seasonReviews           SeasonReview[]
  episodeReviews          EpisodeReview[]
  actorReviews            ActorReview[]
  crewReviews             CrewReview[]
  movieReviewsUpvoted     UpvoteMovieReview[]
  movieReviewsDownvoted   DownvoteMovieReview[]
  serieReviewsUpvoted     UpvoteSerieReview[]
  serieReviewsDownvoted   DownvoteSerieReview[]
  seasonReviewsUpvoted    UpvoteSeasonReview[]
  seasonReviewsDownvoted  DownvoteSeasonReview[]
  episodeReviewsUpvoted   UpvoteEpisodeReview[]
  episodeReviewsDownvoted DownvoteEpisodeReview[]
  actorReviewsUpvoted     UpvoteActorReview[]
  actorReviewsDownvoted   DownvoteActorReview[]
  crewReviewsUpvoted      UpvoteCrewReview[]
  crewReviewsDownvoted    DownvoteCrewReview[]
  avatar                  Avatar?
  followers               UserFollow[]            @relation("UserFollowing")
  following               UserFollow[]            @relation("UserFollowers")
  inboxs                  UserInbox[]
  messagesSent            Message[]               @relation("Sender")
  messagesReceived        Message[]               @relation("Reciever")
  accounts                Account[]
  sessions                Session[]
  notificationsReceived   Notification[]          @relation("NotificationReceiver")
  notificationsSent       Notification[]          @relation("NotificationSender")
}

model ActivateToken {
  id          Int       @id @default(autoincrement())
  token       String    @unique
  createdAt   DateTime  @default(now())
  activatedAt DateTime?
  userId      Int
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model ResetPasswordToken {
  id              Int       @id @default(autoincrement())
  token           String    @unique
  createdAt       DateTime  @default(now())
  resetPasswordAt DateTime?
  userId          Int
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Avatar {
  id       Int    @id @default(autoincrement())
  photoSrc String
  userId   Int    @unique
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserFollow {
  id          Int    @id @default(autoincrement())
  state       String
  follower    User   @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  followerId  Int
  following   User   @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  followingId Int
}

model UserInbox {
  id      Int   @id @default(autoincrement())
  userId  Int
  inboxId Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  inbox   Inbox @relation(fields: [inboxId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Inbox {
  id           Int         @id @default(autoincrement())
  participants UserInbox[]
  messages     Message[]
}

model Message {
  id         Int      @id @default(autoincrement())
  text       String
  sender     User     @relation("Sender", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  senderId   Int
  receiver   User    @relation("Reciever", fields: [receiverId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  receiverId Int
  inbox      Inbox    @relation(fields: [inboxId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  inboxId    Int
  createdAt  DateTime @default(now())
  read       Boolean  @default(false)
  editedAt   DateTime?
}

model UserMovieRating {
  id      Int   @id @default(autoincrement())
  rating  Float
  userId  Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  movieId Int
  movie   Movie @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserSerieRating {
  id      Int   @id @default(autoincrement())
  rating  Float
  userId  Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  serieId Int
  serie   Serie @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserSeasonRating {
  id       Int    @id @default(autoincrement())
  rating   Float
  userId   Int
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  seasonId Int
  season   Season @relation(fields: [seasonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserEpisodeRating {
  id        Int     @id @default(autoincrement())
  rating    Float
  userId    Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  episodeId Int
  episode   Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserActorRating {
  id      Int   @id @default(autoincrement())
  rating  Float
  userId  Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  actorId Int
  actor   Actor @relation(fields: [actorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserCrewRating {
  id     Int   @id @default(autoincrement())
  rating Float
  userId Int
  user   User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  crewId Int
  crew   Crew  @relation(fields: [crewId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserMovieFavorite {
  id      Int   @id @default(autoincrement())
  userId  Int
  movieId Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  movie   Movie @relation(fields: [movieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserGenreFavorite {
  id      Int   @id @default(autoincrement())
  userId  Int
  genreId Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  genre   Genre @relation(fields: [genreId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserSerieFavorite {
  id      Int   @id @default(autoincrement())
  userId  Int
  serieId Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  serie   Serie @relation(fields: [serieId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserEpisodeFavorite {
  id        Int     @id @default(autoincrement())
  userId    Int
  episodeId Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  episode   Episode @relation(fields: [episodeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserSeasonFavorite {
  id       Int    @id @default(autoincrement())
  userId   Int
  seasonId Int
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  season   Season @relation(fields: [seasonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserActorFavorite {
  id      Int   @id @default(autoincrement())
  userId  Int
  actorId Int
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  actor   Actor @relation(fields: [actorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserCrewFavorite {
  id     Int  @id @default(autoincrement())
  userId Int
  crewId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  crew   Crew @relation(fields: [crewId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Notification {
  id        Int      @id @default(autoincrement())
  type      String   
  content   String
  userId    Int
  user      User     @relation("NotificationReceiver", fields: [userId], references: [id], onDelete: Cascade)
  senderId  Int
  sender    User     @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)
  status    String   @default("unread")
  createdAt DateTime @default(now())
}


================================================
File: src/middleware.ts
================================================
import { getToken } from "next-auth/jwt";
import { NextRequestWithAuth, withAuth } from "next-auth/middleware";
import { NextFetchEvent, NextResponse } from "next/server";

export default async function middleware(req: NextRequestWithAuth, event: NextFetchEvent) {
    const token = await getToken({ req });
    const isAuthenticated = !!token;
    const userRole = token?.role;

    if (req.nextUrl.pathname.startsWith("/login") && isAuthenticated) {
        return NextResponse.redirect(new URL("/", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/register") && isAuthenticated) {
        return NextResponse.redirect(new URL("/", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/users") && !isAuthenticated) {
        return NextResponse.redirect(new URL("/login", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/users") && userRole === "Admin") {
        return NextResponse.redirect(new URL("/admin", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/admin") && (!isAuthenticated || userRole !== "Admin")) {
        return NextResponse.redirect(new URL("/login", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/notifications") && !isAuthenticated) {
        return NextResponse.redirect(new URL("/", req.url));
    }

    if (req.nextUrl.pathname.startsWith("/messages") && !isAuthenticated) {
        return NextResponse.redirect(new URL("/", req.url));
    }

    const authMiddleware = await withAuth({
        pages: {
            signIn: req.nextUrl.pathname,
        },
    });

    return authMiddleware(req, event);
}

// Prevented pages if a user is not logged in
export const config = {
    matcher: ["/login", "/register", "/users/:path*", "/admin/:path*", "/notifications", "/messages/:path"],
};


================================================
File: src/actions/actor.actions.ts
================================================
"use server";

import { Actor, Prisma } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { RatingsMap } from "./season.actions";
import { FilterOperator } from "@/types/filterOperators";

interface ActorModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    name?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

// #region "GET Methods"
export async function getActorsWithFilters(
    {
        sortBy,
        ascOrDesc,
        perPage = 12,
        page = 1,
        name,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: ActorModelParams,
    userId?: number,
): Promise<any | null> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (name) filters.name = { contains: name };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    orderByObject[sortBy || "fullname"] = ascOrDesc || "asc";

    const actors = await prisma.actor.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const actorIds = actors.map((actor: Actor) => actor.id);

    const actorRatings = await prisma.actorReview.groupBy({
        by: ["actorId"],
        where: { actorId: { in: actorIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const actorRatingsMap: RatingsMap = actorRatings.reduce((map, rating) => {
        map[rating.actorId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const actorsFinal = await Promise.all(
        actors.map(async (actor) => {
            const { ...properties } = actor;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userActorFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { actorId: actor.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = actorRatingsMap[actor.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const actorsCount = await prisma.actor.count();

    if (actorsFinal) {
        return { actors: actorsFinal, count: actorsCount };
    } else {
        return null;
    }
}

export async function getActors(): Promise<any | null> {
    const actorsAll = await prisma.actor.findMany();

    if (actorsAll) {
        return actorsAll;
    } else {
        return null;
    }
}

export async function getActorById(actorId: number, queryParams: any): Promise<Actor | any | null> {
    const {
        reviewsPage,
        reviewsAscOrDesc,
        reviewsSortBy,
        upvotesPage,
        downvotesPage,
        userId,
        starredMoviesPage,
        starredSeriesPage,
    } = queryParams;

    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const actor = await prisma.actor.findFirst({
            where: {
                id: actorId,
            },
            include: {
                starredMovies: {
                    include: { movie: true },
                    skip: starredMoviesPage ? (starredMoviesPage - 1) * 6 : 0,
                    take: 6,
                },
                starredSeries: {
                    include: { serie: true },
                    skip: starredSeriesPage ? (starredSeriesPage - 1) * 6 : 0,
                    take: 6,
                },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (actor) {
            const totalReviews = await prisma.actorReview.count({
                where: { actorId: actor.id },
            });

            const ratings = await prisma.actorReview.findMany({
                where: { actorId: actor.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of actor.reviews) {
                    const existingUpvote = await prisma.upvoteActorReview.findFirst({
                        where: {
                            AND: [{ userId }, { actorId: actor.id }, { actorReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteActorReview.findFirst({
                        where: {
                            AND: [{ userId }, { actorId: actor.id }, { actorReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;

                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userActorFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { actorId: actor.id }],
                    },
                });
                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.actorReview.findFirst({
                    where: {
                        AND: [{ userId }, { actorId: actor.id }],
                    },
                });
                isReviewed = !!existingReview;
            }

            const [totalMovies, totalSeries] = await Promise.all([
                prisma.castMovie.count({ where: { actorId: actor.id } }),
                prisma.castSerie.count({ where: { actorId: actor.id } }),
            ]);

            return {
                ...actor,
                averageRating,
                totalReviews,
                totalMovies,
                totalSeries,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            return "Actor not found";
        }
    } catch (error) {
        throw new Error("Actor not found");
    }
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateActorById(actorParam: Prisma.ActorUpdateInput, id: string): Promise<Actor | null> {
    const actor: Actor | null = await prisma.actor.findUnique({
        where: { id: Number(id) },
    });

    if (actor) {
        const actorUpdated = await prisma.actor.update({
            where: { id: Number(id) },
            data: actorParam,
        });

        if (actorUpdated) {
            return actorUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addActor(actorParam: Prisma.ActorCreateInput): Promise<Actor | null> {
    try {
        const actorCreated = await prisma.actor.create({
            data: actorParam,
        });

        if (actorCreated) {
            return actorCreated;
        }
    } catch (error) {
        console.error("Error creating actor:", error);
        return null;
    }

    return null;
}

export async function deleteActorById(id: number): Promise<string | null> {
    const actor: Actor | null = await prisma.actor.findUnique({
        where: { id },
    });

    if (actor) {
        const result = await prisma.actor.delete({
            where: { id },
        });

        if (result) {
            return "Actor deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchActorsByTitle(fullname: string, queryParams: any, userId?: number): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "fullname"] = ascOrDesc || "asc";

    const actors = await prisma.actor.findMany({
        where: {
            fullname: { contains: fullname, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const actorIds = actors.map((actor: Actor) => actor.id);

    const actorRatings = await prisma.actorReview.groupBy({
        by: ["actorId"],
        where: { actorId: { in: actorIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const actorRatingsMap: RatingsMap = actorRatings.reduce((map, rating) => {
        map[rating.actorId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const actorsFinal = await Promise.all(
        actors.map(async (actor) => {
            const { ...properties } = actor;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userActorFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { actorId: actor.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = actorRatingsMap[actor.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.actor.count({
        where: {
            fullname: { contains: fullname, mode: "insensitive" },
        },
    });

    if (actors) {
        return { actors: actorsFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/auth.actions.ts
================================================
"use server";

import { hashSync } from "bcrypt";
import { User } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { redirect } from "next/navigation";
import { randomUUID } from "crypto";
import { Resend } from "resend";
import RegistrationEmail from "../../emails/RegistrationEmail";
import ResetPasswordEmail from "../../emails/ResetPasswordEmail";
import NewsletterEmail from "../../emails/NewsletterEmail";

interface IRegister {
    email: string;
    password: string;
    userName: string;
}

interface IResetPassword {
    email: string;
}

interface INewsletterSubscribe {
    email: string;
}

const resend = new Resend(process.env.RESEND_API_KEY);

export async function signUp(userData: IRegister): Promise<User | null | undefined> {
    try {
        const { email, password, userName } = userData;

        const existingUser: User | null = await prisma.user.findUnique({
            where: { email },
        });

        if (existingUser) {
            throw new Error("User already exists.");
        } else {
            const hash = hashSync(password, 7);

            const user: User | null = await prisma.user.create({
                data: { email, password: hash, userName, active: false },
            });

            const token = await prisma.activateToken.create({
                data: {
                    userId: user.id,
                    token: `${randomUUID()}${randomUUID()}`.replace(/-/g, ""),
                },
            });

            if (user && token) {
                await resend.emails.send({
                    from: "MovieLandia24 <onboarding@resend.dev>",
                    to: [email],
                    subject: "Registration Verification - Movielandia24",
                    react: RegistrationEmail({ userName, email, token: token.token }),
                });

                redirect(`/register-verification-sent?email=${encodeURIComponent(email)}`);
            } else {
                throw new Error("Failed to register user.");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function resetPassword(userData: IResetPassword): Promise<any> {
    try {
        const { email } = userData;
        const user = await prisma.user.findUnique({ where: { email } });

        if (!user) {
            redirect("/register");
        }

        const token = await prisma.resetPasswordToken.create({
            data: {
                userId: user.id,
                token: `${randomUUID()}${randomUUID()}`.replace(/-/g, ""),
            },
        });

        await resend.emails.send({
            from: "MovieLandia24 <onboarding@resend.dev>",
            to: [email],
            subject: "Password Reset - Movielandia24",
            react: ResetPasswordEmail({ userName: user.userName, email, token: token.token }),
        });

        redirect(`/reset-password-verification-sent?email=${encodeURIComponent(email)}`);
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function subscribeNewsletter(userData: INewsletterSubscribe): Promise<string> {
    try {
        const { email } = userData;

        const user = await prisma.user.findUnique({
            where: { email },
        });

        if (!user) {
            return "Email does not exist. Please ensure you have entered the correct email.";
        }

        if (user.subscribed) {
            return "You are already subscribed to the newsletter.";
        }

        await prisma.user.update({
            where: { email },
            data: { subscribed: true },
        });

        await resend.emails.send({
            from: "MovieLandia24 <onboarding@resend.dev>",
            to: email,
            subject: "MovieLandia24 Newsletter!",
            react: NewsletterEmail({ userName: user.userName }),
        });

        return "Subscription successful! Check your email for confirmation.";
    } catch (error) {
        return error instanceof Error ? error.message : "An unexpected error occurred.";
    }
}


================================================
File: src/actions/crew.actions.ts
================================================
"use server";

import { Crew, Prisma } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { RatingsMap } from "./season.actions";
import { FilterOperator } from "@/types/filterOperators";

interface CrewModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    fullname?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

// #region "GET Methods"
export async function getCrewMembersWithFilters(
    {
        sortBy,
        ascOrDesc,
        perPage = 12,
        page = 1,
        fullname,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: CrewModelParams,
    userId?: number,
): Promise<any | null> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (fullname) filters.fullname = { contains: fullname };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    orderByObject[sortBy || "fullname"] = ascOrDesc || "asc";

    const crew = await prisma.crew.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const crewIds = crew.map((crew: Crew) => crew.id);

    const crewRatings = await prisma.crewReview.groupBy({
        by: ["crewId"],
        where: { crewId: { in: crewIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const crewRatingsMap: RatingsMap = crewRatings.reduce((map, rating) => {
        map[rating.crewId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const crewFinal = await Promise.all(
        crew.map(async (crewMember) => {
            const { ...properties } = crewMember;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userCrewFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crewMember.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = crewRatingsMap[crewMember.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const crewsCount = await prisma.crew.count();

    if (crewFinal) {
        return { crewMembers: crewFinal, count: crewsCount };
    } else {
        return null;
    }
}

export async function getCrewMemberById(crewId: number, queryParams: any): Promise<Crew | any | null> {
    const {
        reviewsPage,
        reviewsAscOrDesc,
        reviewsSortBy,
        upvotesPage,
        downvotesPage,
        userId,
        producedMoviesPage,
        producedSeriesPage,
    } = queryParams;

    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const crewMember = await prisma.crew.findFirst({
            where: {
                id: crewId,
            },
            include: {
                producedMovies: {
                    include: { movie: true },
                    skip: producedMoviesPage ? (producedMoviesPage - 1) * 6 : 0,
                    take: 6,
                },
                producedSeries: {
                    include: { serie: true },
                    skip: producedSeriesPage ? (producedSeriesPage - 1) * 6 : 0,
                    take: 6,
                },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (crewMember) {
            const totalReviews = await prisma.crewReview.count({
                where: { crewId: crewMember.id },
            });

            const ratings = await prisma.crewReview.findMany({
                where: { crewId: crewMember.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of crewMember.reviews) {
                    const existingUpvote = await prisma.upvoteCrewReview.findFirst({
                        where: {
                            AND: [{ userId }, { crewId: crewMember.id }, { crewReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteCrewReview.findFirst({
                        where: {
                            AND: [{ userId }, { crewId: crewMember.id }, { crewReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;

                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userCrewFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crewMember.id }],
                    },
                });
                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.crewReview.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crewMember.id }],
                    },
                });
                isReviewed = !!existingReview;
            }

            const [totalMovies, totalSeries] = await Promise.all([
                prisma.crewMovie.count({ where: { crewId: crewMember.id } }),
                prisma.crewSerie.count({ where: { crewId: crewMember.id } }),
            ]);

            return {
                ...crewMember,
                averageRating,
                totalReviews,
                totalMovies,
                totalSeries,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            throw new Error("Crew not found");
        }
    } catch (error) {
        throw new Error("Crew not found");
    }
}

export async function getCrewMemberByFullname(crewFullname: string, queryParams: any): Promise<Crew | any | null> {
    const { page, ascOrDesc, sortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = page ? (page - 1) * 5 : 0;
    const take = 5;

    const orderByObject: any = {};
    const fullnameFinal = crewFullname
        .split("")
        .map((char) => (char === "-" ? " " : char))
        .join("");

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const crewMember = await prisma.crew.findFirst({
            where: {
                fullname: fullnameFinal,
            },
            include: {
                producedMovies: { include: { movie: true } },
                producedSeries: { include: { serie: true } },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (crewMember) {
            const totalReviews = await prisma.crewReview.count({
                where: { crewId: crewMember.id },
            });

            const ratings = await prisma.crewReview.findMany({
                where: { crewId: crewMember.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of crewMember.reviews) {
                    const existingUpvote = await prisma.upvoteCrewReview.findFirst({
                        where: {
                            AND: [{ userId }, { crewId: crewMember.id }, { crewReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteCrewReview.findFirst({
                        where: {
                            AND: [{ userId }, { crewId: crewMember.id }, { crewReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;
                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userCrewFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crewMember.id }],
                    },
                });
                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.crewReview.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crewMember.id }],
                    },
                });
                isReviewed = !!existingReview;
            }

            return {
                ...crewMember,
                averageRating,
                totalReviews,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            throw new Error("Crew not found");
        }
    } catch (error) {
        throw new Error("Crew not found");
    }
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateCrewMemberById(crewParam: Prisma.CrewUpdateInput, id: string): Promise<Crew | null> {
    const crewMember: Crew | null = await prisma.crew.findUnique({
        where: { id: Number(id) },
    });

    if (crewMember) {
        const crewMemmberUpdated = await prisma.crew.update({
            where: { id: Number(id) },
            data: crewParam,
        });

        if (crewMemmberUpdated) {
            return crewMemmberUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addCrewMember(crewParam: Crew): Promise<Crew | null> {
    const crewMemberCreated = await prisma.crew.create({
        data: crewParam,
    });

    if (crewMemberCreated) {
        return crewMemberCreated;
    } else {
        return null;
    }
}

export async function deleteCrewMemberById(id: number): Promise<string | null> {
    const crewMember: Crew | null = await prisma.crew.findUnique({
        where: { id },
    });

    if (crewMember) {
        const result = await prisma.crew.delete({
            where: { id },
        });

        if (result) {
            return "Crew deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchCrewMembersByFullname(
    fullname: string,
    queryParams: any,
    userId?: number,
): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "fullname"] = ascOrDesc || "asc";

    const crews = await prisma.crew.findMany({
        where: {
            fullname: { contains: fullname, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const crewIds = crews.map((crew: Crew) => crew.id);

    const crewRatings = await prisma.crewReview.groupBy({
        by: ["crewId"],
        where: { crewId: { in: crewIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const crewRatingsMap: RatingsMap = crewRatings.reduce((map, rating) => {
        map[rating.crewId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const crewsFinal = await Promise.all(
        crews.map(async (crew) => {
            const { ...properties } = crew;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userCrewFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { crewId: crew.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = crewRatingsMap[crew.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.crew.count({
        where: {
            fullname: { contains: fullname, mode: "insensitive" },
        },
    });

    if (crews) {
        return { crews: crewsFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/episode.actions.ts
================================================
"use server";

import { Episode, Prisma } from "@prisma/client";
import { RatingsMap } from "./season.actions";
import { prisma } from "../../prisma/config/prisma";
import { FilterOperator } from "@/types/filterOperators";

interface EpisodeModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    title?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

// #region "GET Methods"
export async function getEpisodesWithFilters({
    sortBy,
    ascOrDesc,
    perPage,
    page,
    title,
    filterValue,
    filterNameString,
    filterOperatorString,
}: EpisodeModelParams): Promise<any | null> {
    const filters: any = {};
    const skip = perPage ? (page ? (page - 1) * perPage : 0) : page ? (page - 1) * 20 : 0;
    const take = perPage || 20;

    if (title) filters.title = { contains: title };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    const orderByObject: any = {};

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    }

    const episodes = await prisma.episode.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    if (episodes) {
        const epispodesCount = await prisma.episode.count();
        return { episodes, count: epispodesCount };
    } else {
        return null;
    }
}

export async function getEpisodes(): Promise<any | null> {
    const episodesAll = await prisma.episode.findMany();

    if (episodesAll) {
        return episodesAll;
    } else {
        return null;
    }
}

export async function getEpisodeById(episodeId: number, queryParams: any): Promise<Episode | any | null> {
    const { reviewsPage, reviewsAscOrDesc, reviewsSortBy, upvotesPage, downvotesPage, userId } = queryParams;
    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const episode = await prisma.episode.findFirst({
            where: { id: episodeId },
            include: {
                season: true,
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (!episode) {
            throw new Error("Episode not found");
        }

        const totalReviews = await prisma.episodeReview.count({
            where: { episodeId: episode.id },
        });

        const ratings = await prisma.episodeReview.findMany({
            where: { episodeId: episode.id },
            select: { rating: true },
        });

        const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

        let isBookmarked = false;
        let isReviewed = false;

        if (userId) {
            for (const review of episode.reviews) {
                const existingUpvote = await prisma.upvoteEpisodeReview.findFirst({
                    where: {
                        AND: [{ userId }, { episodeId: episode.id }, { episodeReviewId: review.id }],
                    },
                });

                const existingDownvote = await prisma.downvoteEpisodeReview.findFirst({
                    where: {
                        AND: [{ userId }, { episodeId: episode.id }, { episodeReviewId: review.id }],
                    },
                });

                // @ts-expect-error type
                review.isUpvoted = !!existingUpvote;

                // @ts-expect-error type
                review.isDownvoted = !!existingDownvote;
            }

            const existingFavorite = await prisma.userEpisodeFavorite.findFirst({
                where: {
                    AND: [{ userId }, { episodeId: episode.id }],
                },
            });

            isBookmarked = !!existingFavorite;

            const existingReview = await prisma.episodeReview.findFirst({
                where: {
                    AND: [{ userId }, { episodeId: episode.id }],
                },
            });

            isReviewed = !!existingReview;
        }

        return {
            ...episode,
            averageRating,
            totalReviews,
            ...(userId && { isBookmarked, isReviewed }),
        };
    } catch (error) {
        throw new Error("Episode not found");
    }
}

export async function getEpisodeByTitle(
    episodeTitle: string,
    seasonId: number,
    queryParams: any,
): Promise<Episode | any | null> {
    const { page, ascOrDesc, sortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = page ? (page - 1) * 5 : 0;
    const take = 5;

    const orderByObject: any = {};
    const titleFinal = episodeTitle
        .split("")
        .map((char) => (char === "-" ? " " : char))
        .join("");

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const episode = await prisma.episode.findFirst({
            where: {
                AND: [{ title: titleFinal }, { seasonId }],
            },
            include: {
                season: true,
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (episode) {
            const totalReviews = await prisma.episodeReview.count({
                where: { episodeId: episode.id },
            });

            const ratings = await prisma.episodeReview.findMany({
                where: { episodeId: episode.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of episode.reviews) {
                    const existingUpvote = await prisma.upvoteEpisodeReview.findFirst({
                        where: {
                            AND: [{ userId }, { episodeId: episode.id }, { episodeReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteEpisodeReview.findFirst({
                        where: {
                            AND: [{ userId }, { episodeId: episode.id }, { episodeReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;

                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userEpisodeFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { episodeId: episode.id }],
                    },
                });
                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.episodeReview.findFirst({
                    where: {
                        AND: [{ userId }, { episodeId: episode.id }],
                    },
                });
                isReviewed = !!existingReview;
            }

            return {
                ...episode,
                averageRating,
                totalReviews,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            throw new Error("Episode not found");
        }
    } catch (error) {
        throw new Error("Episode not found");
    }
}

export async function getLatestEpisodes(seasonId: number): Promise<Episode[] | null> {
    const episodesWithEpisodes = await prisma.episode.findMany({
        orderBy: {
            dateAired: "desc",
        },
        take: 10,
        include: { season: true },
        where: { seasonId },
    });

    const episodeIds = episodesWithEpisodes.map((episode) => episode.id);

    const episodeRatings = await prisma.episodeReview.groupBy({
        by: ["episodeId"],
        where: { episodeId: { in: episodeIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const episodeRatingsMap: RatingsMap = episodeRatings.reduce((map, rating) => {
        map[rating.episodeId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const episodes = episodesWithEpisodes.map((episode) => {
        const { season, ...properties } = episode;
        const ratingsInfo = episodeRatingsMap[episode.id] || { averageRating: 0, totalReviews: 0 };

        return { ...properties, ...ratingsInfo };
    });

    if (episodes) {
        return episodes;
    } else {
        return null;
    }
}

export async function getRelatedEpisodes(
    id: number,
    seasonId: number,
    page: number = 1,
    perPage: number = 6,
): Promise<{ episodes: Episode[] | null; count: number }> {
    const skip = (page - 1) * perPage;

    const episode = await prisma.episode.findFirst({
        where: {
            AND: [{ id }, { seasonId }],
        },
    });

    const episodes = await prisma.episode.findMany({
        where: { NOT: { id: episode?.id }, AND: [{ seasonId }] },
        include: { season: true },
        skip,
        take: perPage,
    });

    const totalCount = await prisma.episode.count({
        where: { NOT: { id: episode?.id }, AND: [{ seasonId }] },
    });

    if (!episodes.length) {
        return { episodes: null, count: 0 };
    }

    const relatedEpisodeIds = episodes.map((rm) => rm.id);

    if (!relatedEpisodeIds.length) {
        return { episodes: null, count: 0 };
    }

    const episodeRatings = await prisma.episodeReview.groupBy({
        by: ["episodeId"],
        where: { episodeId: { in: relatedEpisodeIds } },
        _avg: { rating: true },
        _count: { rating: true },
    });

    const ratingsMap = episodeRatings.reduce(
        (acc, rating) => {
            acc[rating.episodeId] = {
                averageRating: rating._avg.rating || 0,
                totalReviews: rating._count.rating,
            };

            return acc;
        },
        {} as { [key: number]: { averageRating: number; totalReviews: number } },
    );

    const episodesFinal = episodes.map((relatedEpisode) => {
        const { season, ...episodeDetails } = relatedEpisode;
        const ratingsInfo = ratingsMap[relatedEpisode.id] || { averageRating: 0, totalReviews: 0 };

        return { ...episodeDetails, season, ...ratingsInfo };
    });

    return {
        episodes: episodesFinal.length > 0 ? episodesFinal : null,
        count: totalCount,
    };
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateEpisodeById(episodeParam: Prisma.EpisodeUpdateInput, id: string): Promise<Episode | null> {
    const episode: Episode | null = await prisma.episode.findUnique({
        where: { id: Number(id) },
    });

    if (episode) {
        const episodeUpdated = await prisma.episode.update({
            where: { id: Number(id) },
            data: episodeParam,
        });

        if (episodeUpdated) {
            return episodeUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addEpisode(episodeParam: Prisma.EpisodeUncheckedCreateInput): Promise<Episode | null> {
    const episodeCreated = await prisma.episode.create({
        data: episodeParam,
    });

    if (episodeCreated) {
        return episodeCreated;
    } else {
        return null;
    }
}

export async function deleteEpisodeById(id: number): Promise<string | null> {
    const episode: Episode | null = await prisma.episode.findUnique({
        where: { id },
    });

    if (episode) {
        const result = await prisma.episode.delete({
            where: { id },
        });

        if (result) {
            return "Episode deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchEpisodesByTitle(title: string, queryParams: any, userId?: number): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const episodes = await prisma.episode.findMany({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const episodeIds = episodes.map((episode: Episode) => episode.id);

    const episodeRatings = await prisma.episodeReview.groupBy({
        by: ["episodeId"],
        where: { episodeId: { in: episodeIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const episodeRatingsMap: RatingsMap = episodeRatings.reduce((map, rating) => {
        map[rating.episodeId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const episodesFinal = await Promise.all(
        episodes.map(async (episode) => {
            const { ...properties } = episode;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userEpisodeFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { episodeId: episode.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = episodeRatingsMap[episode.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.episode.count({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
    });

    if (episodes) {
        return { episodes: episodesFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/genre.actions.ts
================================================
"use server";

import { Genre, Prisma } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { FilterOperator } from "@/types/filterOperators";

type RatingsMap = {
    [key: number]: {
        averageRating: number;
        totalReviews: number;
    };
};

interface GenreModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    name?: string | null;
    type?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

// #region "GET Methods"
export async function getGenresWithFilters({
    sortBy,
    ascOrDesc,
    perPage = 12,
    page = 1,
    name,
    filterValue,
    filterNameString,
    filterOperatorString,
}: GenreModelParams): Promise<{ rows: Genre[]; count: number }> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (name) filters.name = { contains: name };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    orderByObject[sortBy || "name"] = ascOrDesc || "asc";

    const genres = await prisma.genre.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const genresCount = await prisma.genre.count();

    return { rows: genres, count: genresCount };
}

export async function getGenres(): Promise<Genre[] | null> {
    const genres = await prisma.genre.findMany();

    if (genres) {
        return genres;
    } else {
        return null;
    }
}

export async function getGenreById(
    genreId: number,
    {
        sortBy,
        ascOrDesc,
        perPage,
        page,
        name,
        type,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: GenreModelParams,
    userId?: number,
): Promise<any | null> {
    const filters: any = {};
    const skip = perPage ? (page ? (page - 1) * perPage : 0) : page ? (page - 1) * 20 : 0;
    const take = perPage || 20;

    if (name) filters.name = { contains: name };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    const orderByObject: any = {};

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const genre = await prisma.genre.findFirst({
        where: {
            id: genreId,
        },
    });

    if (genre) {
        if (type === "movie") {
            const result = await prisma.movieGenre.findMany({
                where: {
                    genreId: genre?.id,
                },
                orderBy: {
                    movie: orderByObject,
                },
                skip,
                take,
                select: {
                    movie: true,
                },
            });

            const count = await prisma.movieGenre.count({
                where: {
                    genreId: genre?.id,
                },
            });

            if (result) {
                const movies = await Promise.all(
                    result.map(async (item) => {
                        const isBookmarked = userId
                            ? await prisma.userMovieFavorite.findFirst({
                                  where: {
                                      userId,
                                      movieId: item.movie.id,
                                  },
                              })
                            : null;

                        return {
                            ...item.movie,
                            isBookmarked: !!isBookmarked,
                        };
                    }),
                );

                const movieIds = movies.map((movie) => movie.id);

                const movieRatings = await prisma.movieReview.groupBy({
                    by: ["movieId"],
                    where: { movieId: { in: movieIds } },
                    _avg: {
                        rating: true,
                    },
                    _count: {
                        rating: true,
                    },
                });

                const movieRatingsMap: RatingsMap = movieRatings.reduce((map, rating) => {
                    map[rating.movieId] = {
                        averageRating: rating._avg.rating || 0,
                        totalReviews: rating._count.rating,
                    };

                    return map;
                }, {} as RatingsMap);

                const formattedMovies = movies.map((movie) => {
                    const ratingsInfo = movieRatingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };
                    return { ...movie, ...ratingsInfo };
                });

                return { genre, movies: formattedMovies, count };
            }
        } else if (type === "serie") {
            const result = await prisma.serieGenre.findMany({
                where: {
                    genreId: genre?.id,
                },
                orderBy: {
                    serie: orderByObject,
                },
                skip,
                take,
                select: {
                    serie: true,
                },
            });

            const count = await prisma.serieGenre.count({
                where: {
                    genreId: genre?.id,
                },
            });

            if (result) {
                const series = await Promise.all(
                    result.map(async (item) => {
                        const isBookmarked = userId
                            ? await prisma.userSerieFavorite.findFirst({
                                  where: {
                                      userId,
                                      serieId: item.serie.id,
                                  },
                              })
                            : null;

                        return {
                            ...item.serie,
                            isBookmarked: !!isBookmarked,
                        };
                    }),
                );

                const serieIds = series.map((serie) => serie.id);

                const serieRatings = await prisma.serieReview.groupBy({
                    by: ["serieId"],
                    where: { serieId: { in: serieIds } },
                    _avg: {
                        rating: true,
                    },
                    _count: {
                        rating: true,
                    },
                });

                const serieRatingsMap: RatingsMap = serieRatings.reduce((map, rating) => {
                    map[rating.serieId] = {
                        averageRating: rating._avg.rating || 0,
                        totalReviews: rating._count.rating,
                    };

                    return map;
                }, {} as RatingsMap);

                const formattedSeries = series.map((serie) => {
                    const ratingsInfo = serieRatingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };
                    return { ...serie, ...ratingsInfo };
                });

                return { genre, series: formattedSeries, count };
            }
        } else {
            return null;
        }
    } else {
        throw new Error("Genre not found");
    }
}

export async function getGenreByIdAdmin(genreId: number): Promise<Genre | null> {
    const genre = await prisma.genre.findFirst({
        where: {
            id: genreId,
        },
    });

    if (genre) {
        return genre;
    } else {
        return null;
    }
}

export async function getGenreByName(
    nameGenre: string,
    {
        sortBy,
        ascOrDesc,
        perPage,
        page,
        name,
        type,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: GenreModelParams,
): Promise<any | null> {
    const filters: any = {};
    const skip = perPage ? (page ? (page - 1) * perPage : 0) : page ? (page - 1) * 20 : 0;
    const take = perPage || 20;

    if (name) filters.name = { contains: name };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    const orderByObject: any = {};

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    }

    const genre = await prisma.genre.findFirst({
        where: {
            name: {
                equals: nameGenre,
            },
        },
    });

    if (genre) {
        if (type === "movie") {
            const result = await prisma.movieGenre.findMany({
                where: {
                    genreId: genre?.id,
                },
                orderBy: {
                    movie: orderByObject,
                },
                skip,
                take,
                select: {
                    movie: { include: { genres: { select: { genre: true } } } },
                },
            });

            const count = await prisma.movieGenre.count({
                where: {
                    genreId: genre?.id,
                },
            });

            if (result) {
                const movies = result.map((item) => item.movie);
                const movieIds = movies.map((movie) => movie.id);
                const movieRatings = await prisma.movieReview.groupBy({
                    by: ["movieId"],
                    where: { movieId: { in: movieIds } },
                    _avg: {
                        rating: true,
                    },
                    _count: {
                        rating: true,
                    },
                });

                type RatingsMap = {
                    [key: number]: {
                        averageRating: number;
                        totalReviews: number;
                    };
                };

                const movieRatingsMap: RatingsMap = movieRatings.reduce((map, rating) => {
                    map[rating.movieId] = {
                        averageRating: rating._avg.rating || 0,
                        totalReviews: rating._count.rating,
                    };

                    return map;
                }, {} as RatingsMap);

                const formattedMovies = movies.map((movie) => {
                    const { genres, ...properties } = movie;
                    const simplifiedGenres = genres.map((genre) => genre.genre);
                    const ratingsInfo = movieRatingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };

                    return { ...properties, genres: simplifiedGenres, ...ratingsInfo };
                });

                return { movies: formattedMovies, count };
            }
        } else if (type === "serie") {
            const result = await prisma.serieGenre.findMany({
                where: {
                    genreId: genre?.id,
                },
                orderBy: {
                    serie: orderByObject,
                },
                skip,
                take,
                select: {
                    serie: { include: { genres: { select: { genre: true } } } },
                },
            });

            const count = await prisma.serieGenre.count({
                where: {
                    genreId: genre?.id,
                },
            });

            if (result) {
                const series = result.map((item) => item.serie);
                const serieIds = series.map((serie) => serie.id);
                const serieRatings = await prisma.serieReview.groupBy({
                    by: ["serieId"],
                    where: { serieId: { in: serieIds } },
                    _avg: {
                        rating: true,
                    },
                    _count: {
                        rating: true,
                    },
                });

                type RatingsMap = {
                    [key: number]: {
                        averageRating: number;
                        totalReviews: number;
                    };
                };

                const serieRatingsMap: RatingsMap = serieRatings.reduce((map, rating) => {
                    map[rating.serieId] = {
                        averageRating: rating._avg.rating || 0,
                        totalReviews: rating._count.rating,
                    };

                    return map;
                }, {} as RatingsMap);

                const formattedSeries = series.map((serie) => {
                    const { genres, ...properties } = serie;
                    const simplifiedGenres = genres.map((genre) => genre.genre);
                    const ratingsInfo = serieRatingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };

                    return { ...properties, genres: simplifiedGenres, ...ratingsInfo };
                });

                return { series: formattedSeries, count };
            }
        } else {
            return null;
        }
    } else {
        throw new Error("Genre not found");
    }
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function addGenre(genreData: Prisma.GenreCreateInput): Promise<Genre | null> {
    const genre = await prisma.genre.create({
        data: genreData,
    });

    if (genre) {
        return genre;
    } else {
        return null;
    }
}

export async function updateGenreById(genreData: Prisma.GenreUpdateInput, id: string): Promise<Genre | null> {
    const genreUpdated = await prisma.genre.update({
        where: {
            id: parseInt(id),
        },
        data: genreData,
    });

    if (genreUpdated) {
        return genreUpdated;
    } else {
        return null;
    }
}

export async function deleteGenreById(id: number): Promise<string | null> {
    try {
        const genreDeleted = await prisma.genre.delete({
            where: {
                id,
            },
        });

        if (genreDeleted) {
            return "Genre deleted successfully";
        } else {
            return null;
        }
    } catch (error) {
        throw new Error("Failed to delete genre");
    }
}

export async function searchGenresByName(name: string, page: number): Promise<Genre[] | null> {
    const perPage = 20;
    const skip = perPage * (page - 1);
    const genres = await prisma.genre.findMany({
        where: {
            name: {
                contains: name,
            },
        },
        orderBy: {
            name: "asc",
        },
        skip,
        take: perPage,
    });

    if (genres) {
        return genres;
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/movie.actions.ts
================================================
"use server";

import { Movie, Prisma } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { FilterOperator } from "@/types/filterOperators";

interface MovieModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    title?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

type RatingsMap = {
    [key: number]: {
        averageRating: number;
        totalReviews: number;
    };
};

// #region "GET Methods"
export async function getMoviesWithFilters(
    {
        sortBy,
        ascOrDesc,
        perPage = 12,
        page = 1,
        title,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: MovieModelParams,
    userId?: number,
): Promise<any | null> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (title) filters.title = { contains: title };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const movies = await prisma.movie.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const movieIds = movies.map((movie: Movie) => movie.id);

    const movieRatings = await prisma.movieReview.groupBy({
        by: ["movieId"],
        where: { movieId: { in: movieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const movieRatingsMap: RatingsMap = movieRatings.reduce((map, rating) => {
        map[rating.movieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const moviesFinal = await Promise.all(
        movies.map(async (movie) => {
            const { ...properties } = movie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userMovieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = movieRatingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const moviesCount = await prisma.movie.count();

    return { movies: moviesFinal, count: moviesCount };
}

export async function getMovies(): Promise<any | null> {
    const moviesAll = await prisma.movie.findMany();

    if (moviesAll) {
        return moviesAll;
    } else {
        return null;
    }
}

export async function getMovieById(movieId: number, queryParams: any): Promise<Movie | any | null> {
    const { reviewsPage, reviewsAscOrDesc, reviewsSortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const movie = await prisma.movie.findFirst({
            where: { id: movieId },
            include: {
                genres: { select: { genre: true } },
                cast: {
                    include: { actor: true },
                    skip: queryParams.castPage ? (queryParams.castPage - 1) * 5 : 0,
                    take: 5,
                },
                crew: {
                    include: { crew: true },
                    skip: queryParams.crewPage ? (queryParams.crewPage - 1) * 5 : 0,
                    take: 5,
                },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (!movie) {
            throw new Error("Movie not found");
        }

        const totalReviews = await prisma.movieReview.count({
            where: { movieId: movie.id },
        });

        const ratings = await prisma.movieReview.findMany({
            where: { movieId: movie.id },
            select: { rating: true },
        });

        const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

        let isBookmarked = false;
        let isReviewed = false;

        if (userId) {
            for (const review of movie.reviews) {
                const existingUpvote = await prisma.upvoteMovieReview.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }, { movieReviewId: review.id }],
                    },
                });

                const existingDownvote = await prisma.downvoteMovieReview.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }, { movieReviewId: review.id }],
                    },
                });

                // @ts-expect-error type
                review.isUpvoted = !!existingUpvote;

                // @ts-expect-error type
                review.isDownvoted = !!existingDownvote;
            }

            const existingFavorite = await prisma.userMovieFavorite.findFirst({
                where: {
                    AND: [{ userId }, { movieId: movie.id }],
                },
            });

            isBookmarked = !!existingFavorite;

            const existingReview = await prisma.movieReview.findFirst({
                where: {
                    AND: [{ userId }, { movieId: movie.id }],
                },
            });

            isReviewed = !!existingReview;
        }

        const [totalCast, totalCrew] = await Promise.all([
            prisma.castMovie.count({ where: { movieId: movie.id } }),
            prisma.crewMovie.count({ where: { movieId: movie.id } }),
        ]);

        return {
            ...movie,
            averageRating,
            totalReviews,
            totalCast,
            totalCrew,
            ...(userId && { isBookmarked, isReviewed }),
        };
    } catch (error) {
        throw new Error("Movie not found");
    }
}

export async function getMovieByTitle(title: string, queryParams: any): Promise<Movie | any | null> {
    const { page, ascOrDesc, sortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = page ? (page - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    const titleFinal = title
        .split("")
        .map((char) => (char === "-" ? " " : char))
        .join("");

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const movie = await prisma.movie.findFirst({
            where: { title: titleFinal },
            include: {
                genres: { select: { genre: true } },
                cast: { include: { actor: true } },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (movie) {
            const totalReviews = await prisma.movieReview.count({
                where: { movieId: movie.id },
            });

            const ratings = await prisma.movieReview.findMany({
                where: { movieId: movie.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of movie.reviews) {
                    const existingUpvote = await prisma.upvoteMovieReview.findFirst({
                        where: {
                            AND: [{ userId }, { movieId: movie.id }, { movieReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteMovieReview.findFirst({
                        where: {
                            AND: [{ userId }, { movieId: movie.id }, { movieReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;

                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userMovieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.movieReview.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isReviewed = !!existingReview;
            }

            return {
                ...movie,
                averageRating,
                totalReviews,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            throw new Error("Movie not found");
        }
    } catch (error) {
        throw new Error("Movie not found");
    }
}

export async function getLatestMovies(userId?: number): Promise<Movie[] | null> {
    const movies = await prisma.movie.findMany({
        orderBy: {
            dateAired: "desc",
        },
        take: 6,
    });

    const movieIds = movies.map((movie) => movie.id);

    const movieRatings = await prisma.movieReview.groupBy({
        by: ["movieId"],
        where: { movieId: { in: movieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const movieRatingsMap: RatingsMap = movieRatings.reduce((map, rating) => {
        map[rating.movieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const moviesFinal = await Promise.all(
        movies.map(async (movie) => {
            const { ...properties } = movie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userMovieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = movieRatingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    if (moviesFinal) {
        return moviesFinal;
    } else {
        return null;
    }
}

export async function getRelatedMovies(id: number, userId?: number): Promise<Movie[] | null> {
    const movie = await prisma.movie.findFirst({
        where: { id },
    });

    const movieGenres = await prisma.movieGenre.findMany({
        where: { movieId: movie?.id },
        select: { genreId: true },
    });

    if (!movieGenres.length) {
        return null;
    }

    const genreIds = movieGenres.map((mg) => mg.genreId);
    const relatedMovieIdsByGenre = await prisma.movieGenre.findMany({
        where: {
            genreId: { in: genreIds },
            movieId: { not: movie?.id },
        },
        distinct: ["movieId"],
        select: { movieId: true },
    });

    const relatedMovieIds = relatedMovieIdsByGenre.map((rm) => rm.movieId);

    if (!relatedMovieIds.length) {
        return null;
    }

    const relatedMovies = await prisma.movie.findMany({
        where: { id: { in: relatedMovieIds } },
    });

    const movieRatings = await prisma.movieReview.groupBy({
        by: ["movieId"],
        where: { movieId: { in: relatedMovieIds } },
        _avg: { rating: true },
        _count: { rating: true },
    });

    const ratingsMap = movieRatings.reduce(
        (acc, rating) => {
            acc[rating.movieId] = {
                averageRating: rating._avg.rating || 0,
                totalReviews: rating._count.rating,
            };

            return acc;
        },
        {} as { [key: number]: { averageRating: number; totalReviews: number } },
    );

    const movies = await Promise.all(
        relatedMovies.map(async (movie) => {
            const { ...properties } = movie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userMovieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = ratingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    return movies.length > 0 ? movies : null;
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateMovieById(movieParam: Prisma.MovieUpdateInput, id: string): Promise<Movie | null> {
    const movie: Movie | null = await prisma.movie.findUnique({
        where: { id: Number(id) },
    });

    if (movie) {
        const movieUpdated = await prisma.movie.update({
            where: { id: Number(id) },
            data: movieParam,
            include: { genres: { select: { genre: true } } },
        });

        if (movieUpdated) {
            return movieUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addMovie(movieParam: Prisma.MovieCreateInput): Promise<Movie | null> {
    const movieCreated = await prisma.movie.create({
        data: movieParam,
        include: { genres: { select: { genre: true } } },
    });

    if (movieCreated) {
        return movieCreated;
    } else {
        return null;
    }
}

export async function deleteMovieById(id: number): Promise<string | null> {
    const movie: Movie | null = await prisma.movie.findUnique({
        where: { id },
    });

    if (movie) {
        const result = await prisma.movie.delete({
            where: { id },
        });

        if (result) {
            return "Movie deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchMoviesByTitle(title: string, queryParams: any, userId?: number): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const movies = await prisma.movie.findMany({
        where: { title: { contains: title, mode: "insensitive" } },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const movieIds = movies.map((movie: Movie) => movie.id);

    const movieRatings = await prisma.movieReview.groupBy({
        by: ["movieId"],
        where: { movieId: { in: movieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const movieRatingsMap: RatingsMap = movieRatings.reduce((map, rating) => {
        map[rating.movieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const moviesFinal = await Promise.all(
        movies.map(async (movie) => {
            const { ...properties } = movie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userMovieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { movieId: movie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = movieRatingsMap[movie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.movie.count({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
    });

    if (movies) {
        return { movies: moviesFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/season.actions.ts
================================================
"use server";

import { Season, Prisma } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { FilterOperator } from "@/types/filterOperators";

interface SeasonModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    title?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

export type RatingsMap = {
    [key: number]: {
        averageRating: number;
        totalReviews: number;
    };
};

// #region "GET Methods"
export async function getSeasonsWithFilters({
    sortBy,
    ascOrDesc,
    perPage,
    page,
    title,
    filterValue,
    filterNameString,
    filterOperatorString,
}: SeasonModelParams): Promise<any | null> {
    const filters: any = {};
    const skip = perPage ? (page ? (page - 1) * perPage : 0) : page ? (page - 1) * 20 : 0;
    const take = perPage || 20;

    if (title) filters.title = { contains: title };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    const orderByObject: any = {};

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    }

    const seasons = await prisma.season.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    if (seasons) {
        const seasonsCount = await prisma.season.count();

        return { seasons, count: seasonsCount };
    } else {
        return null;
    }
}

export async function getSeasons(): Promise<any | null> {
    const seasonsAll = await prisma.season.findMany();

    if (seasonsAll) {
        return seasonsAll;
    } else {
        return null;
    }
}

export async function getSeasonById(seasonId: number, queryParams: any): Promise<Season | any | null> {
    const { reviewsPage, reviewsAscOrDesc, reviewsSortBy, upvotesPage, downvotesPage, userId, episodesPage } =
        queryParams;
    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const season = await prisma.season.findFirst({
            where: { id: seasonId },
            include: {
                episodes: {
                    skip: episodesPage ? (episodesPage - 1) * 5 : 0,
                    take: 6,
                },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (!season) {
            throw new Error("Season not found");
        }

        const [totalReviews, totalEpisodes] = await Promise.all([
            prisma.seasonReview.count({ where: { seasonId: season.id } }),
            prisma.episode.count({ where: { seasonId: season.id } }),
        ]);

        const ratings = await prisma.seasonReview.findMany({
            where: { seasonId: season.id },
            select: { rating: true },
        });

        const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

        let isBookmarked = false;
        let isReviewed = false;

        if (userId) {
            for (const review of season.reviews) {
                const existingUpvote = await prisma.upvoteSeasonReview.findFirst({
                    where: {
                        AND: [{ userId }, { seasonId: season.id }, { seasonReviewId: review.id }],
                    },
                });

                const existingDownvote = await prisma.downvoteSeasonReview.findFirst({
                    where: {
                        AND: [{ userId }, { seasonId: season.id }, { seasonReviewId: review.id }],
                    },
                });

                // @ts-expect-error type
                review.isUpvoted = !!existingUpvote;

                // @ts-expect-error type
                review.isDownvoted = !!existingDownvote;
            }

            const existingFavorite = await prisma.userSeasonFavorite.findFirst({
                where: {
                    AND: [{ userId }, { seasonId: season.id }],
                },
            });

            isBookmarked = !!existingFavorite;

            const existingReview = await prisma.seasonReview.findFirst({
                where: {
                    AND: [{ userId }, { seasonId: season.id }],
                },
            });

            isReviewed = !!existingReview;
        }

        return {
            ...season,
            averageRating,
            totalReviews,
            totalEpisodes,
            ...(userId && { isBookmarked, isReviewed }),
        };
    } catch (error) {
        throw new Error("Season not found");
    }
}

export async function getSeasonByTitle(
    seasonTitle: string,
    serieId: number,
    queryParams: any,
): Promise<Season | any | null> {
    const { page, ascOrDesc, sortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = page ? (page - 1) * 5 : 0;
    const take = 5;

    const orderByObject: any = {};
    const titleFinal = seasonTitle
        .split("")
        .map((char) => (char === "-" ? " " : char))
        .join("");

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const season = await prisma.season.findFirst({
            where: {
                AND: [{ title: titleFinal }, { serieId }],
            },
            include: {
                episodes: true,
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
            },
        });

        if (season) {
            const totalReviews = await prisma.seasonReview.count({
                where: { seasonId: season.id },
            });

            const ratings = await prisma.seasonReview.findMany({
                where: { seasonId: season.id },
                select: { rating: true },
            });

            const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
            const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

            let isBookmarked = false;
            let isReviewed = false;

            if (userId) {
                for (const review of season.reviews) {
                    const existingUpvote = await prisma.upvoteSeasonReview.findFirst({
                        where: {
                            AND: [{ userId }, { seasonId: season.id }, { seasonReviewId: review.id }],
                        },
                    });

                    const existingDownvote = await prisma.downvoteSeasonReview.findFirst({
                        where: {
                            AND: [{ userId }, { seasonId: season.id }, { seasonReviewId: review.id }],
                        },
                    });

                    // @ts-expect-error type
                    review.isUpvoted = !!existingUpvote;

                    // @ts-expect-error type
                    review.isDownvoted = !!existingDownvote;
                }

                const existingFavorite = await prisma.userSeasonFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { seasonId: season.id }],
                    },
                });
                isBookmarked = !!existingFavorite;

                const existingReview = await prisma.seasonReview.findFirst({
                    where: {
                        AND: [{ userId }, { seasonId: season.id }],
                    },
                });
                isReviewed = !!existingReview;
            }

            return {
                ...season,
                averageRating,
                totalReviews,
                ...(userId && { isBookmarked, isReviewed }),
            };
        } else {
            throw new Error("Season not found");
        }
    } catch (error) {
        throw new Error("Season not found");
    }
}

export async function getLatestSeasons(serieId: number): Promise<Season[] | null> {
    const seasonsWithEpisodes = await prisma.season.findMany({
        orderBy: {
            dateAired: "desc",
        },
        take: 10,
        include: { episodes: true },
        where: { serieId },
    });

    const seasonIds = seasonsWithEpisodes.map((season) => season.id);

    const seasonRatings = await prisma.seasonReview.groupBy({
        by: ["seasonId"],
        where: { seasonId: { in: seasonIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const seasonRatingsMap: RatingsMap = seasonRatings.reduce((map, rating) => {
        map[rating.seasonId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const seasons = seasonsWithEpisodes.map((season) => {
        const { episodes, ...properties } = season;
        const ratingsInfo = seasonRatingsMap[season.id] || { averageRating: 0, totalReviews: 0 };

        return { ...properties, ...ratingsInfo };
    });

    if (seasons) {
        return seasons;
    } else {
        return null;
    }
}

export async function getRelatedSeasons(
    seasonId: number,
    serieId: number,
    page: number = 1,
    perPage: number = 6,
): Promise<{ seasons: Season[] | null; count: number }> {
    const skip = (page - 1) * perPage;

    const season = await prisma.season.findFirst({
        where: {
            AND: [{ id: seasonId }, { serieId }],
        },
    });

    const seasons = await prisma.season.findMany({
        where: { NOT: { id: season?.id }, AND: [{ serieId }] },
        include: { episodes: true },
        skip,
        take: perPage,
    });

    const totalCount = await prisma.season.count({
        where: { NOT: { id: season?.id }, AND: [{ serieId }] },
    });

    if (!seasons.length) {
        return { seasons: null, count: 0 };
    }

    const relatedSeasonIds = seasons.map((rm) => rm.id);

    if (!relatedSeasonIds.length) {
        return { seasons: null, count: 0 };
    }

    const seasonRatings = await prisma.seasonReview.groupBy({
        by: ["seasonId"],
        where: { seasonId: { in: relatedSeasonIds } },
        _avg: { rating: true },
        _count: { rating: true },
    });

    const ratingsMap = seasonRatings.reduce(
        (acc, rating) => {
            acc[rating.seasonId] = {
                averageRating: rating._avg.rating || 0,
                totalReviews: rating._count.rating,
            };
            return acc;
        },
        {} as { [key: number]: { averageRating: number; totalReviews: number } },
    );

    const seasonsFinal = seasons.map((relatedSeason) => {
        const { episodes, ...seasonDetails } = relatedSeason;
        const ratingsInfo = ratingsMap[relatedSeason.id] || { averageRating: 0, totalReviews: 0 };
        return { ...seasonDetails, episodes, ...ratingsInfo };
    });

    return {
        seasons: seasonsFinal.length > 0 ? seasonsFinal : null,
        count: totalCount,
    };
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateSeasonById(seasonParam: Prisma.SeasonUpdateInput, id: string): Promise<Season | null> {
    const season: Season | null = await prisma.season.findUnique({
        where: { id: Number(id) },
    });

    if (season) {
        const seasonUpdated = await prisma.season.update({
            where: { id: Number(id) },
            data: seasonParam,
        });

        if (seasonUpdated) {
            return seasonUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addSeason(seasonParam: Prisma.SeasonCreateInput): Promise<Season | null> {
    const seasonCreated = await prisma.season.create({
        data: seasonParam,
    });

    if (seasonCreated) {
        return seasonCreated;
    } else {
        return null;
    }
}

export async function deleteSeasonById(id: number): Promise<string | null> {
    const season: Season | null = await prisma.season.findUnique({
        where: { id },
    });

    if (season) {
        const result = await prisma.season.delete({
            where: { id },
        });

        if (result) {
            return "Season deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchSeasonsByTitle(title: string, queryParams: any, userId?: number): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const seasons = await prisma.season.findMany({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const seasonIds = seasons.map((season: Season) => season.id);

    const seasonRatings = await prisma.seasonReview.groupBy({
        by: ["seasonId"],
        where: { seasonId: { in: seasonIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const seasonRatingsMap: RatingsMap = seasonRatings.reduce((map, rating) => {
        map[rating.seasonId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const seasonsFinal = await Promise.all(
        seasons.map(async (season) => {
            const { ...properties } = season;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userSeasonFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { seasonId: season.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = seasonRatingsMap[season.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.season.count({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
    });

    if (seasons) {
        return { seasons: seasonsFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/serie.actions.ts
================================================
"use server";

import { Prisma, Serie } from "@prisma/client";
import { prisma } from "../../prisma/config/prisma";
import { FilterOperator } from "@/types/filterOperators";

interface SerieModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    title?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

type RatingsMap = {
    [key: number]: {
        averageRating: number;
        totalReviews: number;
    };
};

// #region "GET Methods"
export async function getSeriesWithFilters(
    {
        sortBy,
        ascOrDesc,
        perPage = 12,
        page = 1,
        title,
        filterValue,
        filterNameString,
        filterOperatorString,
    }: SerieModelParams,
    userId?: number,
): Promise<any | null> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (title) filters.title = { contains: title };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const series = await prisma.serie.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const serieIds = series.map((serie) => serie.id);

    const serieRatings = await prisma.serieReview.groupBy({
        by: ["serieId"],
        where: { serieId: { in: serieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const serieRatingsMap: RatingsMap = serieRatings.reduce((map, rating) => {
        map[rating.serieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const seriesFinal = await Promise.all(
        series.map(async (serie) => {
            const { ...properties } = serie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userSerieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = serieRatingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.serie.count();

    if (seriesFinal) {
        return { rows: seriesFinal, count };
    } else {
        return null;
    }
}

export async function getSeries(): Promise<any | null> {
    const seriesAll = await prisma.serie.findMany();

    if (seriesAll) {
        return seriesAll;
    } else {
        return null;
    }
}

export async function getSerieById(id: number, queryParams: any): Promise<Serie | any | null> {
    const { reviewsPage, reviewsAscOrDesc, reviewsSortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = reviewsPage ? (reviewsPage - 1) * 5 : 0;
    const take = 5;
    const orderByObject: any = {};

    if (reviewsSortBy && reviewsAscOrDesc) {
        orderByObject[reviewsSortBy] = reviewsAscOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const serie = await prisma.serie.findFirst({
            where: { id },
            include: {
                genres: { select: { genre: true } },
                cast: {
                    include: { actor: true },
                    skip: queryParams.castPage ? (queryParams.castPage - 1) * 5 : 0,
                    take: 5,
                },
                crew: {
                    include: { crew: true },
                    skip: queryParams.crewPage ? (queryParams.crewPage - 1) * 5 : 0,
                    take: 5,
                },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
                seasons: {
                    skip: queryParams.seasonsPage ? (queryParams.seasonsPage - 1) * 5 : 0,
                    take: 6,
                },
            },
        });

        if (!serie) {
            throw new Error("Serie not found");
        }

        const totalReviews = await prisma.serieReview.count({
            where: { serieId: serie.id },
        });

        const ratings = await prisma.serieReview.findMany({
            where: { serieId: serie.id },
            select: { rating: true },
        });

        const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

        let isBookmarked = false;
        let isReviewed = false;

        if (userId) {
            for (const review of serie.reviews) {
                const existingUpvote = await prisma.upvoteSerieReview.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }, { serieReviewId: review.id }],
                    },
                });

                const existingDownvote = await prisma.downvoteSerieReview.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }, { serieReviewId: review.id }],
                    },
                });

                // @ts-expect-error type
                review.isUpvoted = !!existingUpvote;

                // @ts-expect-error type
                review.isDownvoted = !!existingDownvote;
            }

            const existingFavorite = await prisma.userSerieFavorite.findFirst({
                where: {
                    AND: [{ userId }, { serieId: serie.id }],
                },
            });

            isBookmarked = !!existingFavorite;

            const existingReview = await prisma.serieReview.findFirst({
                where: {
                    AND: [{ userId }, { serieId: serie.id }],
                },
            });

            isReviewed = !!existingReview;
        }

        const [totalCast, totalCrew, totalSeasons] = await Promise.all([
            prisma.castSerie.count({ where: { serieId: serie.id } }),
            prisma.crewSerie.count({ where: { serieId: serie.id } }),
            prisma.season.count({ where: { serieId: serie.id } }),
        ]);

        return {
            ...serie,
            averageRating,
            totalReviews,
            totalCast,
            totalCrew,
            totalSeasons,
            ...(userId && { isBookmarked, isReviewed }),
        };
    } catch (error) {
        throw new Error("Serie not found");
    }
}

export async function getSerieByTitle(title: string, queryParams: any): Promise<Serie | any | null> {
    const { page, ascOrDesc, sortBy, upvotesPage, downvotesPage, userId } = queryParams;

    const skip = page ? (page - 1) * 5 : 0;
    const take = 5;

    const orderByObject: any = {};

    const titleFinal = title
        .split("")
        .map((char) => (char === "-" ? " " : char))
        .join("");

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    } else {
        orderByObject["createdAt"] = "desc";
    }

    try {
        const serie = await prisma.serie.findFirst({
            where: { title: titleFinal },
            include: {
                genres: { select: { genre: true } },
                cast: { include: { actor: true } },
                reviews: {
                    include: {
                        user: true,
                        upvotes: {
                            take: upvotesPage ? upvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        downvotes: {
                            take: downvotesPage ? downvotesPage * 5 : 5,
                            select: { user: true },
                        },
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    orderBy: orderByObject,
                    skip: skip,
                    take: take,
                },
                seasons: true,
            },
        });

        if (!serie) {
            throw new Error("Serie not found");
        }

        const totalReviews = await prisma.serieReview.count({
            where: { serieId: serie.id },
        });

        const ratings = await prisma.serieReview.findMany({
            where: { serieId: serie.id },
            select: { rating: true },
        });

        const totalRating = ratings.reduce((sum, review) => sum + review!.rating!, 0);
        const averageRating = totalReviews > 0 ? totalRating / totalReviews : 0;

        let isBookmarked = false;
        let isReviewed = false;

        if (userId) {
            for (const review of serie.reviews) {
                const existingUpvote = await prisma.upvoteSerieReview.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }, { serieReviewId: review.id }],
                    },
                });

                const existingDownvote = await prisma.downvoteSerieReview.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }, { serieReviewId: review.id }],
                    },
                });

                // @ts-expect-error type
                review.isUpvoted = !!existingUpvote;

                // @ts-expect-error type
                review.isDownvoted = !!existingDownvote;
            }

            const existingFavorite = await prisma.userSerieFavorite.findFirst({
                where: {
                    AND: [{ userId }, { serieId: serie.id }],
                },
            });
            isBookmarked = !!existingFavorite;

            const existingReview = await prisma.serieReview.findFirst({
                where: {
                    AND: [{ userId }, { serieId: serie.id }],
                },
            });
            isReviewed = !!existingReview;
        }

        return {
            ...serie,
            averageRating,
            totalReviews,
            ...(userId && { isBookmarked, isReviewed }),
        };
    } catch (error) {
        throw new Error("Serie not found");
    }
}

export async function getLatestSeries(userId?: number): Promise<Serie[] | null> {
    const series = await prisma.serie.findMany({
        orderBy: {
            dateAired: "desc",
        },
        take: 6,
    });

    const serieIds = series.map((serie) => serie.id);

    const serieRatings = await prisma.serieReview.groupBy({
        by: ["serieId"],
        where: { serieId: { in: serieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const serieRatingsMap: RatingsMap = serieRatings.reduce((map, rating) => {
        map[rating.serieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const seriesFinal = await Promise.all(
        series.map(async (serie) => {
            const { ...properties } = serie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userSerieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = serieRatingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    if (seriesFinal) {
        return seriesFinal;
    } else {
        return null;
    }
}

export async function getRelatedSeries(id: number, userId?: number): Promise<Serie[] | null> {
    const serie = await prisma.serie.findFirst({
        where: { id },
    });

    const seriesGenres = await prisma.serieGenre.findMany({
        where: { serieId: serie?.id },
        select: { genreId: true },
    });

    if (!seriesGenres.length) {
        return null;
    }

    const genreIds = seriesGenres.map((sg) => sg.genreId);
    const relatedSerieIdsByGenre = await prisma.serieGenre.findMany({
        where: {
            genreId: { in: genreIds },
            serieId: { not: serie?.id },
        },
        distinct: ["serieId"],
        select: { serieId: true },
    });

    const relatedSerieIds = relatedSerieIdsByGenre.map((rs) => rs.serieId);

    if (!relatedSerieIds.length) {
        return null;
    }

    const relatedSeries = await prisma.serie.findMany({
        where: { id: { in: relatedSerieIds } },
    });

    const serieRatings = await prisma.serieReview.groupBy({
        by: ["serieId"],
        where: { serieId: { in: relatedSerieIds } },
        _avg: { rating: true },
        _count: { rating: true },
    });

    const ratingsMap = serieRatings.reduce(
        (acc, rating) => {
            acc[rating.serieId] = {
                averageRating: rating._avg.rating || 0,
                totalReviews: rating._count.rating,
            };

            return acc;
        },
        {} as { [key: number]: { averageRating: number; totalReviews: number } },
    );

    const series = await Promise.all(
        relatedSeries.map(async (serie) => {
            const { ...properties } = serie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userSerieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = ratingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    return series.length > 0 ? series : null;
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateSerieById(serieParam: Prisma.SerieUpdateInput, id: string): Promise<Serie | null> {
    const serie: Serie | null = await prisma.serie.findUnique({
        where: { id: Number(id) },
    });

    if (serie) {
        const serieUpdated = await prisma.serie.update({
            where: { id: Number(id) },
            data: serieParam,
            include: { genres: { select: { genre: true } } },
        });

        if (serieUpdated) {
            return serieUpdated;
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function addSerie(serieParam: Prisma.SerieCreateInput): Promise<Serie | null> {
    const serieCreated = await prisma.serie.create({
        data: serieParam,
        include: { genres: { select: { genre: true } } },
    });

    if (serieCreated) {
        return serieCreated;
    } else {
        return null;
    }
}

export async function deleteSerieById(id: number): Promise<string | null> {
    const serie: Serie | null = await prisma.serie.findUnique({
        where: { id },
    });

    if (serie) {
        const result = await prisma.serie.delete({
            where: { id },
        });

        if (result) {
            return "Serie deleted successfully";
        } else {
            return null;
        }
    } else {
        return null;
    }
}

export async function searchSeriesByTitle(title: string, queryParams: any, userId?: number): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "title"] = ascOrDesc || "asc";

    const series = await prisma.serie.findMany({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const serieIds = series.map((serie) => serie.id);

    const serieRatings = await prisma.serieReview.groupBy({
        by: ["serieId"],
        where: { serieId: { in: serieIds } },
        _avg: {
            rating: true,
        },
        _count: {
            rating: true,
        },
    });

    const serieRatingsMap: RatingsMap = serieRatings.reduce((map, rating) => {
        map[rating.serieId] = {
            averageRating: rating._avg.rating || 0,
            totalReviews: rating._count.rating,
        };

        return map;
    }, {} as RatingsMap);

    const seriesFinal = await Promise.all(
        series.map(async (serie) => {
            const { ...properties } = serie;

            let isBookmarked = false;

            if (userId) {
                const existingFavorite = await prisma.userSerieFavorite.findFirst({
                    where: {
                        AND: [{ userId }, { serieId: serie.id }],
                    },
                });

                isBookmarked = !!existingFavorite;
            }

            const ratingsInfo = serieRatingsMap[serie.id] || { averageRating: 0, totalReviews: 0 };

            return { ...properties, ...ratingsInfo, ...(userId && { isBookmarked }) };
        }),
    );

    const count = await prisma.serie.count({
        where: {
            title: { contains: title, mode: "insensitive" },
        },
    });

    if (series) {
        return { rows: seriesFinal, count };
    } else {
        return null;
    }
}
// #endregion


================================================
File: src/actions/review/reviewVotes.actions.ts
================================================
"use server";

import { prisma } from "../../../prisma/config/prisma";

type ReviewType = "movie" | "serie" | "season" | "episode" | "actor" | "crew";

interface VotesResponse {
    items: any;
    total: number;
}

export async function getUpvotesByReviewId(
    reviewId: number,
    type: ReviewType,
    page: number = 1,
    perPage: number = 10,
): Promise<VotesResponse> {
    const skip = (page - 1) * perPage;

    let upvotes;
    let total;

    switch (type) {
        case "movie":
            [upvotes, total] = await Promise.all([
                prisma.upvoteMovieReview.findMany({
                    where: { movieReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteMovieReview.count({
                    where: { movieReviewId: reviewId },
                }),
            ]);
            break;
        case "serie":
            [upvotes, total] = await Promise.all([
                prisma.upvoteSerieReview.findMany({
                    where: { serieReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteSerieReview.count({
                    where: { serieReviewId: reviewId },
                }),
            ]);
            break;
        case "season":
            [upvotes, total] = await Promise.all([
                prisma.upvoteSeasonReview.findMany({
                    where: { seasonReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteSeasonReview.count({
                    where: { seasonReviewId: reviewId },
                }),
            ]);
            break;
        case "episode":
            [upvotes, total] = await Promise.all([
                prisma.upvoteEpisodeReview.findMany({
                    where: { episodeReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteEpisodeReview.count({
                    where: { episodeReviewId: reviewId },
                }),
            ]);
            break;
        case "actor":
            [upvotes, total] = await Promise.all([
                prisma.upvoteActorReview.findMany({
                    where: { actorReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteActorReview.count({
                    where: { actorReviewId: reviewId },
                }),
            ]);
            break;
        case "crew":
            [upvotes, total] = await Promise.all([
                prisma.upvoteCrewReview.findMany({
                    where: { crewReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.upvoteCrewReview.count({
                    where: { crewReviewId: reviewId },
                }),
            ]);
            break;
        default:
            throw new Error("Invalid review type");
    }

    return {
        items: upvotes,
        total,
    };
}

export async function getDownvotesByReviewId(
    reviewId: number,
    type: ReviewType,
    page: number = 1,
    perPage: number = 10,
): Promise<VotesResponse> {
    const skip = (page - 1) * perPage;

    let downvotes;
    let total;

    switch (type) {
        case "movie":
            [downvotes, total] = await Promise.all([
                prisma.downvoteMovieReview.findMany({
                    where: { movieReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteMovieReview.count({
                    where: { movieReviewId: reviewId },
                }),
            ]);
            break;
        case "serie":
            [downvotes, total] = await Promise.all([
                prisma.downvoteSerieReview.findMany({
                    where: { serieReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteSerieReview.count({
                    where: { serieReviewId: reviewId },
                }),
            ]);
            break;
        case "season":
            [downvotes, total] = await Promise.all([
                prisma.downvoteSeasonReview.findMany({
                    where: { seasonReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteSeasonReview.count({
                    where: { seasonReviewId: reviewId },
                }),
            ]);
            break;
        case "episode":
            [downvotes, total] = await Promise.all([
                prisma.downvoteEpisodeReview.findMany({
                    where: { episodeReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteEpisodeReview.count({
                    where: { episodeReviewId: reviewId },
                }),
            ]);
            break;
        case "actor":
            [downvotes, total] = await Promise.all([
                prisma.downvoteActorReview.findMany({
                    where: { actorReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteActorReview.count({
                    where: { actorReviewId: reviewId },
                }),
            ]);
            break;
        case "crew":
            [downvotes, total] = await Promise.all([
                prisma.downvoteCrewReview.findMany({
                    where: { crewReviewId: reviewId },
                    include: { user: true },
                    skip,
                    take: perPage,
                }),
                prisma.downvoteCrewReview.count({
                    where: { crewReviewId: reviewId },
                }),
            ]);
            break;
        default:
            throw new Error("Invalid review type");
    }

    return {
        items: downvotes,
        total,
    };
}


================================================
File: src/actions/user/user.actions.ts
================================================
"use server";

import { headers } from "next/headers";
import { Prisma, User } from "@prisma/client";
import { prisma } from "../../../prisma/config/prisma";
import { revalidatePath } from "next/cache";
import { FilterOperator } from "@/types/filterOperators";

// #region "Interfaces"
export interface UserModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    title?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

export interface AddReviewMovieParams {
    content: string;
    createdAt?: Date;
    rating: number;
    userId: number;
    movieId: number;
}

export interface AddReviewSerieParams {
    content: string;
    createdAt?: Date;
    rating: number;
    userId: number;
    serieId: number;
}

export interface UpdateReviewMovieParams {
    content: string;
    updatedAt?: Date;
    rating: number;
    userId: number;
    movieId: number;
}

export interface UpdateReviewSerieParams {
    content: string;
    updatedAt?: Date;
    rating: number;
    userId: number;
    serieId: number;
}

export interface RemoveReviewMovieParams {
    userId: number;
    movieId: number;
}

export interface RemoveReviewSerieParams {
    userId: number;
    serieId: number;
}

export interface RemoveReviewSeasonParams {
    userId: number;
    seasonId: number;
}

export interface RemoveReviewEpisodeParams {
    userId: number;
    episodeId: number;
}

export interface RemoveReviewActorParams {
    userId: number;
    actorId: number;
}

export interface RemoveReviewCrewParams {
    userId: number;
    crewId: number;
}

export interface VoteMovieReviewParams {
    userId: number;
    movieId: number;
    movieReviewId: number;
}

export interface VoteSerieReviewParams {
    userId: number;
    serieId: number;
    serieReviewId: number;
}

export interface VoteSeasonReviewParams {
    userId: number;
    seasonId: number;
    seasonReviewId: number;
}

export interface VoteEpisodeReviewParams {
    userId: number;
    episodeId: number;
    episodeReviewId: number;
}

export interface VoteActorReviewParams {
    userId: number;
    actorId: number;
    actorReviewId: number;
}

export interface VoteCrewReviewParams {
    userId: number;
    crewId: number;
    crewReviewId: number;
}

export interface UserModelParams {
    sortBy?: string;
    ascOrDesc?: string;
    perPage?: number;
    page?: number;
    userName?: string | null;
    filterValue?: number | string;
    filterNameString?: string | null;
    filterOperatorString?: FilterOperator;
}

// #endregion

// #region "Utils"
export async function getReferer() {
    const headersList = headers() as any;
    const referer = headersList.get("referer");

    if (referer) {
        return referer;
    } else {
        return "/";
    }
}
// #endregion

// #region "CRUD"

// #region "GET Methods"
export async function getUsersWithFilters({
    sortBy,
    ascOrDesc,
    perPage = 12,
    page = 1,
    userName,
    filterValue,
    filterNameString,
    filterOperatorString,
}: UserModelParams): Promise<{ users: User[]; count: number }> {
    const filters: any = {};
    const orderByObject: any = {};

    const skip = (page - 1) * perPage;
    const take = perPage;

    if (userName) filters.userName = { contains: userName };

    if (filterValue !== undefined && filterNameString && filterOperatorString) {
        if (filterOperatorString === "contains") {
            filters[filterNameString] = { contains: filterValue };
        } else {
            const operator = filterOperatorString === ">" ? "gt" : filterOperatorString === "<" ? "lt" : "equals";
            filters[filterNameString] = { [operator]: filterValue };
        }
    }

    if (sortBy && ascOrDesc) {
        orderByObject[sortBy] = ascOrDesc;
    }

    const users = await prisma.user.findMany({
        where: filters,
        orderBy: orderByObject,
        skip,
        take,
    });

    const usersCount = await prisma.user.count();

    return { users, count: usersCount };
}

export async function getUsers(): Promise<any | null> {
    const users = await prisma.user.findMany();

    if (users) {
        return users;
    } else {
        return null;
    }
}

export async function getUserById(userId: number, userLoggedInId?: number): Promise<User | null> {
    const user = await prisma.user.findUnique({
        where: { id: userId },
        include: {
            avatar: true,
        },
    });

    if (user) {
        let isFollowed: boolean = false;
        let isFollowedStatus: string | null = null;

        if (userLoggedInId) {
            const existingFollow = await prisma.userFollow.findFirst({
                where: {
                    followerId: userLoggedInId,
                    followingId: userId,
                },
            });

            if (existingFollow) {
                isFollowed = true;
                isFollowedStatus = existingFollow.state;
            }
        }

        return { ...user, ...(userLoggedInId && { isFollowed, isFollowedStatus }) };
    }

    return null;
}

export async function getUsernameByUserId(userId: number): Promise<string> {
    const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { userName: true },
    });

    try {
        if (user) {
            return user.userName;
        } else {
            throw new Error("User not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function getUserByUsername(userName: string, userLoggedInId: number): Promise<User | null> {
    const user = await prisma.user.findFirst({
        where: { userName },
        include: {
            avatar: true,
        },
    });

    if (user) {
        let isFollowed: boolean = false;
        let isFollowedStatus: string | null = null;

        if (userLoggedInId) {
            const existingFollow = await prisma.userFollow.findFirst({
                where: {
                    followerId: userLoggedInId,
                },
            });

            if (existingFollow) {
                isFollowed = true;
                isFollowedStatus = existingFollow.state;
            }
        }

        return { ...user, ...(userLoggedInId && { isFollowed, isFollowedStatus }) };
    } else {
        return null;
    }
}
// #endregion

// #region "Other Methods UPDATE, CREATE, DELETE, and SEARCH"
export async function updateUserByIdAdmin(userParam: Prisma.UserUpdateInput, id: number): Promise<User | null> {
    try {
        const updatedUser = await prisma.user.update({
            where: { id },
            data: userParam,
        });

        if (updatedUser) {
            return updatedUser;
            // revalidatePath(`/users/${updatedUser.id}/${updatedUser.userName}`, "page");
        } else {
            // throw new Error("Failed to update user.");
            return null;
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function updateUserById(userParam: Prisma.UserUpdateInput, id: number): Promise<void> {
    try {
        const updatedUser = await prisma.user.update({
            where: { id },
            data: userParam,
        });

        if (updatedUser) {
            revalidatePath(`/users/${updatedUser.id}/${updatedUser.userName}`, "page");
        } else {
            throw new Error("Failed to update user.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function deleteUserById(id: number): Promise<string | null> {
    const user = await prisma.user.findUnique({
        where: { id },
    });

    if (user) {
        await prisma.user.delete({
            where: { id },
        });
        return "User deleted successfully";
    } else {
        return null;
    }
}

export async function searchUsersByUsername(userName: string, queryParams: any): Promise<any | null> {
    const { page, ascOrDesc, sortBy } = queryParams;
    const orderByObject: any = {};

    orderByObject[sortBy || "userName"] = ascOrDesc || "asc";

    const users = await prisma.user.findMany({
        where: {
            userName: { contains: userName, mode: "insensitive" },
        },
        orderBy: orderByObject,
        skip: page ? (page - 1) * 12 : 0,
        take: 12,
    });

    const count = await prisma.user.count({
        where: {
            userName: { contains: userName, mode: "insensitive" },
        },
    });

    if (users) {
        return { users, count };
    } else {
        return null;
    }
}
// #endregion

// #endregion


================================================
File: src/actions/user/userBookmarks.actions.ts
================================================
"use server";

import { revalidatePath } from "next/cache";
import { prisma } from "../../../prisma/config/prisma";
import { getReferer } from "./user.actions";

// #region "Bookmarks"

// #region "Add Favorite"
export async function addFavoriteSerieToUser(userId: number, serieId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userSerieFavorite.findFirst({
            where: {
                AND: [{ userId }, { serieId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This serie is already in your favorites.");
        }

        const serie = await prisma.serie.findUnique({
            where: {
                id: serieId,
            },
        });

        if (!serie) {
            throw new Error("Serie not found.");
        }

        const result = await prisma.userSerieFavorite.create({
            data: { userId, serieId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add serie to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addFavoriteMovieToUser(userId: number, movieId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userMovieFavorite.findFirst({
            where: {
                AND: [{ userId }, { movieId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This movie is already in your favorites.");
        }

        const movie = await prisma.movie.findUnique({
            where: {
                id: movieId,
            },
        });

        if (!movie) {
            throw new Error("Movie not found.");
        }

        const result = await prisma.userMovieFavorite.create({
            data: { userId, movieId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add movie to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addFavoriteSeasonToUser(userId: number, seasonId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userSeasonFavorite.findFirst({
            where: {
                AND: [{ userId }, { seasonId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This season is already in your favorites.");
        }

        const season = await prisma.season.findUnique({
            where: {
                id: seasonId,
            },
        });

        if (!season) {
            throw new Error("Season not found.");
        }

        const result = await prisma.userSeasonFavorite.create({
            data: { userId, seasonId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add season to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addFavoriteEpisodeToUser(userId: number, episodeId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userEpisodeFavorite.findFirst({
            where: {
                AND: [{ userId }, { episodeId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This episode is already in your favorites.");
        }

        const episode = await prisma.episode.findUnique({
            where: {
                id: episodeId,
            },
        });

        if (!episode) {
            throw new Error("Episode not found.");
        }

        const result = await prisma.userEpisodeFavorite.create({
            data: { userId, episodeId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add episode to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addFavoriteActorToUser(userId: number, actorId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userActorFavorite.findFirst({
            where: {
                AND: [{ userId }, { actorId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This actor is already in your favorites.");
        }

        const actor = await prisma.actor.findUnique({
            where: {
                id: actorId,
            },
        });

        if (!actor) {
            throw new Error("Actor not found.");
        }

        const result = await prisma.userActorFavorite.create({
            data: { userId, actorId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add actor to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addFavoriteCrewToUser(userId: number, crewId: number): Promise<void> {
    try {
        const existingFavorite = await prisma.userCrewFavorite.findFirst({
            where: {
                AND: [{ userId }, { crewId }],
            },
        });

        if (existingFavorite) {
            throw new Error("This crew is already in your favorites.");
        }

        const crew = await prisma.crew.findUnique({
            where: {
                id: crewId,
            },
        });

        if (!crew) {
            throw new Error("crew not found.");
        }

        const result = await prisma.userCrewFavorite.create({
            data: { userId, crewId },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to add crew to favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

// #region "Remove Favorite"
export async function removeFavoriteMovieToUser(userId: number, movieId: number, pathFrom: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userMovieFavorite.findFirst({
            where: {
                AND: [{ userId }, { movieId }],
            },
            include: {
                movie: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite movie not found.");
        }

        const result = await prisma.userMovieFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom === "/profile?tab=favMovies") {
                revalidatePath("/profile?tab=favMovies");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove movie from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeFavoriteSerieToUser(userId: number, serieId: number, pathFrom: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userSerieFavorite.findFirst({
            where: {
                AND: [{ userId }, { serieId }],
            },
            include: {
                serie: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite serie not found.");
        }

        const result = await prisma.userSerieFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom === "/profile?tab=favSeries") {
                revalidatePath("/profile?tab=favSeries");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove serie from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeFavoriteSeasonToUser(userId: number, seasonId: number, pathFrom: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userSeasonFavorite.findFirst({
            where: {
                AND: [{ userId }, { seasonId }],
            },
            include: {
                season: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite season not found.");
        }

        const result = await prisma.userSeasonFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom === "/profile?tab=favSeasons") {
                revalidatePath("/profile?tab=favSeasons");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove season from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeFavoriteEpisodeToUser(userId: number, episodeId: number, pathFrom: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userEpisodeFavorite.findFirst({
            where: {
                AND: [{ userId }, { episodeId }],
            },
            include: {
                episode: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite episode not found.");
        }

        const result = await prisma.userEpisodeFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom === "/profile?tab=favEpisodes") {
                revalidatePath("/profile?tab=favEpisodes");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove episode from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeFavoriteActorToUser(userId: number, actorId: number, pathFrom?: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userActorFavorite.findFirst({
            where: {
                AND: [{ userId }, { actorId }],
            },
            include: {
                actor: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite actor not found.");
        }

        const result = await prisma.userActorFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom && pathFrom === "/profile?tab=favActors") {
                revalidatePath("/profile?tab=favActors");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove actor from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeFavoriteCrewToUser(userId: number, crewId: number, pathFrom?: string): Promise<void> {
    try {
        const existingFavorite = await prisma.userCrewFavorite.findFirst({
            where: {
                AND: [{ userId }, { crewId }],
            },
            include: {
                crew: true,
            },
        });

        if (!existingFavorite) {
            throw new Error("Favorite crew not found.");
        }

        const result = await prisma.userCrewFavorite.delete({
            where: { id: existingFavorite.id },
        });

        if (result) {
            if (pathFrom && pathFrom === "/profile?tab=favCrew") {
                revalidatePath("/profile?tab=favCrew");
            } else {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            }
        } else {
            throw new Error("Failed to remove crew from favorites.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

// #endregion


================================================
File: src/actions/user/userDownvotes.actions.ts
================================================
"use server";

import { revalidatePath } from "next/cache";
import { prisma } from "../../../prisma/config/prisma";
import {
    VoteMovieReviewParams,
    getReferer,
    VoteSerieReviewParams,
    VoteSeasonReviewParams,
    VoteEpisodeReviewParams,
    VoteActorReviewParams,
    VoteCrewReviewParams,
} from "./user.actions";

// #region "Downvotes"

// #region "Add Downvote"
export async function addDownvoteMovieReview({ userId, movieId, movieReviewId }: VoteMovieReviewParams): Promise<any> {
    try {
        const existingDownvoteMovieReview = await prisma.downvoteMovieReview.findFirst({
            where: {
                AND: [{ userId }, { movieId }, { movieReviewId }],
            },
        });

        if (!existingDownvoteMovieReview) {
            const downvoteAdded = await prisma.downvoteMovieReview.create({
                data: {
                    userId,
                    movieId,
                    movieReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote movie");
            }
        } else {
            throw new Error("Failed to downvote movie");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addDownvoteSerieReview({ userId, serieId, serieReviewId }: VoteSerieReviewParams): Promise<any> {
    try {
        const existingDownvoteSerieReview = await prisma.downvoteSerieReview.findFirst({
            where: {
                AND: [{ userId }, { serieId }, { serieReviewId }],
            },
        });

        if (!existingDownvoteSerieReview) {
            const downvoteAdded = await prisma.downvoteSerieReview.create({
                data: {
                    userId,
                    serieId,
                    serieReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote serie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addDownvoteSeasonReview({
    userId,
    seasonId,
    seasonReviewId,
}: VoteSeasonReviewParams): Promise<any> {
    try {
        const existingDownvoteSeasonReview = await prisma.downvoteSeasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonId }, { seasonReviewId }],
            },
        });

        if (!existingDownvoteSeasonReview) {
            const downvoteAdded = await prisma.downvoteSeasonReview.create({
                data: {
                    userId,
                    seasonId,
                    seasonReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote season");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addDownvoteEpisodeReview({
    userId,
    episodeId,
    episodeReviewId,
}: VoteEpisodeReviewParams): Promise<any> {
    try {
        const existingDownvoteEpisodeReview = await prisma.downvoteEpisodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeId }, { episodeReviewId }],
            },
        });

        if (!existingDownvoteEpisodeReview) {
            const downvoteAdded = await prisma.downvoteEpisodeReview.create({
                data: {
                    userId,
                    episodeId,
                    episodeReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote episode");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addDownvoteActorReview({ userId, actorId, actorReviewId }: VoteActorReviewParams): Promise<any> {
    try {
        const existingDownvoteActorReview = await prisma.downvoteActorReview.findFirst({
            where: {
                AND: [{ userId }, { actorId }, { actorReviewId }],
            },
        });

        if (!existingDownvoteActorReview) {
            const downvoteAdded = await prisma.downvoteActorReview.create({
                data: {
                    userId,
                    actorId,
                    actorReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote actor");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addDownvoteCrewReview({ userId, crewId, crewReviewId }: VoteCrewReviewParams): Promise<any> {
    try {
        const existingDownvoteCrewReview = await prisma.downvoteCrewReview.findFirst({
            where: {
                AND: [{ userId }, { crewId }, { crewReviewId }],
            },
        });

        if (!existingDownvoteCrewReview) {
            const downvoteAdded = await prisma.downvoteCrewReview.create({
                data: {
                    userId,
                    crewId,
                    crewReviewId,
                },
            });

            if (downvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to downvote crew");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

// #region "Remove Downvote"
export async function removeDownvoteMovieReview({
    userId,
    movieId,
    movieReviewId,
}: VoteMovieReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteMovieReview.findFirst({
            where: {
                AND: [{ userId }, { movieReviewId }, { movieId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteMovieReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote movie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeDownvoteSerieReview({
    userId,
    serieId,
    serieReviewId,
}: VoteSerieReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteSerieReview.findFirst({
            where: {
                AND: [{ userId }, { serieReviewId }, { serieId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteSerieReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote serie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeDownvoteSeasonReview({
    userId,
    seasonId,
    seasonReviewId,
}: VoteSeasonReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteSeasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonReviewId }, { seasonId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteSeasonReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote season");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeDownvoteEpisodeReview({
    userId,
    episodeId,
    episodeReviewId,
}: VoteEpisodeReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteEpisodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeReviewId }, { episodeId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteEpisodeReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote episode");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeDownvoteActorReview({
    userId,
    actorId,
    actorReviewId,
}: VoteActorReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteActorReview.findFirst({
            where: {
                AND: [{ userId }, { actorReviewId }, { actorId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteActorReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote actor");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeDownvoteCrewReview({ userId, crewId, crewReviewId }: VoteCrewReviewParams): Promise<any> {
    try {
        const existingDownvote = await prisma.downvoteCrewReview.findFirst({
            where: {
                AND: [{ userId }, { crewReviewId }, { crewId }],
            },
        });

        if (existingDownvote) {
            const result = await prisma.downvoteCrewReview.delete({
                where: { id: existingDownvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove downvote crew");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

//#endregion


================================================
File: src/actions/user/userFollow.actions.ts
================================================
"use server";

import { prisma } from "../../../prisma/config/prisma";
import { revalidatePath } from "next/cache";
import { getReferer } from "./user.actions";

export async function follow(followerId: number, followingId: number): Promise<void> {
    try {
        if (followerId === followingId) {
            throw new Error("You cannot follow yourself.");
        }

        const existingFollow = await prisma.userFollow.findFirst({
            where: {
                AND: [{ followerId }, { followingId }],
            },
        });

        if (existingFollow) {
            throw new Error("You already follow this user.");
        }

        await prisma.$transaction([
            prisma.userFollow.create({
                data: {
                    followerId,
                    followingId,
                    state: "pending",
                },
            }),
            prisma.notification.create({
                data: {
                    type: "follow_request",
                    content: "sent you a follow request",
                    userId: followingId,
                    senderId: followerId,
                    status: "unread",
                },
            }),
        ]);

        const referer = getReferer();
        revalidatePath(`${referer}`, "page");
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function unfollow(followerId: number, followingId: number): Promise<void> {
    try {
        if (followerId === followingId) {
            throw new Error("You cannot unfollow yourself.");
        }

        const existingFollow = await prisma.userFollow.findFirst({
            where: {
                AND: [{ followerId }, { followingId }],
            },
        });

        if (!existingFollow) {
            throw new Error("You do not follow this user.");
        }

        const result = await prisma.userFollow.delete({
            where: {
                id: existingFollow.id,
            },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to unfollow user.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function acceptFollowRequest(followerId: number, followingId: number): Promise<void> {
    try {
        const followRequest = await prisma.userFollow.findFirst({
            where: {
                AND: [{ followerId }, { followingId }, { state: "pending" }],
            },
        });

        if (!followRequest) {
            throw new Error("No pending follow request found.");
        }

        const result = await prisma.userFollow.update({
            where: {
                id: followRequest.id,
            },
            data: {
                state: "accepted",
            },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to accept follow request.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function refuseFollowRequest(followerId: number, followingId: number): Promise<void> {
    try {
        const followRequest = await prisma.userFollow.findFirst({
            where: {
                AND: [{ followerId }, { followingId }, { state: "pending" }],
            },
        });

        if (!followRequest) {
            throw new Error("No pending follow request found.");
        }

        const result = await prisma.userFollow.delete({
            where: {
                id: followRequest.id,
            },
        });

        if (result) {
            const referer = getReferer();
            revalidatePath(`${referer}`, "page");
        } else {
            throw new Error("Failed to refuse follow request.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function getFollowers(
    userId: number,
    userLoggedInId?: number | null,
    page: number = 1,
    limit: number = 10,
) {
    const skip = (page - 1) * limit;

    const [followers, total] = await Promise.all([
        prisma.userFollow.findMany({
            where: {
                followingId: userId,
                state: "accepted",
            },
            include: {
                follower: {
                    include: {
                        avatar: true,
                    },
                },
            },
            take: limit,
            skip,
        }),
        prisma.userFollow.count({
            where: {
                followingId: userId,
                state: "accepted",
            },
        }),
    ]);

    const followersWithStatus = await Promise.all(
        followers.map(async (follow) => {
            let followStatus = null;

            if (userLoggedInId) {
                const existingFollow = await prisma.userFollow.findFirst({
                    where: {
                        followerId: userLoggedInId,
                        followingId: follow.follower.id,
                    },
                });

                followStatus = existingFollow
                    ? {
                          isFollowing: true,
                          state: existingFollow.state,
                      }
                    : {
                          isFollowing: false,
                          state: null,
                      };
            }

            return {
                ...follow,
                follower: {
                    ...follow.follower,
                    followStatus,
                },
            };
        }),
    );

    return {
        items: followersWithStatus || [],
        total: total || 0,
    };
}

export async function getFollowing(
    userId: number,
    userLoggedInId?: number | null,
    page: number = 1,
    limit: number = 10,
) {
    const skip = (page - 1) * limit;

    const [following, total] = await Promise.all([
        prisma.userFollow.findMany({
            where: {
                followerId: userId,
                state: "accepted",
            },
            include: {
                following: {
                    include: {
                        avatar: true,
                    },
                },
            },
            take: limit,
            skip,
        }),
        prisma.userFollow.count({
            where: {
                followerId: userId,
                state: "accepted",
            },
        }),
    ]);

    const followingWithStatus = await Promise.all(
        following.map(async (follow) => {
            let followStatus = null;

            if (userLoggedInId) {
                const existingFollow = await prisma.userFollow.findFirst({
                    where: {
                        followerId: userLoggedInId,
                        followingId: follow.following.id,
                    },
                });

                followStatus = existingFollow
                    ? {
                          isFollowing: true,
                          state: existingFollow.state,
                      }
                    : {
                          isFollowing: false,
                          state: null,
                      };
            }

            return {
                ...follow,
                following: {
                    ...follow.following,
                    followStatus,
                },
            };
        }),
    );

    return {
        items: followingWithStatus || [],
        total: total || 0,
    };
}

export async function getPendingFollowRequests(userId: number, page: number = 1, limit: number = 10) {
    const skip = (page - 1) * limit;

    const [pendingRequests, total] = await Promise.all([
        prisma.userFollow.findMany({
            where: {
                followingId: userId,
                state: "pending",
            },
            include: {
                follower: {
                    include: {
                        avatar: true,
                    },
                },
            },
            take: limit,
            skip,
        }),
        prisma.userFollow.count({
            where: {
                followingId: userId,
                state: "pending",
            },
        }),
    ]);

    return {
        items: pendingRequests || [],
        total: total || 0,
    };
}

export async function getUnreadNotificationsCount(userId: number): Promise<number> {
    return prisma.notification.count({
        where: {
            userId,
            status: "unread",
        },
    });
}

export async function getRecentNotifications(userId: number, limit: number = 5) {
    return prisma.notification.findMany({
        where: {
            userId,
        },
        include: {
            sender: {
                select: {
                    id: true,
                    userName: true,
                    avatar: true,
                },
            },
        },
        orderBy: {
            createdAt: "desc",
        },
        take: limit,
    });
}

export async function markNotificationsAsRead(userId: number): Promise<void> {
    await prisma.notification.updateMany({
        where: {
            userId,
            status: "unread",
        },
        data: {
            status: "read",
        },
    });

    revalidatePath("/notifications");
}

export const getAllNotifications = async (userId: number, page: number = 1) => {
    const perPage = 10;
    const skip = (page - 1) * perPage;

    const [notifications, total] = await Promise.all([
        prisma.notification.findMany({
            where: {
                userId: userId, // Changed from receiverId to userId
            },
            include: {
                sender: {
                    include: {
                        avatar: true,
                    },
                },
            },
            orderBy: {
                createdAt: "desc",
            },
            skip,
            take: perPage,
        }),
        prisma.notification.count({
            where: {
                userId: userId, // Changed from receiverId to userId
            },
        }),
    ]);

    const notificationsWithReadStatus = notifications.map((notification) => ({
        ...notification,
        isRead: notification.status === "read",
    }));

    return {
        items: notificationsWithReadStatus,
        total,
    };
};

export async function getPaginatedNotifications(userId: number, page: number = 1, limit: number = 5) {
    const skip = (page - 1) * limit;

    return prisma.notification.findMany({
        where: {
            userId,
        },
        include: {
            sender: {
                select: {
                    id: true,
                    userName: true,
                    avatar: true,
                },
            },
        },
        orderBy: {
            createdAt: "desc",
        },
        skip,
        take: limit,
    });
}


================================================
File: src/actions/user/userMessages.actions.ts
================================================
"use server";

import { prisma } from "../../../prisma/config/prisma";

export const getUserInbox = async (page: number = 1, userLoggedInId: number) => {
    const perPage = 10;
    const skip = (page - 1) * perPage;

    const [messages, total] = await Promise.all([
        prisma.message.findMany({
            where: {
                receiverId: userLoggedInId,
            },
            include: {
                sender: {
                    include: {
                        avatar: true,
                    },
                },
                receiver: {
                    include: {
                        avatar: true,
                    },
                },
            },
            orderBy: {
                createdAt: "desc",
            },
            skip,
            take: perPage,
        }),
        prisma.message.count({
            where: {
                receiverId: userLoggedInId,
            },
        }),
    ]);

    return {
        items: messages,
        total,
    };
};

export const getSentMessages = async (page: number = 1, userLoggedInId: number) => {
    const perPage = 10;
    const skip = (page - 1) * perPage;

    const [messages, total] = await Promise.all([
        prisma.message.findMany({
            where: {
                senderId: userLoggedInId,
            },
            include: {
                receiver: {
                    include: {
                        avatar: true,
                    },
                },
                sender: {
                    include: {
                        avatar: true,
                    },
                },
            },
            orderBy: {
                createdAt: "desc",
            },
            skip,
            take: perPage,
        }),
        prisma.message.count({
            where: {
                senderId: userLoggedInId,
            },
        }),
    ]);

    return {
        items: messages,
        total,
    };
};

export const sendMessage = async (receiverId: number, text: string, userLoggedInId: number) => {
    const inbox = await prisma.inbox.create({
        data: {
            participants: {
                create: [{ userId: userLoggedInId }, { userId: receiverId }],
            },
        },
    });

    const message = await prisma.message.create({
        data: {
            text,
            senderId: userLoggedInId,
            receiverId,
            inboxId: inbox.id,
        },
    });

    return message;
};

export const deleteMessage = async (messageId: number) => {
    try {
        await prisma.message.delete({
            where: {
                id: messageId,
            },
        });
    } catch (error) {
        console.error("Error deleting message:", error);
        throw error;
    }
};

export const searchUsers = async (query: string, currentUserId: number) => {
    if (!query) return [];

    const users = await prisma.user.findMany({
        where: {
            AND: [
                {
                    OR: [
                        { userName: { contains: query, mode: "insensitive" } },
                        { email: { contains: query, mode: "insensitive" } },
                    ],
                },
                { NOT: { id: currentUserId } },
            ],
        },
        select: {
            id: true,
            userName: true,
            email: true,
            avatar: true,
        },
        take: 5,
    });

    return users;
};

export const getUserById = async (userId: number) => {
    const user = await prisma.user.findUnique({
        where: {
            id: userId,
        },
        select: {
            id: true,
            userName: true,
            email: true,
            avatar: true,
        },
    });

    return user;
};

export const markMessageAsRead = async (messageId: number) => {
    await prisma.message.update({
        where: {
            id: messageId,
        },
        data: {
            read: true,
        },
    });
};

export const getTotalUnreadMessages = async (userId: number) => {
    const count = await prisma.message.count({
        where: {
            receiverId: userId,
            read: false,
        },
    });

    return count;
};

export const editMessage = async (messageId: number, text: string) => {
    try {
        await prisma.message.update({
            where: {
                id: messageId,
            },
            data: {
                text,
                editedAt: new Date(),
            },
        });
    } catch (error) {
        console.error("Error editing message:", error);
        throw error;
    }
};

export const getMessageById = async (messageId: number) => {
    const message = await prisma.message.findUnique({
        where: {
            id: messageId,
        },
        include: {
            sender: {
                include: {
                    avatar: true,
                },
            },
            receiver: {
                include: {
                    avatar: true,
                },
            },
        },
    });

    return message;
};

export const getUnreadMessagesCount = async (userId: number) => {
    const count = await prisma.message.count({
        where: {
            receiverId: userId,
            read: false,
        },
    });

    return count;
};


================================================
File: src/actions/user/userProfile.actions.ts
================================================
"use server";

import { prisma } from "../../../prisma/config/prisma";

export async function getUserFavorites(
    userId: number,
    type: "movies" | "series" | "actors" | "crew" | "seasons" | "episodes",
    page: number = 1,
    search: string = "",
) {
    const perPage = 10;
    const skip = (page - 1) * perPage;

    try {
        let items: any[] = [];
        let total = 0;

        switch (type.toLowerCase()) {
            case "movies":
                [items, total] = await Promise.all([
                    prisma.userMovieFavorite.findMany({
                        where: {
                            userId,
                            movie: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            movie: true,
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userMovieFavorite.count({
                        where: {
                            userId,
                            movie: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            case "series":
                [items, total] = await Promise.all([
                    prisma.userSerieFavorite.findMany({
                        where: {
                            userId,
                            serie: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            serie: true,
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userSerieFavorite.count({
                        where: {
                            userId,
                            serie: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            case "actors":
                [items, total] = await Promise.all([
                    prisma.userActorFavorite.findMany({
                        where: {
                            userId,
                            actor: {
                                fullname: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            actor: true,
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userActorFavorite.count({
                        where: {
                            userId,
                            actor: {
                                fullname: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            case "crew":
                [items, total] = await Promise.all([
                    prisma.userCrewFavorite.findMany({
                        where: {
                            userId,
                            crew: {
                                fullname: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            crew: true,
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userCrewFavorite.count({
                        where: {
                            userId,
                            crew: {
                                fullname: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            case "seasons":
                [items, total] = await Promise.all([
                    prisma.userSeasonFavorite.findMany({
                        where: {
                            userId,
                            season: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            season: {
                                include: {
                                    serie: true,
                                },
                            },
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userSeasonFavorite.count({
                        where: {
                            userId,
                            season: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            case "episodes":
                [items, total] = await Promise.all([
                    prisma.userEpisodeFavorite.findMany({
                        where: {
                            userId,
                            episode: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                        include: {
                            episode: {
                                include: {
                                    season: {
                                        include: {
                                            serie: true,
                                        },
                                    },
                                },
                            },
                        },
                        skip,
                        take: perPage,
                        orderBy: {
                            id: "desc",
                        },
                    }),
                    prisma.userEpisodeFavorite.count({
                        where: {
                            userId,
                            episode: {
                                title: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    }),
                ]);
                break;

            default:
                throw new Error("Invalid type specified");
        }

        return {
            items,
            total,
        };
    } catch (error) {
        console.error("Error fetching user favorites:", error);
        throw error;
    }
}

export async function getUserReviews(
    userId: number,
    subTab: "movies" | "series" | "seasons" | "episodes" | "actors" | "crew",
    page: number = 1,
    search: string = "",
    limit: number = 10,
) {
    const skip = (page - 1) * limit;
    const singularSubTab = subTab === "crew" ? "crew" : subTab.slice(0, -1);

    const titleField = singularSubTab === "actor" || singularSubTab === "crew" ? "fullname" : "title";

    const [reviews, total] = await Promise.all([
        prisma.user.findUnique({
            where: { id: userId },
            select: {
                [`${singularSubTab}Reviews`]: {
                    where: {
                        [singularSubTab]: {
                            [titleField]: {
                                contains: search,
                                mode: "insensitive",
                            },
                        },
                    },
                    include: {
                        [singularSubTab]: true,
                        _count: {
                            select: {
                                upvotes: true,
                                downvotes: true,
                            },
                        },
                    },
                    take: limit,
                    skip,
                },
            },
        }),
        prisma.user.findUnique({
            where: { id: userId },
            select: {
                [`_count`]: {
                    select: {
                        [`${singularSubTab}Reviews`]: true,
                    },
                },
            },
        }),
    ]);

    return {
        items: reviews?.[`${singularSubTab}Reviews`] || [],
        total: total?._count?.[`${singularSubTab}Reviews`] || 0,
    };
}

export async function getUserVotes(
    userId: number,
    subTab: "movies" | "series" | "seasons" | "episodes" | "actors" | "crew",
    mainTab: "upvotes" | "downvotes",
    search: string = "",
    page: number = 1,
    limit: number = 10,
) {
    const skip = (page - 1) * limit;
    const singularSubTab = subTab === "crew" ? "crew" : subTab.slice(0, -1);
    const type = mainTab === "upvotes" ? "upvoted" : mainTab === "downvotes" ? "downvoted" : mainTab;
    const titleField = singularSubTab === "actor" || singularSubTab === "crew" ? "fullname" : "title";

    const [votes, total] = await Promise.all([
        prisma.user.findUnique({
            where: { id: userId },
            select: {
                [`${singularSubTab}Reviews${type.charAt(0).toUpperCase() + type.slice(1)}`]: {
                    where: {
                        [`${singularSubTab}Review`]: {
                            [singularSubTab]: {
                                [titleField]: {
                                    contains: search,
                                    mode: "insensitive",
                                },
                            },
                        },
                    },
                    include: {
                        [`${singularSubTab}Review`]: {
                            include: {
                                user: { include: { avatar: true } },
                                [singularSubTab]: true,
                                _count: {
                                    select: {
                                        upvotes: true,
                                        downvotes: true,
                                    },
                                },
                            },
                        },
                        [singularSubTab]: true,
                    },
                    take: limit,
                    skip,
                },
            },
        }),
        prisma.user.findUnique({
            where: { id: userId },
            select: {
                [`_count`]: {
                    select: {
                        [`${singularSubTab}Reviews${type.charAt(0).toUpperCase() + type.slice(1)}`]: {
                            where: {
                                [`${singularSubTab}Review`]: {
                                    [singularSubTab]: {
                                        [titleField]: {
                                            contains: search,
                                            mode: "insensitive",
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        }),
    ]);

    return {
        items: votes?.[`${singularSubTab}Reviews${type.charAt(0).toUpperCase() + type.slice(1)}`] || [],
        total: total?._count?.[`${singularSubTab}Reviews${type.charAt(0).toUpperCase() + type.slice(1)}`] || 0,
    };
}


================================================
File: src/actions/user/userReviews.actions.ts
================================================
"use server";

import { Prisma } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { prisma } from "../../../prisma/config/prisma";
import {
    AddReviewMovieParams,
    getReferer,
    AddReviewSerieParams,
    UpdateReviewMovieParams,
    UpdateReviewSerieParams,
    RemoveReviewMovieParams,
    RemoveReviewSerieParams,
    RemoveReviewSeasonParams,
    RemoveReviewEpisodeParams,
    RemoveReviewActorParams,
    RemoveReviewCrewParams,
} from "./user.actions";

// #region "Reviews"

// #region "Add Review"
export const addReviewMovie = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    movieId,
}: AddReviewMovieParams): Promise<void> => {
    try {
        const existingReview = await prisma.movieReview.findFirst({
            where: {
                userId,
                movieId,
            },
        });

        if (!existingReview) {
            const movie = await prisma.movie.findUnique({
                where: {
                    id: movieId,
                },
            });

            if (!movie) {
                throw new Error("Movie not found.");
            }

            // console.log(content, createdAt, rating, userId, movieId);

            const reviewAdded = await prisma.movieReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    movieId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this movie.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const addReviewSerie = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    serieId,
}: AddReviewSerieParams): Promise<void> => {
    try {
        const existingReview = await prisma.serieReview.findFirst({
            where: {
                userId,
                serieId,
            },
        });

        if (!existingReview) {
            const serie = await prisma.serie.findUnique({
                where: {
                    id: serieId,
                },
            });

            if (!serie) {
                throw new Error("Serie not found.");
            }

            const reviewAdded = await prisma.serieReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    serieId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this serie.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const addReviewSeason = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    seasonId,
}: Prisma.SeasonReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.seasonReview.findFirst({
            where: {
                userId,
                seasonId,
            },
        });

        if (!existingReview) {
            const season = await prisma.season.findUnique({
                where: {
                    id: seasonId,
                },
            });

            if (!season) {
                throw new Error("Season not found.");
            }

            const reviewAdded = await prisma.seasonReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    seasonId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this season.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const addReviewEpisode = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    episodeId,
}: Prisma.EpisodeReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.episodeReview.findFirst({
            where: {
                userId,
                episodeId,
            },
        });

        if (!existingReview) {
            const episode = await prisma.episode.findUnique({
                where: {
                    id: episodeId,
                },
            });

            if (!episode) {
                throw new Error("Episode not found.");
            }

            const reviewAdded = await prisma.episodeReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    episodeId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this episode.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const addReviewActor = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    actorId,
}: Prisma.ActorReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.actorReview.findFirst({
            where: {
                userId,
                actorId,
            },
        });

        if (!existingReview) {
            const actor = await prisma.actor.findUnique({
                where: {
                    id: actorId,
                },
            });

            if (!actor) {
                throw new Error("Actor not found.");
            }

            const reviewAdded = await prisma.actorReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    actorId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this actor.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const addReviewCrew = async ({
    content,
    createdAt = new Date(),
    rating,
    userId,
    crewId,
}: Prisma.CrewReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.crewReview.findFirst({
            where: {
                userId,
                crewId,
            },
        });

        if (!existingReview) {
            const crew = await prisma.crew.findUnique({
                where: {
                    id: crewId,
                },
            });

            if (!crew) {
                throw new Error("Crew not found.");
            }

            const reviewAdded = await prisma.crewReview.create({
                data: {
                    content,
                    createdAt,
                    rating,
                    userId,
                    crewId,
                },
            });

            if (reviewAdded) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to add review.");
            }
        } else {
            throw new Error("You have already reviewed this crew.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};
// #endregion

// #region "Update Review"
export const updateReviewMovie = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    movieId,
}: UpdateReviewMovieParams): Promise<void> => {
    try {
        const existingReview = await prisma.movieReview.findFirst({
            where: {
                AND: [{ userId }, { movieId }],
            },
            include: {
                movie: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.movieReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    movieId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const updateReviewSerie = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    serieId,
}: UpdateReviewSerieParams): Promise<void> => {
    try {
        const existingReview = await prisma.serieReview.findFirst({
            where: {
                AND: [{ userId }, { serieId }],
            },
            include: {
                serie: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.serieReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    serieId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const updateReviewSeason = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    seasonId,
}: Prisma.SeasonReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.seasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonId }],
            },
            include: {
                season: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.seasonReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    seasonId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Season not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const updateReviewEpisode = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    episodeId,
}: Prisma.EpisodeReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.episodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeId }],
            },
            include: {
                episode: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.episodeReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    episodeId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Episode not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const updateReviewActor = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    actorId,
}: Prisma.ActorReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.actorReview.findFirst({
            where: {
                AND: [{ userId }, { actorId }],
            },
            include: {
                actor: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.actorReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    actorId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Actor not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const updateReviewCrew = async ({
    content,
    updatedAt = new Date(),
    rating,
    userId,
    crewId,
}: Prisma.CrewReviewCreateManyInput): Promise<void> => {
    try {
        const existingReview = await prisma.crewReview.findFirst({
            where: {
                AND: [{ userId }, { crewId }],
            },
            include: {
                crew: true,
            },
        });

        if (existingReview) {
            const reviewUpdated = await prisma.crewReview.update({
                data: {
                    content,
                    updatedAt,
                    rating,
                    userId,
                    crewId,
                },
                where: {
                    id: existingReview.id,
                },
            });

            if (reviewUpdated) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to update review.");
            }
        } else {
            throw new Error("Crew not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};
// #endregion

// #region "Remove Review"
export const removeReviewMovie = async ({ userId, movieId }: RemoveReviewMovieParams): Promise<void> => {
    try {
        const existingReview = await prisma.movieReview.findFirst({
            where: {
                AND: [{ userId }, { movieId }],
            },
            include: {
                movie: true,
            },
        });

        if (existingReview) {
            const result = await prisma.movieReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const removeReviewSerie = async ({ userId, serieId }: RemoveReviewSerieParams): Promise<void> => {
    try {
        const existingReview = await prisma.serieReview.findFirst({
            where: {
                AND: [{ userId }, { serieId }],
            },
            include: {
                serie: true,
            },
        });

        if (existingReview) {
            const result = await prisma.serieReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const removeReviewSeason = async ({ userId, seasonId }: RemoveReviewSeasonParams): Promise<void> => {
    try {
        const existingReview = await prisma.seasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonId }],
            },
            include: {
                season: true,
            },
        });

        if (existingReview) {
            const result = await prisma.seasonReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const removeReviewEpisode = async ({ userId, episodeId }: RemoveReviewEpisodeParams): Promise<void> => {
    try {
        const existingReview = await prisma.episodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeId }],
            },
            include: {
                episode: true,
            },
        });

        if (existingReview) {
            const result = await prisma.episodeReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const removeReviewActor = async ({ userId, actorId }: RemoveReviewActorParams): Promise<void> => {
    try {
        const existingReview = await prisma.actorReview.findFirst({
            where: {
                AND: [{ userId }, { actorId }],
            },
            include: {
                actor: true,
            },
        });

        if (existingReview) {
            const result = await prisma.actorReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Review not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};

export const removeReviewCrew = async ({ userId, crewId }: RemoveReviewCrewParams): Promise<void> => {
    try {
        const existingReview = await prisma.crewReview.findFirst({
            where: {
                AND: [{ userId }, { crewId }],
            },
            include: {
                crew: true,
            },
        });

        if (existingReview) {
            const result = await prisma.crewReview.delete({
                where: { id: existingReview.id },
            });

            if (result) {
                const referer = getReferer();
                revalidatePath(`${referer}`, "page");
            } else {
                throw new Error("Failed to delete review.");
            }
        } else {
            throw new Error("Crew not found.");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
};
// #endregion

// #endregion


================================================
File: src/actions/user/userUpvotes.actions.ts
================================================
"use server";

import { revalidatePath } from "next/cache";
import { prisma } from "../../../prisma/config/prisma";
import {
    VoteMovieReviewParams,
    getReferer,
    VoteSerieReviewParams,
    VoteSeasonReviewParams,
    VoteEpisodeReviewParams,
    VoteActorReviewParams,
    VoteCrewReviewParams,
} from "./user.actions";

// #region "Upvotes"

// #region "Add Upvote"
export async function addUpvoteMovieReview({ userId, movieId, movieReviewId }: VoteMovieReviewParams): Promise<any> {
    try {
        const existingUpvoteMovieReview = await prisma.upvoteMovieReview.findFirst({
            where: {
                AND: [{ userId }, { movieId }, { movieReviewId }],
            },
        });

        if (!existingUpvoteMovieReview) {
            const upvoteAdded = await prisma.upvoteMovieReview.create({
                data: {
                    userId,
                    movieId,
                    movieReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote movie");
            }
        } else {
            throw new Error("Failed to upvote movie");
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addUpvoteSerieReview({ userId, serieId, serieReviewId }: VoteSerieReviewParams): Promise<any> {
    try {
        const existingUpvoteSerieReview = await prisma.upvoteSerieReview.findFirst({
            where: {
                AND: [{ userId }, { serieId }, { serieReviewId }],
            },
        });

        if (!existingUpvoteSerieReview) {
            const upvoteAdded = await prisma.upvoteSerieReview.create({
                data: {
                    userId,
                    serieId,
                    serieReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote serie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addUpvoteSeasonReview({
    userId,
    seasonId,
    seasonReviewId,
}: VoteSeasonReviewParams): Promise<any> {
    try {
        const existingUpvoteSeasonReview = await prisma.upvoteSeasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonId }, { seasonReviewId }],
            },
        });

        if (!existingUpvoteSeasonReview) {
            const upvoteAdded = await prisma.upvoteSeasonReview.create({
                data: {
                    userId,
                    seasonId,
                    seasonReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote season");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addUpvoteEpisodeReview({
    userId,
    episodeId,
    episodeReviewId,
}: VoteEpisodeReviewParams): Promise<any> {
    try {
        const existingUpvoteEpisodeReview = await prisma.upvoteEpisodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeId }, { episodeReviewId }],
            },
        });

        if (!existingUpvoteEpisodeReview) {
            const upvoteAdded = await prisma.upvoteEpisodeReview.create({
                data: {
                    userId,
                    episodeId,
                    episodeReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote episode");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addUpvoteActorReview({ userId, actorId, actorReviewId }: VoteActorReviewParams): Promise<any> {
    try {
        const existingUpvoteActorReview = await prisma.upvoteActorReview.findFirst({
            where: {
                AND: [{ userId }, { actorId }, { actorReviewId }],
            },
        });

        if (!existingUpvoteActorReview) {
            const upvoteAdded = await prisma.upvoteActorReview.create({
                data: {
                    userId,
                    actorId,
                    actorReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote actor");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function addUpvoteCrewReview({ userId, crewId, crewReviewId }: VoteCrewReviewParams): Promise<any> {
    try {
        const existingUpvoteCrewReview = await prisma.upvoteCrewReview.findFirst({
            where: {
                AND: [{ userId }, { crewId }, { crewReviewId }],
            },
        });

        if (!existingUpvoteCrewReview) {
            const upvoteAdded = await prisma.upvoteCrewReview.create({
                data: {
                    userId,
                    crewId,
                    crewReviewId,
                },
            });

            if (upvoteAdded) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to upvote crew");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

// #region "Remove Upvote"
export async function removeUpvoteMovieReview({ userId, movieId, movieReviewId }: VoteMovieReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteMovieReview.findFirst({
            where: {
                AND: [{ userId }, { movieReviewId }, { movieId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteMovieReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote movie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeUpvoteSerieReview({ userId, serieId, serieReviewId }: VoteSerieReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteSerieReview.findFirst({
            where: {
                AND: [{ userId }, { serieReviewId }, { serieId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteSerieReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote serie");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeUpvoteSeasonReview({
    userId,
    seasonId,
    seasonReviewId,
}: VoteSeasonReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteSeasonReview.findFirst({
            where: {
                AND: [{ userId }, { seasonReviewId }, { seasonId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteSeasonReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote season");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeUpvoteEpisodeReview({
    userId,
    episodeId,
    episodeReviewId,
}: VoteEpisodeReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteEpisodeReview.findFirst({
            where: {
                AND: [{ userId }, { episodeReviewId }, { episodeId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteEpisodeReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote episode");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeUpvoteActorReview({ userId, actorId, actorReviewId }: VoteActorReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteActorReview.findFirst({
            where: {
                AND: [{ userId }, { actorReviewId }, { actorId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteActorReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote actor");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}

export async function removeUpvoteCrewReview({ userId, crewId, crewReviewId }: VoteCrewReviewParams): Promise<any> {
    try {
        const existingUpvote = await prisma.upvoteCrewReview.findFirst({
            where: {
                AND: [{ userId }, { crewReviewId }, { crewId }],
            },
        });

        if (existingUpvote) {
            const result = await prisma.upvoteCrewReview.delete({
                where: { id: existingUpvote.id },
            });

            if (result) {
                const referer = await getReferer();
                revalidatePath(referer);
            } else {
                throw new Error("Failed to remove upvote crew");
            }
        }
    } catch (error) {
        throw new Error(error instanceof Error ? error.message : "An unexpected error occurred.");
    }
}
// #endregion

// #endregion


================================================
File: src/app/global-error.tsx
================================================
"use client";

import { Box, Button, Typography } from "@mui/material";

export default function GlobalError({ error, reset }: { error: Error; reset: () => void }) {
    return (
        <Box>
            <Typography component="h3" variant="h3">
                Something went wrong!
            </Typography>
            <Box>{error.message}</Box>
            <Button onClick={() => reset()}>Try again</Button>
        </Box>
    );
}


================================================
File: src/app/globals.css
================================================
* {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
}

[data-mui-color-scheme="light"] {
    color-scheme: light;
}

[data-mui-color-scheme="dark"] {
    color-scheme: dark;
}


================================================
File: src/app/robots.ts
================================================
import { MetadataRoute } from "next";

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export default function robots(): MetadataRoute.Robots {
    return {
        rules: [
            {
                userAgent: "*",
                allow: "/",
                disallow: ["/admin/"],
            },
        ],
        sitemap: `${baseUrl}/sitemap.xml`,
        host: baseUrl,
    };
}


================================================
File: src/app/sitemap.ts
================================================
import { getActors } from "@/actions/actor.actions";
import { getEpisodes } from "@/actions/episode.actions";
import { getGenres } from "@/actions/genre.actions";
import { getMovies } from "@/actions/movie.actions";
import { getSeasons } from "@/actions/season.actions";
import { getSeries } from "@/actions/serie.actions";
import { getUsers } from "@/actions/user/user.actions";
import { Actor, Episode, Genre, Movie, Season, Serie, User } from "@prisma/client";
import { MetadataRoute } from "next";

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export const dynamic = "force-dynamic";

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
    const urls: any[] = [];

    const movies = await getMovies();
    const series = await getSeries();
    const genres = await getGenres();
    const seasons = await getSeasons();
    const episodes = await getEpisodes();
    const actors = await getActors();
    const users = await getUsers();

    urls.push({
        url: `${baseUrl}`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/movies`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/series`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/seasons`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/genres`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/episodes`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 1,
    });

    urls.push({
        url: `${baseUrl}/login`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 0.5,
    });

    urls.push({
        url: `${baseUrl}/register`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 0.5,
    });

    urls.push({
        url: `${baseUrl}/search`,
        lastModified: new Date(),
        changeFrequency: "monthly",
        priority: 0.5,
    });

    movies.forEach((movie: Movie) => {
        urls.push({
            url: `${baseUrl}/movies/${movie.id}/${movie.title}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    series.forEach((serie: Serie) => {
        urls.push({
            url: `${baseUrl}/series/${serie.id}/${serie.title}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    genres?.forEach((genre: Genre) => {
        urls.push({
            url: `${baseUrl}/genres/${genre.id}/${genre.name}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    seasons.forEach((season: Season) => {
        urls.push({
            url: `${baseUrl}/seasons/${season.id}/${season.title}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    episodes.forEach((episode: Episode) => {
        urls.push({
            url: `${baseUrl}/episodes/${episode.id}/${episode.title}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    actors.forEach((actor: Actor) => {
        urls.push({
            url: `${baseUrl}/actors/${actor.id}/${actor.fullname}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    users.forEach((user: User) => {
        urls.push({
            url: `${baseUrl}/users/${user.id}/${user.userName}`,
            lastModified: new Date(),
            changeFrequency: "monthly",
            priority: 0.8,
        });
    });

    return urls;
}


================================================
File: src/app/(admin)/error.tsx
================================================
"use client";

import { Box, Button, Container, Typography } from "@mui/material";

export default function Error({ error, reset }: { error: Error & { digest?: string }; reset: () => void }) {
    return (
        <Container maxWidth="sm">
            <Box
                sx={{
                    my: 20,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    borderRadius: 2,
                    border: 1,
                    borderColor: "neutral.200",
                    bgcolor: "background.paper",
                    p: 4,
                    boxShadow: 3,
                    transition: "background-color 0.5s ease",
                }}
            >
                <Typography variant="h3" gutterBottom>
                    Something went wrong.
                </Typography>
                <Typography variant="h5" gutterBottom>
                    Please try again now or later.
                </Typography>
                <Button onClick={reset} className="text-accent-blue">
                    Try again
                </Button>
            </Box>
        </Container>
    );
}


================================================
File: src/app/(admin)/layout.tsx
================================================
import { AuthProvider } from "@/providers/AuthProvider";
import { ModalProvider } from "@/providers/ModalProvider";
import { RightPanelProvider } from "@/providers/RightPanelProvider";
import ToastProvider from "@/providers/ToastProvider";
import { MUIThemeProvider } from "@/providers/ThemeProvider";
import InitColorSchemeScript from "@mui/material/InitColorSchemeScript";
import AdminLayout from "@/layouts/AdminLayout";
import { Montserrat } from "next/font/google";
import "../globals.css";

const montserrat = Montserrat({
    weight: ["300", "400", "500", "700"],
    subsets: ["latin"],
    display: "swap",
    fallback: ["Arial", "sans-serif"],
});

export const metadata = {
    robots: {
        follow: false,
        index: false,
    },
    title: {
        default: "Admin Panel",
    },
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html suppressHydrationWarning lang="en">
            <body className={montserrat.className}>
                <AuthProvider>
                    <MUIThemeProvider>
                        <ToastProvider>
                            <ModalProvider>
                                <RightPanelProvider>
                                    <InitColorSchemeScript attribute="class" />
                                    <AdminLayout>{children}</AdminLayout>
                                </RightPanelProvider>
                            </ModalProvider>
                        </ToastProvider>
                    </MUIThemeProvider>
                </AuthProvider>
            </body>
        </html>
    );
}


================================================
File: src/app/(admin)/loading.tsx
================================================
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

const Loading = () => {
    return <LoadingSpinner />;
};

export default Loading;


================================================
File: src/app/(admin)/admin/page.tsx
================================================
import DashboardAdmin from "./dashboard/page";

export default function BaseAdmin() {
    return <DashboardAdmin />;
}


================================================
File: src/app/(admin)/admin/actors/page.tsx
================================================
import ActorsAdminPage from "./_components/ActorsAdminPage";

export default function ActorsAdmin() {
    return <ActorsAdminPage />;
}


================================================
File: src/app/(admin)/admin/actors/[id]/page.tsx
================================================
import ActorAdminPage from "./_components/ActorAdminPage";

export default function ActorAdmin() {
    return <ActorAdminPage />;
}


================================================
File: src/app/(admin)/admin/actors/[id]/_components/ActorAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Actor, Prisma } from "@prisma/client";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { useParams, useRouter } from "next/navigation";
import { deleteActorById, getActorById, updateActorById } from "@/actions/actor.actions";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { actorSchema } from "@/schemas/actor.schema";

const ActorAdminPage = () => {
    const [actor, setActor] = useState<Actor | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/actors" style={{ textDecoration: "none" }}>
            Actors
        </Link>,
        <Link key="2" href={`/admin/actors/${params?.id}`} style={{ textDecoration: "none" }}>
            {actor?.fullname || `Actor ${params?.id}`}
        </Link>,
    ];

    // const handleDataChange = (values: any) => {
    //     setFormData(values);
    // };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.ActorUpdateInput = {
            fullname: values.fullname,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            description: values.description,
            debut: values.debut,
        };

        const response: Actor | null = await updateActorById(payload, String(actor?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getActor();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getActor(): Promise<void> {
        setLoading(true);
        const response: Actor | null = await getActorById(Number(params.id), {});

        if (response) {
            setActor(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getActor();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/actors"} />
            <HeaderDashboard title={"Actor"} subtitle={"Edit actor"} />
            <FormAdvanced
                defaultValues={{
                    id: actor?.id,
                    fullname: actor?.fullname,
                    photoSrc: actor?.photoSrc,
                    photoSrcProd: actor?.photoSrcProd,
                    description: actor?.description,
                    debut: actor?.debut,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "fullname",
                        label: "Full Name",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "debut",
                        label: "Debut",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                schema={actorSchema}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected actor ${formData.name}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteActorById(actor?.id!);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/actors");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default ActorAdminPage;


================================================
File: src/app/(admin)/admin/actors/_components/ActorsAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const ActorsAdminPage = () => {
    const router = useRouter();

    function handleAddActor() {
        router.push("/admin/actors/create");
    }

    const { table } = TableAdmin({
        page: "actors",
        handleAddItem: handleAddActor,
    });

    return (
        <Box m="20px">
            <HeaderDashboard title="Actors" subtitle="List of actors" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default ActorsAdminPage;


================================================
File: src/app/(admin)/admin/actors/create/page.tsx
================================================
import CreateActorForm from "./_components/AddActorAdminPage";

export default function CreateActor() {
    return <CreateActorForm />;
}


================================================
File: src/app/(admin)/admin/actors/create/_components/AddActorAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { Actor, Prisma } from "@prisma/client";
import { addActor } from "@/actions/actor.actions";
import { actorSchema } from "@/schemas/actor.schema";

const AddActorAdminPage = () => {
    const formRef = useRef<any>(null);
    const router = useRouter();

    const breadcrumbs = [
        <Link key="1" href="/admin/actors" style={{ textDecoration: "none" }}>
            Actors
        </Link>,
        <Link key="2" href="/admin/actors/create" style={{ textDecoration: "none" }}>
            New Actor
        </Link>,
    ];

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.ActorCreateInput = {
            fullname: values.fullname,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            description: values.description,
            debut: values.debut,
        };

        try {
            const response: Actor | null = await addActor(payload);

            if (response) {
                toast.success(CONSTANTS.ADD__SUCCESS);
                router.push("/admin/actors");
            } else {
                toast.error(CONSTANTS.ADD__FAILURE);
            }
        } catch (error) {
            console.error("Error creating actor:", error);
            toast.error(CONSTANTS.ADD__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo="/admin/actors" />
            <HeaderDashboard title="Actor" subtitle="Add an actor" />
            <FormAdvanced
                schema={actorSchema}
                defaultValues={{
                    fullname: "",
                    photoSrc: "",
                    photoSrcProd: "",
                    description: "",
                    debut: "",
                }}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                fields={[
                    {
                        name: "fullname",
                        label: "Fullname",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "description",
                        label: "Description",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "debut",
                        label: "Debut",
                        type: "text",
                        variant: "filled",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
            />
        </Box>
    );
};

export default AddActorAdminPage;


================================================
File: src/app/(admin)/admin/crews/page.tsx
================================================
import CrewAdminPage from "./_components/CrewsAdminPage";

export default async function CrewAdmin() {
    return <CrewAdminPage />;
}


================================================
File: src/app/(admin)/admin/crews/[id]/page.tsx
================================================
import CrewAdminPage from "./_components/CrewAdminPage";

export default async function CrewAdmin() {
    return <CrewAdminPage />;
}


================================================
File: src/app/(admin)/admin/crews/[id]/_components/CrewAdminPage.tsx
================================================
"use client";

import { Box, Link } from "@mui/material";
import { useRouter, useParams } from "next/navigation";
import { useRef, useState, useEffect } from "react";
import { toast } from "react-toastify";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { getCrewMemberById, updateCrewMemberById, deleteCrewMemberById } from "@/actions/crew.actions";
import { Crew } from "@prisma/client";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useModal } from "@/providers/ModalProvider";
import * as CONSTANTS from "@/constants/Constants";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { crewSchema } from "@/schemas/crew.schema";

const CrewAdminPage = () => {
    const [crew, setCrew] = useState<Crew | null>(null);
    // const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();

    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/crews" style={{ textDecoration: "none" }}>
            Crews
        </Link>,
        <Link key="2" href={`/admin/crews/${params?.id}`} style={{ textDecoration: "none" }}>
            {crew?.fullname || `Crew ${params?.id}`}
        </Link>,
    ];

    const handleFormSubmit = async (data: any) => {
        const response = await updateCrewMemberById(data, String(crew?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            router.push("/admin/crews");
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    async function getCrew(): Promise<void> {
        setLoading(true);
        const response: Crew | null = await getCrewMemberById(Number(params.id), {});

        if (response) {
            setCrew(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getCrew();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/crews"} />
            <HeaderDashboard title={"Crew"} subtitle={"Edit crew member"} />
            <FormAdvanced
                defaultValues={{
                    id: crew?.id,
                    fullname: crew?.fullname,
                    photoSrc: crew?.photoSrc,
                    photoSrcProd: crew?.photoSrcProd,
                    role: crew?.role,
                    description: crew?.description,
                    debut: crew?.debut,
                }}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                fields={[
                    {
                        name: "fullname",
                        label: "Full Name",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "role",
                        label: "Role",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "debut",
                        label: "Debut",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                schema={crewSchema}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected crew member ${crew?.fullname}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteCrewMemberById(crew?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/crews");
                                            } else {
                                                toast.error(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default CrewAdminPage;


================================================
File: src/app/(admin)/admin/crews/_components/CrewsAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const CrewsAdminPage = () => {
    const router = useRouter();

    function handleAddCrew() {
        router.push("/admin/crews/create");
    }

    const { table } = TableAdmin({
        page: "crews",
        handleAddItem: handleAddCrew,
    });

    return (
        <>
            <Box m="20px" component={"main"}>
                <HeaderDashboard title="Crews" subtitle="List of crews" />
                <MaterialReactTable table={table} />
            </Box>
        </>
    );
};

export default CrewsAdminPage;


================================================
File: src/app/(admin)/admin/crews/create/page.tsx
================================================
import AddCrewAdminPage from "./_components/AddCrewAdminPage";

export default async function CreateCrew() {
    return <AddCrewAdminPage />;
}


================================================
File: src/app/(admin)/admin/crews/create/_components/AddCrewAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useRouter } from "next/navigation";
import { useRef } from "react";
import { toast } from "react-toastify";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { addCrewMember } from "@/actions/crew.actions";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import FormAdvanced from "@/components/admin/form/Form";
import * as CONSTANTS from "@/constants/Constants";
import Link from "next/link";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { crewSchema } from "@/schemas/crew.schema";

const AddCrewAdminPage = () => {
    const router = useRouter();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/crews" style={{ textDecoration: "none" }}>
            Crews
        </Link>,
        <Link key="2" href={`/admin/crews/create`} style={{ textDecoration: "none" }}>
            New Crew
        </Link>,
    ];

    const handleFormSubmit = async (data: any) => {
        const response = await addCrewMember(data);

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            router.push("/admin/crew");
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo="/admin/actors" />
            <HeaderDashboard title="Crew" subtitle="Add a crew member" />
            <FormAdvanced
                schema={crewSchema}
                defaultValues={{
                    fullname: "",
                    photoSrc: "",
                    photoSrcProd: "",
                    role: "",
                    description: "",
                    debut: "",
                }}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                fields={[
                    {
                        name: "fullname",
                        label: "Full Name",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "role",
                        label: "Role",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "description",
                        label: "Description",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "debut",
                        label: "Debut",
                        type: "text",
                        variant: "filled",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
            />
        </Box>
    );
};

export default AddCrewAdminPage;


================================================
File: src/app/(admin)/admin/dashboard/page.tsx
================================================
import DashboardAdminPage from "./_components/DashboardAdminPage";
import { getDashboardStats } from "./_actions/getDashboardStats";

export default async function DashboardAdmin() {
    const stats = await getDashboardStats();

    return <DashboardAdminPage stats={stats} />;
}


================================================
File: src/app/(admin)/admin/dashboard/_actions/getDashboardStats.ts
================================================
"use server";

import { prisma } from "../../../../../../prisma/config/prisma";

export type DashboardStats = {
    totalMovies: number;
    totalSeries: number;
    totalGenres: number;
    totalActors: number;
    totalEpisodes: number;
    totalSeasons: number;
    totalUsers: number;
};

export async function getDashboardStats(): Promise<DashboardStats> {
    const [totalMovies, totalSeries, totalGenres, totalActors, totalEpisodes, totalSeasons, totalUsers] =
        await Promise.all([
            prisma.movie.count(),
            prisma.serie.count(),
            prisma.genre.count(),
            prisma.actor.count(),
            prisma.episode.count(),
            prisma.season.count(),
            prisma.user.count(),
        ]);

    return {
        totalMovies,
        totalSeries,
        totalGenres,
        totalActors,
        totalEpisodes,
        totalSeasons,
        totalUsers,
    };
}


================================================
File: src/app/(admin)/admin/dashboard/_components/DashboardAdminPage.tsx
================================================
"use client";

import { Box, useTheme } from "@mui/material";
import PersonAddIcon from "@mui/icons-material/PersonAdd";
import MovieIcon from "@mui/icons-material/Movie";
import LiveTvIcon from "@mui/icons-material/LiveTv";
import CategoryIcon from "@mui/icons-material/Category";
import PersonIcon from "@mui/icons-material/Person";
import PlaylistPlayIcon from "@mui/icons-material/PlaylistPlay";
import VideoLibraryIcon from "@mui/icons-material/VideoLibrary";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { DashboardStatBox } from "./DashboardStatBox";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import type { DashboardStats } from "../_actions/getDashboardStats";

interface DashboardAdminPageProps {
    stats: DashboardStats;
}

const DashboardAdminPage = ({ stats }: DashboardAdminPageProps) => {
    const theme = useTheme();

    const StatBoxWrapper = ({ children }: { children: React.ReactNode }) => (
        <Box
            sx={{
                backgroundColor: theme.vars.palette.background.paper,
                borderRadius: 2,
                p: 3,
                boxShadow: theme.vars.palette.stats.boxShadow,
                transition: "all 0.3s ease-in-out",
                "&:hover": {
                    transform: "translateY(-4px)",
                    boxShadow: theme.vars.palette.stats.hoverShadow,
                    "& .stat-icon": {
                        transform: "scale(1.1)",
                    },
                },
                minHeight: "200px",
                width: "100%",
                display: "flex",
                flexDirection: "column",
                justifyContent: "space-between",
            }}
        >
            {children}
        </Box>
    );

    return (
        <Box
            sx={{
                p: { xs: 2, sm: 3 },
                width: "100%",
                maxWidth: "100%",
                overflow: "hidden",
            }}
        >
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                <HeaderDashboard title="Dashboard" subtitle="Welcome to your MovieLandia24 Admin Dashboard" />
            </Box>

            <Box
                sx={{
                    display: "grid",
                    gridTemplateColumns: {
                        xs: "1fr",
                        sm: "repeat(2, 1fr)",
                        md: "repeat(3, 1fr)",
                        lg: "repeat(4, 1fr)",
                    },
                    gap: { xs: 2, sm: 2.5, md: 3 },
                    width: "100%",
                }}
            >
                {/* Movies */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalMovies.toString()}
                        subtitle="Movies"
                        progress={0.75}
                        increase="Total"
                        icon={
                            <MovieIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* TV Series */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalSeries.toString()}
                        subtitle="TV Series"
                        progress={0.65}
                        increase="Total"
                        icon={
                            <LiveTvIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* Users */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalUsers.toString()}
                        subtitle="Users"
                        progress={0.5}
                        increase="Total"
                        icon={
                            <PersonAddIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* Genres */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalGenres.toString()}
                        subtitle="Genres"
                        progress={0.8}
                        increase="Total"
                        icon={
                            <CategoryIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* Actors */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalActors.toString()}
                        subtitle="Actors"
                        progress={0.7}
                        increase="Total"
                        icon={
                            <PersonIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* Episodes */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalEpisodes.toString()}
                        subtitle="Episodes"
                        progress={0.6}
                        increase="Total"
                        icon={
                            <PlaylistPlayIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>

                {/* Seasons */}
                <StatBoxWrapper>
                    <DashboardStatBox
                        title={stats.totalSeasons.toString()}
                        subtitle="Seasons"
                        progress={0.55}
                        increase="Total"
                        icon={
                            <VideoLibraryIcon
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontSize: 32,
                                }}
                            />
                        }
                    />
                </StatBoxWrapper>
            </Box>
        </Box>
    );
};

export default DashboardAdminPage;


================================================
File: src/app/(admin)/admin/dashboard/_components/DashboardProgressCircle.tsx
================================================
import { Box, useTheme } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IDashboardProgressCircleProps {
    progress: number;
    size?: string;
}

export const DashboardProgressCircle = ({ progress = 0.75, size = "40" }: IDashboardProgressCircleProps) => {
    const theme = useTheme();

    const angle = progress * 360;

    return (
        <Box
            sx={{
                background: `radial-gradient(${theme.vars.palette.background.default} 55%, transparent 56%),
            conic-gradient(transparent 0deg ${angle}deg, ${theme.vars.palette.blue.main} ${angle}deg 360deg),
            ${theme.vars.palette.green.light}`,
                borderRadius: "50%",
                width: `${size}px`,
                height: `${size}px`,
            }}
        />
    );
};


================================================
File: src/app/(admin)/admin/dashboard/_components/DashboardStatBox.tsx
================================================
import { Box, Typography, useTheme } from "@mui/material";
import { DashboardProgressCircle } from "./DashboardProgressCircle";
import type {} from "@mui/material/themeCssVarsAugmentation";
import React, { JSX } from "react";

interface IDashboardProgressCircleProps {
    title: string;
    subtitle: string;
    progress: number;
    increase: string;
    icon: JSX.Element;
}

export const DashboardStatBox = ({ title, subtitle, icon, progress, increase }: IDashboardProgressCircleProps) => {
    const theme = useTheme();

    return (
        <Box width="100%" height="100%" display="flex" flexDirection="column" justifyContent="space-between">
            <Box display="flex" justifyContent="space-between" alignItems="flex-start">
                <Box>
                    <Box
                        className="stat-icon"
                        sx={{
                            backgroundColor: theme.vars.palette.stats.iconBg,
                            p: 1,
                            borderRadius: 2,
                            display: "inline-flex",
                            transition: "transform 0.3s ease-in-out",
                        }}
                    >
                        {icon}
                    </Box>
                    <Typography
                        variant="h4"
                        fontWeight="bold"
                        sx={{
                            color: theme.vars.palette.text.primary,
                            mt: 2,
                            mb: 1,
                            fontSize: "2rem",
                        }}
                    >
                        {title}
                    </Typography>
                </Box>
                <Box>
                    <DashboardProgressCircle progress={progress} />
                </Box>
            </Box>
            <Box
                display="flex"
                justifyContent="space-between"
                alignItems="center"
                mt={2}
                sx={{
                    borderTop: `1px solid ${theme.vars.palette.stats.borderColor}`,
                    pt: 2,
                }}
            >
                <Typography
                    variant="h6"
                    sx={{
                        color: theme.vars.palette.text.secondary,
                        fontWeight: 500,
                    }}
                >
                    {subtitle}
                </Typography>
                <Typography
                    variant="body2"
                    sx={{
                        color: theme.vars.palette.primary.main,
                        backgroundColor: theme.vars.palette.stats.iconBg,
                        px: 2,
                        py: 0.75,
                        borderRadius: 2,
                        fontWeight: 600,
                        fontSize: "0.875rem",
                    }}
                >
                    {increase}
                </Typography>
            </Box>
        </Box>
    );
};


================================================
File: src/app/(admin)/admin/episodes/page.tsx
================================================
import EpisodesAdminPage from "./_components/EpisodesAdminPage";

export default async function EpisodesAdmin() {
    return <EpisodesAdminPage />;
}


================================================
File: src/app/(admin)/admin/episodes/[id]/page.tsx
================================================
import EpisodeAdminPage from "./_components/EpisodeAdminPage";

export default async function EpisodeAdmin() {
    return <EpisodeAdminPage />;
}


================================================
File: src/app/(admin)/admin/episodes/[id]/_components/EpisodeAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Episode, Prisma } from "@prisma/client";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { useParams, useRouter } from "next/navigation";
import { deleteEpisodeById, getEpisodeById, updateEpisodeById } from "@/actions/episode.actions";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { episodeSchema } from "@/schemas/episode.schema";

const EpisodeAdminPage = () => {
    const [episode, setEpisode] = useState<Episode | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/episodes" style={{ textDecoration: "none" }}>
            Episodes
        </Link>,
        <Link key="2" href={`/admin/episodes/${params?.id}`} style={{ textDecoration: "none" }}>
            {episode?.title || `Episode ${params?.id}`}
        </Link>,
    ];

    // const handleDataChange = (values: any) => {
    //     setFormData(values);
    // };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.EpisodeUpdateInput = {
            title: values.title,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            trailerSrc: values.trailerSrc,
            description: values.description,
            duration: Number(values.duration),
            dateAired: values.dateAired,
            ratingImdb: Number(values.ratingImdb),
            season: {
                connect: {
                    id: values.seasonId,
                },
            },
        };

        const response: Episode | null = await updateEpisodeById(payload, String(episode?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getEpisode();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getEpisode(): Promise<void> {
        setLoading(true);
        const response: Episode | null = await getEpisodeById(Number(params.id), {});

        if (response) {
            setEpisode(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getEpisode();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/episodes"} />
            <HeaderDashboard title={"Episode"} subtitle={"Edit Episode"} />
            <FormAdvanced
                defaultValues={{
                    id: episode?.id,
                    title: episode?.title,
                    photoSrc: episode?.photoSrc,
                    photoSrcProd: episode?.photoSrcProd,
                    trailerSrc: episode?.trailerSrc,
                    description: episode?.description,
                    duration: episode?.duration,
                    dateAired: episode?.dateAired,
                    ratingImdb: episode?.ratingImdb,
                    seasonId: episode?.seasonId,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "duration",
                        label: "Duration (minutes)",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date Aired",
                        variant: "filled",
                        type: "date",
                    },
                    {
                        name: "ratingImdb",
                        label: "IMDB Rating",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "seasonId",
                        label: "Season ID",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                schema={episodeSchema}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected episode ${formData.title}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteEpisodeById(episode?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/episodes");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default EpisodeAdminPage;


================================================
File: src/app/(admin)/admin/episodes/_components/EpisodesAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const EpisodesAdminPage = () => {
    const router = useRouter();

    function handleAddEpisode() {
        router.push("/admin/episodes/create");
    }

    const { table } = TableAdmin({
        page: "episodes",
        handleAddItem: handleAddEpisode,
    });

    return (
        <Box m="20px">
            <HeaderDashboard title="Episodes" subtitle="List of episodes" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default EpisodesAdminPage;


================================================
File: src/app/(admin)/admin/episodes/create/page.tsx
================================================
import CreateEpisodeForm from "./_components/AddEpisodeAdminPage";

export default async function CreateEpisode() {
    return <CreateEpisodeForm />;
}


================================================
File: src/app/(admin)/admin/episodes/create/_components/AddEpisodeAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { Episode } from "@prisma/client";
import { addEpisode } from "@/actions/episode.actions";
import { episodeSchema } from "@/schemas/episode.schema";

interface IAddEpisode {
    title: string;
    photoSrc: string;
    photoSrcProd: string;
    trailerSrc: string;
    description: string;
    duration: string | number;
    dateAired: string;
    ratingImdb: string | number;
    seasonId: string | number;
}

const AddEpisodeAdminPage = () => {
    const formRef = useRef<any>(null);
    const router = useRouter();

    const breadcrumbs = [
        <Link key="1" href="/admin/episodes" style={{ textDecoration: "none" }}>
            Episodes
        </Link>,
        <Link key="2" href="/admin/episodes/create" style={{ textDecoration: "none" }}>
            New Episode
        </Link>,
    ];

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    const handleFormSubmit = async (values: IAddEpisode) => {
        const payload = {
            title: values.title,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            trailerSrc: values.trailerSrc,
            description: values.description,
            duration: Number(values.duration),
            dateAired: values.dateAired,
            ratingImdb: Number(values.ratingImdb),
            seasonId: Number(values.seasonId),
        };

        const response: Episode | null = await addEpisode(payload);

        if (response) {
            toast.success(CONSTANTS.ADD__SUCCESS);
            router.push("/admin/episodes");
        } else {
            toast.error(CONSTANTS.ADD__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo="/admin/episodes" />
            <HeaderDashboard title="Episode" subtitle="Add a new episode" />
            <FormAdvanced
                schema={episodeSchema}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                defaultValues={{
                    title: "",
                    photoSrc: "",
                    photoSrcProd: "",
                    trailerSrc: "",
                    description: "",
                    duration: "",
                    dateAired: "",
                    ratingImdb: "",
                    seasonId: "",
                }}
                fields={[
                    {
                        name: "title",
                        label: "Title",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "description",
                        label: "Description",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "duration",
                        label: "Duration (minutes)",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "dateAired",
                        label: "Date Aired",
                        type: "date",
                        variant: "filled",
                    },
                    {
                        name: "ratingImdb",
                        label: "Rating IMDB",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "seasonId",
                        label: "Season ID",
                        type: "text",
                        variant: "filled",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
            />
        </Box>
    );
};

export default AddEpisodeAdminPage;


================================================
File: src/app/(admin)/admin/genres/page.tsx
================================================
import GenresAdminPage from "./_components/GenresAdminPage";

export default async function GenresAdmin() {
    return <GenresAdminPage />;
}


================================================
File: src/app/(admin)/admin/genres/[id]/page.tsx
================================================
import GenreAdminPage from "./_components/GenreAdminPage";

export default async function GenreAdmin() {
    return <GenreAdminPage />;
}


================================================
File: src/app/(admin)/admin/genres/[id]/_components/GenreAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import FormAdvanced from "@/components/admin/form/Form";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { useParams, useRouter } from "next/navigation";
import { deleteGenreById, getGenreByIdAdmin, updateGenreById } from "@/actions/genre.actions";
import { Genre, Prisma } from "@prisma/client";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { genreSchema } from "@/schemas/genre.schema";

interface IGenreEdit {
    id?: string;
    name: string;
}

const GenreAdminPage = () => {
    const [genre, setGenre] = useState<Genre | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const formRef = useRef<any>(null);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();

    const breadcrumbs = [
        <Link key="1" href="/admin/genres" style={{ textDecoration: "none" }}>
            Genres
        </Link>,
        <Link key="2" href={`/admin/genres/${params?.id}`} style={{ textDecoration: "none" }}>
            {genre?.name || `Genre ${params?.id}`}
        </Link>,
    ];

    const handleDataChange = (values: any) => {
        setFormData(values);
    };

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    const handleFormSubmit = async (values: IGenreEdit) => {
        const payload: Prisma.GenreUpdateInput = {
            name: values.name,
        };

        const response: Genre | null = await updateGenreById(payload, String(genre?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getGenre();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getGenre(): Promise<void> {
        setLoading(true);

        const response: Genre | null = await getGenreByIdAdmin(Number(params?.id));

        if (response) {
            setGenre(response);
            setLoading(false);
        } else {
            toast.error("Failed to fetch genre");
        }
    }

    useEffect(() => {
        getGenre();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/genres"} />
            <HeaderDashboard title={CONSTANTS.USER__EDIT__TITLE} subtitle={CONSTANTS.USER__EDIT__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    id: genre?.id,
                    name: genre?.name,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Genre id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "name",
                        label: "Name",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                onDataChange={(values: any) => {
                    handleDataChange(values);
                }}
                onSubmit={handleFormSubmit}
                schema={genreSchema}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected genre ${formData.name}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteGenreById(genre?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/genres");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default GenreAdminPage;


================================================
File: src/app/(admin)/admin/genres/_components/GenresAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";

const GenresAdminPage = () => {
    const router = useRouter();

    function handleAddGenre() {
        router.push("/admin/genres/create");
    }

    const { table } = TableAdmin({
        page: "genres",
        handleAddItem: handleAddGenre,
    });

    return (
        <Box m="20px">
            <HeaderDashboard title="Genres" subtitle="List of Genres" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default GenresAdminPage;


================================================
File: src/app/(admin)/admin/genres/create/page.tsx
================================================
import AddGenreAdminPage from "./_components/AddGenreAdminPage";

export default async function AddGenreAdmin() {
    return <AddGenreAdminPage />;
}


================================================
File: src/app/(admin)/admin/genres/create/_components/AddGenreAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import Header from "@/components/admin/headerDashboard/HeaderDashboard";
import { toast } from "react-toastify";
import FormAdvanced from "@/components/admin/form/Form";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import * as CONSTANTS from "@/constants/Constants";
import { useRouter } from "next/navigation";
import { addGenre } from "@/actions/genre.actions";
import { Genre } from "@prisma/client";
import Link from "next/link";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { genreSchema } from "@/schemas/genre.schema";

interface IGenreAdd {
    name: string;
}

const AddGenreAdminPage = () => {
    const router = useRouter();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/genres" style={{ textDecoration: "none" }}>
            Genres
        </Link>,
        <Link key="2" href={`/admin/genres/create`} style={{ textDecoration: "none" }}>
            New Genre
        </Link>,
    ];

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: IGenreAdd) => {
        const payload: IGenreAdd = {
            name: values.name,
        };

        const response: Genre | null = await addGenre(payload);

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            router.push(`/admin/genres/${response.id}`);
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/genres"} />
            <Header title={CONSTANTS.GENRE__ADD__TITLE} subtitle={CONSTANTS.GENRE__ADD__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    name: "",
                }}
                fields={[
                    {
                        name: "name",
                        label: "Name",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
                onSubmit={handleFormSubmit}
                schema={genreSchema}
                formRef={formRef}
            />
        </Box>
    );
};

export default AddGenreAdminPage;


================================================
File: src/app/(admin)/admin/movies/page.tsx
================================================
import MoviesAdminPage from "./_components/MoviesAdminPage";

export default async function MoviesAdmin() {
    return <MoviesAdminPage />;
}


================================================
File: src/app/(admin)/admin/movies/[id]/page.tsx
================================================
import MovieAdminPage from "./_components/MovieAdminPage";

export default async function MovieAdmin() {
    return <MovieAdminPage />;
}


================================================
File: src/app/(admin)/admin/movies/[id]/_components/MovieAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Movie, Prisma } from "@prisma/client";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { useParams, useRouter } from "next/navigation";
import { deleteMovieById, getMovieById, updateMovieById } from "@/actions/movie.actions";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { movieSchema } from "@/schemas/movie.schema";

const MovieAdminPage = () => {
    const [movie, setMovie] = useState<Movie | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [open, setOpen] = useState(false);
    const [loading, setLoading] = useState(true);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/movies" style={{ textDecoration: "none" }}>
            Movies
        </Link>,
        <Link key="2" href={`/admin/movies/${params?.id}`} style={{ textDecoration: "none" }}>
            {movie?.title || `Movie ${params?.id}`}
        </Link>,
    ];

    const handleDataChange = (values: any) => {
        setFormData(values);
    };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.MovieUpdateInput = {
            title: values.title,
            description: values.description,
            duration: Number(values.duration),
            photoSrc: values.photoSrc,
            trailerSrc: values.trailerSrc,
            ratingImdb: Number(values.ratingImdb),
            dateAired: values.dateAired,
        };

        const response: Movie | null = await updateMovieById(payload, String(movie?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getMovie();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getMovie(): Promise<void> {
        setLoading(true);

        const response: Movie | null = await getMovieById(Number(params.id), {});

        if (response) {
            setMovie(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getMovie();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/movies"} />
            <HeaderDashboard title={CONSTANTS.MOVIE__EDIT__TITLE} subtitle={CONSTANTS.MOVIE__EDIT__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    id: movie?.id,
                    title: movie?.title,
                    trailerSrc: movie?.trailerSrc,
                    photoSrc: movie?.photoSrc,
                    description: movie?.description,
                    dateAired: movie?.dateAired,
                    ratingImdb: movie?.ratingImdb,
                    duration: movie?.duration,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo src prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date aired",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "ratingImdb",
                        label: "Rating imdb",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "duration",
                        label: "Duration",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                onDataChange={(values: any) => {
                    handleDataChange(values);
                }}
                onSubmit={handleFormSubmit}
                schema={movieSchema}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected movie ${formData.title}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteMovieById(movie?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/movies");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default MovieAdminPage;


================================================
File: src/app/(admin)/admin/movies/_components/MoviesAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const MoviesAdminPage = () => {
    const router = useRouter();

    function handleAddMovie() {
        router.push("/admin/movies/create");
    }

    const { table } = TableAdmin({
        page: "movies",
        handleAddItem: handleAddMovie,
    });

    return (
        <>
            <Box m="20px" component={"main"}>
                <HeaderDashboard title="Movies" subtitle="List of Movies" />
                <MaterialReactTable table={table} />
            </Box>
        </>
    );
};

export default MoviesAdminPage;


================================================
File: src/app/(admin)/admin/movies/create/page.tsx
================================================
import AddMovieAdminPage from "./_components/AddMovieAdminPage";

export default async function AddMovieAdmin() {
    return <AddMovieAdminPage />;
}


================================================
File: src/app/(admin)/admin/movies/create/_components/AddMovieAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { toast } from "react-toastify";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import * as CONSTANTS from "@/constants/Constants";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import { addMovie } from "@/actions/movie.actions";
import { useRouter } from "next/navigation";
import Link from "next/link";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { movieSchema } from "@/schemas/movie.schema";

const AddMovieAdminPage = () => {
    const router = useRouter();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/movies" style={{ textDecoration: "none" }}>
            Movies
        </Link>,
        <Link key="2" href={`/admin/movies/create`} style={{ textDecoration: "none" }}>
            New Movie
        </Link>,
    ];

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload = {
            title: values.title,
            description: values.description,
            duration: values.duration,
            photoSrc: values.photoSrc,
            trailerSrc: values.trailerSrc,
            ratingImdb: Number(values.ratingImdb),
            dateAired: values.dateAired,
        };

        const response = await addMovie(payload);

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            router.push(`/admin/movies/${response.id}`);
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/movies"} />
            <HeaderDashboard title={CONSTANTS.MOVIE__ADD__TITLE} subtitle={CONSTANTS.MOVIE__ADD__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    title: "",
                    photoSrc: "",
                    trailerSrc: "",
                    duration: "",
                    ratingImdb: "",
                    dateAired: "",
                    description: "",
                }}
                fields={[
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo src prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "duration",
                        label: "Duration",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "ratingImdb",
                        label: "Rating imdb",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date aired",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
                onSubmit={handleFormSubmit}
                schema={movieSchema}
                formRef={formRef}
            />
        </Box>
    );
};

export default AddMovieAdminPage;


================================================
File: src/app/(admin)/admin/seasons/page.tsx
================================================
import SeasonsAdminPage from "./_components/SeasonsAdminPage";

export default async function SeasonsAdmin() {
    return <SeasonsAdminPage />;
}


================================================
File: src/app/(admin)/admin/seasons/[id]/page.tsx
================================================
import SeasonAdminPage from "./_components/SeasonAdminPage";

export default async function SeasonAdmin() {
    return <SeasonAdminPage />;
}


================================================
File: src/app/(admin)/admin/seasons/[id]/_components/SeasonAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Season, Prisma } from "@prisma/client";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { useParams, useRouter } from "next/navigation";
import { deleteSeasonById, getSeasonById, updateSeasonById } from "@/actions/season.actions";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { seasonSchema } from "@/schemas/season.schema";

const SeasonAdminPage = () => {
    const [season, setSeason] = useState<Season | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/seasons" style={{ textDecoration: "none" }}>
            Seasons
        </Link>,
        <Link key="2" href={`/admin/seasons/${params?.id}`} style={{ textDecoration: "none" }}>
            {season?.title || `Season ${params?.id}`}
        </Link>,
    ];

    // const handleDataChange = (values: any) => {
    //     setFormData(values);
    // };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.SeasonUpdateInput = {
            title: values.title,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            trailerSrc: values.trailerSrc,
            description: values.description,
            dateAired: values.dateAired,
            ratingImdb: Number(values.ratingImdb),
            serie: {
                connect: {
                    id: values.serieId,
                },
            },
        };

        const response: Season | null = await updateSeasonById(payload, String(season?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getSeason();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getSeason(): Promise<void> {
        setLoading(true);
        const response: Season | null = await getSeasonById(Number(params.id), {});

        if (response) {
            setSeason(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getSeason();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/seasons"} />
            <HeaderDashboard title={"Season"} subtitle={"Edit Season"} />
            <FormAdvanced
                defaultValues={{
                    id: season?.id,
                    title: season?.title,
                    photoSrc: season?.photoSrc,
                    photoSrcProd: season?.photoSrcProd,
                    trailerSrc: season?.trailerSrc,
                    description: season?.description,
                    dateAired: season?.dateAired,
                    ratingImdb: season?.ratingImdb,
                    serieId: season?.serieId,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer Src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "description",
                        label: "Description",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date Aired",
                        variant: "filled",
                        type: "date",
                    },
                    {
                        name: "ratingImdb",
                        label: "IMDB Rating",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "serieId",
                        label: "Serie ID",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                schema={seasonSchema}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected season ${formData.title}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteSeasonById(season?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/seasons");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default SeasonAdminPage;


================================================
File: src/app/(admin)/admin/seasons/_components/SeasonsAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const SeasonsAdminPage = () => {
    const router = useRouter();

    function handleAddSeason() {
        router.push("/admin/seasons/create");
    }

    const { table } = TableAdmin({
        page: "seasons",
        handleAddItem: handleAddSeason,
    });

    return (
        <Box m="20px">
            <HeaderDashboard title="Seasons" subtitle="List of seasons" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default SeasonsAdminPage;


================================================
File: src/app/(admin)/admin/seasons/create/page.tsx
================================================
import CreateSeasonPage from "./_components/AddSeasonAdminPage";

export default async function CreateSeason() {
    return <CreateSeasonPage />;
}


================================================
File: src/app/(admin)/admin/seasons/create/_components/AddSeasonAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { Season } from "@prisma/client";
import { addSeason } from "@/actions/season.actions";
import { seasonSchema } from "@/schemas/season.schema";

interface IAddSeason {
    title: string;
    photoSrc: string;
    photoSrcProd: string;
    trailerSrc: string;
    description: string;
    dateAired: string;
    ratingImdb: number;
    serieId: number;
}

const AddSeasonAdminPage = () => {
    const formRef = useRef<any>(null);
    const router = useRouter();

    const breadcrumbs = [
        <Link key="1" href="/admin/seasons" style={{ textDecoration: "none" }}>
            Seasons
        </Link>,
        <Link key="2" href="/admin/seasons/create" style={{ textDecoration: "none" }}>
            New Season
        </Link>,
    ];

    const handleResetFromParent = () => {
        if (formRef.current) {
            formRef.current.reset();
        }
    };

    const handleFormSubmit = async (values: any) => {
        const payload: IAddSeason = {
            title: values.title,
            photoSrc: values.photoSrc,
            photoSrcProd: values.photoSrcProd,
            trailerSrc: values.trailerSrc,
            description: values.description,
            dateAired: values.dateAired,
            ratingImdb: values.ratingImdb,
            serieId: values.serieId,
        };

        const response: Season | null = await addSeason(payload);

        if (response) {
            toast.success(CONSTANTS.ADD__SUCCESS);
            router.push("/admin/seasons");
        } else {
            toast.error(CONSTANTS.ADD__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo="/admin/seasons" />
            <HeaderDashboard title="Season" subtitle="Add a new season" />
            <FormAdvanced
                schema={seasonSchema}
                defaultValues={{
                    title: "",
                    photoSrc: "",
                    photoSrcProd: "",
                    trailerSrc: "",
                    description: "",
                    dateAired: "",
                    ratingImdb: "",
                    serieId: "",
                }}
                onSubmit={handleFormSubmit}
                formRef={formRef}
                fields={[
                    {
                        name: "title",
                        label: "Title",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo Src Prod",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "trailerSrc",
                        label: "Trailer Src",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "description",
                        label: "Description",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "dateAired",
                        label: "Date Aired",
                        type: "date",
                        variant: "filled",
                    },
                    {
                        name: "ratingImdb",
                        label: "Rating IMDB",
                        type: "text",
                        variant: "filled",
                    },
                    {
                        name: "serieId",
                        label: "Series ID",
                        type: "text",
                        variant: "filled",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
            />
        </Box>
    );
};

export default AddSeasonAdminPage;


================================================
File: src/app/(admin)/admin/series/page.tsx
================================================
import SeriesAdminPage from "./_components/SeriesAdminPage";

export default async function SeriesAdmin() {
    return <SeriesAdminPage />;
}


================================================
File: src/app/(admin)/admin/series/[id]/page.tsx
================================================
import SerieAdminPage from "./_components/SerieAdminPage";

export default async function SerieAdmin() {
    return <SerieAdminPage />;
}


================================================
File: src/app/(admin)/admin/series/[id]/_components/SerieAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Prisma, Serie } from "@prisma/client";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useModal } from "@/providers/ModalProvider";
import { updateSerieById, getSerieById, deleteSerieById } from "@/actions/serie.actions";
import { useParams, useRouter } from "next/navigation";
import Link from "next/link";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { serieSchema } from "@/schemas/serie.schema";

const SerieAdminPage = () => {
    const [serie, setSerie] = useState<Serie | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const params = useParams();

    const formRef = useRef<any>(null);
    const { openModal } = useModal();

    const breadcrumbs = [
        <Link key="1" href="/admin/series" style={{ textDecoration: "none" }}>
            Series
        </Link>,
        <Link key="2" href={`/admin/series/${params?.id}`} style={{ textDecoration: "none" }}>
            {serie?.title || `Serie ${params?.id}`}
        </Link>,
    ];

    const handleDataChange = (values: any) => {
        setFormData(values);
    };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.SerieUpdateInput = {
            title: values.title,
            photoSrc: values.photoSrc,
            ratingImdb: Number(values.ratingImdb),
            dateAired: values.dateAired,
        };

        const response: Serie | null = await updateSerieById(payload, String(serie?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getSerie();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getSerie(): Promise<void> {
        setLoading(true);

        const response: Serie | null = await getSerieById(Number(params.id), {});

        if (response) {
            setSerie(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getSerie();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/series"} />
            <HeaderDashboard title={CONSTANTS.USER__EDIT__TITLE} subtitle={CONSTANTS.USER__EDIT__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    id: serie?.id,
                    title: serie?.title,
                    photoSrc: serie?.photoSrc,
                    photoSrcProd: serie?.photoSrcProd,
                    dateAired: serie?.dateAired,
                    ratingImdb: serie?.ratingImdb,
                }}
                fields={[
                    {
                        name: "id",
                        label: "Serie id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo src prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date aired",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "ratingImdb",
                        label: "RatingImdb",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                onDataChange={(values: any) => {
                    handleDataChange(values);
                }}
                onSubmit={handleFormSubmit}
                schema={serieSchema}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected serie ${formData.title}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            const response = await deleteSerieById(serie?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/series");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default SerieAdminPage;


================================================
File: src/app/(admin)/admin/series/_components/SeriesAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const SeriesAdminPage = () => {
    const router = useRouter();

    function handleAddSerie() {
        router.push("/admin/series/create");
    }

    const { table } = TableAdmin({
        page: "series",
        handleAddItem: handleAddSerie,
    });

    return (
        <Box m="20px">
            <HeaderDashboard title="Series" subtitle="List of Series" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default SeriesAdminPage;


================================================
File: src/app/(admin)/admin/series/create/page.tsx
================================================
import AddSerieAdminPage from "./_components/AddSerieAdminPage";

export default async function AddSerieAdmin() {
    return <AddSerieAdminPage />;
}


================================================
File: src/app/(admin)/admin/series/create/_components/AddSerieAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { toast } from "react-toastify";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import * as CONSTANTS from "@/constants/Constants";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import FormAdvanced from "@/components/admin/form/Form";
import { addSerie } from "@/actions/serie.actions";
import { Serie } from "@prisma/client";
import Link from "next/link";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { serieSchema } from "@/schemas/serie.schema";

interface IAddSerie {
    title: string;
    photoSrc: string;
    dateAired: string;
    ratingImdb: string | number;
}

const AddSerieAdminPage = () => {
    const formRef = useRef<any>(null);
    const router = useRouter();

    const breadcrumbs = [
        <Link key="1" href="/admin/series" style={{ textDecoration: "none" }}>
            Series
        </Link>,
        <Link key="2" href={`/admin/series/create`} style={{ textDecoration: "none" }}>
            New Serie
        </Link>,
    ];

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: IAddSerie) => {
        const payload = {
            title: values.title,
            photoSrc: values.photoSrc,
            ratingImdb: Number(values.ratingImdb),
            dateAired: values.dateAired,
        };

        const response: Serie | null = await addSerie(payload);

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            router.push(`/admin/series/${response.id}`);
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/series"} />
            <HeaderDashboard title={CONSTANTS.SERIE__ADD__TITLE} subtitle={CONSTANTS.SERIE__ADD__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    title: "",
                    photoSrc: "",
                    photoSrcProd: "",
                    dateAired: "",
                    ratingImdb: "",
                }}
                fields={[
                    {
                        name: "title",
                        label: "Title",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrc",
                        label: "Photo src",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "photoSrcProd",
                        label: "Photo src prod",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "dateAired",
                        label: "Date aired",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "ratingImdb",
                        label: "Rating imdb",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
                onSubmit={handleFormSubmit}
                schema={serieSchema}
                formRef={formRef}
            />
        </Box>
    );
};

export default AddSerieAdminPage;


================================================
File: src/app/(admin)/admin/users/page.tsx
================================================
import UsersAdminPage from "./_components/UsersAdminPage";

export default async function UsersAdmin() {
    return <UsersAdminPage />;
}


================================================
File: src/app/(admin)/admin/users/[id]/page.tsx
================================================
import UserAdminPage from "./_components/UserAdminPage";

export default async function UserAdmin() {
    return <UserAdminPage />;
}


================================================
File: src/app/(admin)/admin/users/[id]/_components/UserAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { useState, useEffect, useRef } from "react";
import ClearOutlinedIcon from "@mui/icons-material/ClearOutlined";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import { toast } from "react-toastify";
import * as CONSTANTS from "@/constants/Constants";
import { CheckOutlined, WarningOutlined } from "@mui/icons-material";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import FormAdvanced from "@/components/admin/form/Form";
import { useModal } from "@/providers/ModalProvider";
import { deleteUserById, getUserById, updateUserByIdAdmin } from "@/actions/user/user.actions";
import { useParams, useRouter } from "next/navigation";
import Link from "next/link";
import { Prisma, User } from "@prisma/client";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { userSchema } from "@/schemas/user.schema";

const UserAdmin = () => {
    const [user, setUser] = useState<User | null>(null);
    const [formData, setFormData] = useState<any>({});
    const [loading, setLoading] = useState(true);
    const [open, setOpen] = useState(false);

    const formRef = useRef<any>(null);

    const router = useRouter();
    const params = useParams();
    const { openModal } = useModal();

    const breadcrumbs = [
        <Link key="1" href="/admin/users" style={{ textDecoration: "none" }}>
            Users
        </Link>,
        <Link key="2" href={`/admin/users/${params?.id}`} style={{ textDecoration: "none" }}>
            {user?.userName || `User ${params?.id}`}
        </Link>,
    ];

    const handleDataChange = (values: any) => {
        setFormData(values);
    };

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const payload: Prisma.UserUpdateInput = {
            userName: values.userName,
            email: values.email,
            password: values.password,
        };

        const response: User | null = await updateUserByIdAdmin(payload, Number(user?.id));

        if (response) {
            toast.success(CONSTANTS.UPDATE__SUCCESS);
            getUser();
        } else {
            toast.error(CONSTANTS.UPDATE__FAILURE);
        }
    };

    async function getUser(): Promise<void> {
        setLoading(true);

        const response: User | null = await getUserById(Number(params.id));

        if (response) {
            setUser(response);
            setLoading(false);
        }
    }

    useEffect(() => {
        getUser();
    }, []);

    if (loading) {
        return <LoadingSpinner />;
    }

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/users"} />
            <HeaderDashboard title={CONSTANTS.USER__EDIT__TITLE} subtitle={CONSTANTS.USER__EDIT__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    id: user?.id,
                    userName: user?.userName,
                    email: user?.email,
                }}
                fields={[
                    {
                        name: "id",
                        label: "User id",
                        disabled: true,
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "userName",
                        label: "Username",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "email",
                        label: "Email",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                onDataChange={(values: any) => {
                    handleDataChange(values);
                }}
                onSubmit={handleFormSubmit}
                schema={userSchema}
                formRef={formRef}
                actions={[
                    {
                        label: CONSTANTS.FORM__DELETE__BUTTON,
                        onClick: async () => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: `Delete selected user ${formData.userName}`,
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            setOpen(false);
                                            const response = await deleteUserById(user?.id);

                                            if (response) {
                                                toast.success(CONSTANTS.DELETE__SUCCESS);
                                                router.push("/admin/users");
                                            } else {
                                                toast.success(CONSTANTS.DELETE__FAILURE);
                                            }
                                        },
                                        type: "submit",
                                        color: "secondary",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Do you want to delete selected record ?",
                            });
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#ff5252",
                        },
                        icon: <ClearOutlinedIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#00bfff",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            bgcolor: "#30969f",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                ]}
            />
        </Box>
    );
};

export default UserAdmin;


================================================
File: src/app/(admin)/admin/users/_components/UsersAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MaterialReactTable } from "material-react-table";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import { useRouter } from "next/navigation";
import TableAdmin from "@/components/admin/tableAdmin/TableAdmin";

const UsersAdminPage = () => {
    const router = useRouter();

    function handleAddUser() {
        router.push("/admin/users/create");
    }

    const { table } = TableAdmin({
        page: "users",
        handleAddItem: handleAddUser,
    });

    return (
        <Box m="20px" component={"main"}>
            <HeaderDashboard title="Users" subtitle="List of Users" />
            <MaterialReactTable table={table} />
        </Box>
    );
};

export default UsersAdminPage;


================================================
File: src/app/(admin)/admin/users/create/page.tsx
================================================
import AddUserAdminPage from "./_components/AddUserAdminPage";

export default async function AddUserAdmin() {
    return <AddUserAdminPage />;
}


================================================
File: src/app/(admin)/admin/users/create/_components/AddUserAdminPage.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { toast } from "react-toastify";
import { useRef } from "react";
import SaveAsIcon from "@mui/icons-material/SaveAs";
import ClearAllIcon from "@mui/icons-material/ClearAll";
import * as CONSTANTS from "@/constants/Constants";
import { useRouter } from "next/navigation";
import HeaderDashboard from "@/components/admin/headerDashboard/HeaderDashboard";
import FormAdvanced from "@/components/admin/form/Form";
import { signUp } from "@/actions/auth.actions";
import { User } from "@prisma/client";
import Link from "next/link";
import Breadcrumb from "@/components/admin/breadcrumb/Breadcrumb";
import { addUserSchema } from "@/schemas/user.schema";

const AddUserAdminPage = () => {
    const router = useRouter();
    const formRef = useRef<any>(null);

    const breadcrumbs = [
        <Link key="1" href="/admin/users" style={{ textDecoration: "none" }}>
            Users
        </Link>,
        <Link key="2" href={`/admin/users/create`} style={{ textDecoration: "none" }}>
            New User
        </Link>,
    ];

    const handleResetFromParent = () => {
        formRef.current?.reset();
    };

    const handleFormSubmit = async (values: any) => {
        const response: User | null | undefined = await signUp({
            userName: values.userName,
            email: values.email,
            password: values.password,
        });

        if (response) {
            toast.success(CONSTANTS.ADD__SUCCESS);
            router.push(`/admin/users/${response.id}`);
        } else {
            toast.error(CONSTANTS.ADD__FAILURE);
        }
    };

    return (
        <Box m="20px">
            <Breadcrumb breadcrumbs={breadcrumbs} navigateTo={"/admin/genres"} />
            <HeaderDashboard title={CONSTANTS.USER__ADD__TITLE} subtitle={CONSTANTS.USER__ADD__SUBTITLE} />
            <FormAdvanced
                defaultValues={{
                    userName: "",
                    email: "",
                    password: "",
                }}
                fields={[
                    {
                        name: "userName",
                        label: "Username",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "email",
                        label: "Email",
                        variant: "filled",
                        type: "text",
                    },
                    {
                        name: "password",
                        label: "Password",
                        variant: "filled",
                        type: "text",
                    },
                ]}
                actions={[
                    {
                        label: CONSTANTS.FORM__UPDATE__BUTTON,
                        type: "submit",
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#30969f",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <SaveAsIcon sx={{ ml: "10px" }} color="action" />,
                    },
                    {
                        label: CONSTANTS.FORM__RESET__BUTTON,
                        type: "reset",
                        onClick: () => {
                            handleResetFromParent();
                        },
                        color: "secondary",
                        variant: "contained",
                        sx: {
                            border: "1px solid #000",
                            bgcolor: "#ff5252",
                            fontSize: "15px",
                            fontWeight: "700",
                        },
                        icon: <ClearAllIcon color="action" sx={{ ml: "10px" }} />,
                    },
                ]}
                onSubmit={handleFormSubmit}
                schema={addUserSchema}
                formRef={formRef}
            />
        </Box>
    );
};

export default AddUserAdminPage;


================================================
File: src/app/(root)/error.tsx
================================================
"use client";

import { Box, Button, Container, Typography } from "@mui/material";

interface IErrorProps {
    error: Error & { digest?: string };
    reset: () => void;
}

export default function Error({ error, reset }: IErrorProps) {
    return (
        <Container maxWidth="sm">
            <Box
                sx={{
                    my: 20,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    borderRadius: 2,
                    border: 1,
                    borderColor: "neutral.200",
                    bgcolor: "background.paper",
                    p: 4,
                    boxShadow: 3,
                    transition: "background-color 0.5s ease",
                }}
            >
                <Typography variant="h3" gutterBottom>
                    Something went wrong.
                    {error.message}
                </Typography>
                <Typography variant="h5" gutterBottom>
                    Please try again now or later
                </Typography>
                <Button onClick={reset} className="text-accent-blue">
                    Try again
                </Button>
            </Box>
        </Container>
    );
}


================================================
File: src/app/(root)/layout.tsx
================================================
import { ensureStartsWith } from "@/utils/helpers/utils";
import { AuthProvider } from "@/providers/AuthProvider";
import { ModalProvider } from "@/providers/ModalProvider";
import { RightPanelProvider } from "@/providers/RightPanelProvider";
import ToastProvider from "@/providers/ToastProvider";
import { MUIThemeProvider } from "@/providers/ThemeProvider";
import InitColorSchemeScript from "@mui/material/InitColorSchemeScript";
import MainLayout from "@/layouts/MainLayout";
import { Montserrat } from "next/font/google";
import "../globals.css";

const montserrat = Montserrat({
    weight: ["300", "400", "500", "700"],
    subsets: ["latin"],
    display: "swap",
    fallback: ["Arial", "sans-serif"],
});

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL!;
const { TWITTER_CREATOR, TWITTER_SITE, SITE_NAME } = process.env;
const twitterCreator = TWITTER_CREATOR ? ensureStartsWith(TWITTER_CREATOR, "@") : undefined;
const twitterSite = TWITTER_SITE ? ensureStartsWith(TWITTER_SITE, "https://") : undefined;

export const metadata = {
    metadataBase: new URL(baseUrl),
    title: {
        default: SITE_NAME!,
        template: `%s | ${SITE_NAME}`,
    },
    robots: {
        follow: true,
        index: true,
    },
    ...{
        twitter: {
            card: "summary_large_image",
            creator: twitterCreator,
            site: twitterSite,
        },
    },
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html suppressHydrationWarning lang="en">
            <body className={montserrat.className}>
                <AuthProvider>
                    <MUIThemeProvider>
                        <ToastProvider>
                            <ModalProvider>
                                <RightPanelProvider>
                                    <InitColorSchemeScript attribute="class" />
                                    <MainLayout>{children}</MainLayout>
                                </RightPanelProvider>
                            </ModalProvider>
                        </ToastProvider>
                    </MUIThemeProvider>
                </AuthProvider>
            </body>
        </html>
    );
}


================================================
File: src/app/(root)/loading.tsx
================================================
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

export default function Loading() {
    return <LoadingSpinner />;
}


================================================
File: src/app/(root)/not-found.tsx
================================================
import NotFoundGlobalPage from "../_components/NotFoundGlobalPage";

export default function NotFound() {
    return <NotFoundGlobalPage />;
}


================================================
File: src/app/(root)/page.tsx
================================================
import { Stack, Box, Container } from "@mui/material";
import { Movie, Serie } from "@prisma/client";
import type { Metadata } from "next";
import { authOptions } from "../api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth/next";
import HomeHeroSection from "./(home)/_components/HomeHero";
import ListHomeSection from "./(home)/_components/ListHomeSection";
import MarketingSection from "./(home)/_components/MarketingSection";
import NewsletterSection from "./(home)/_components/NewsletterSection";
import { getMoviesWithFilters } from "@/actions/movie.actions";
import { getSeriesWithFilters } from "@/actions/serie.actions";

export const metadata: Metadata = {
    title: "MovieLandia24 - Your Ultimate Destination for Movies",
    description:
        "Welcome to MovieLandia24 - your ultimate destination for movies. Discover a vast collection of movies and enjoy streaming your favorites.",
    openGraph: {
        type: "video.tv_show",
        url: process.env.NEXT_PUBLIC_PROJECT_URL,
        title: "MovieLandia24 - Your Ultimate Destination for Movies",
        description:
            "Welcome to MovieLandia24 - your ultimate destination for movies. Discover a vast collection of movies and enjoy streaming your favorites.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "MovieLandia24 - Your Ultimate Destination for Movies",
        description:
            "Welcome to MovieLandia24 - your ultimate destination for movies. Discover a vast collection of movies and enjoy streaming your favorites.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Home() {
    const session = await getServerSession(authOptions);

    const queryParams = {
        page: 1,
    };

    const moviesData = await getMoviesWithFilters(queryParams, Number(session?.user?.id));
    const movies: Movie[] = moviesData.movies;

    const seriesData = await getSeriesWithFilters(queryParams, Number(session?.user?.id));
    const series: Serie[] = seriesData.rows;

    return (
        <Box
            component="main"
            sx={{
                width: "100%",
                overflow: "hidden",
            }}
        >
            <HomeHeroSection />
            <MarketingSection />
            <NewsletterSection />
            <Container maxWidth="xl">
                <Stack>
                    <ListHomeSection
                        key={"movie"}
                        data={movies}
                        type="movie"
                        link="/movies"
                        linkText="Explore all Movies"
                    />
                    <ListHomeSection
                        key={"serie"}
                        data={series}
                        type="serie"
                        link="/series"
                        linkText="Explore all Series"
                    />
                </Stack>
            </Container>
        </Box>
    );
}


================================================
File: src/app/(root)/template.tsx
================================================
"use client";

import { motion } from "framer-motion";

export default function Template({ children }: { children: React.ReactNode }) {
    return (
        <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 1 }}
        >
            {children}
        </motion.div>
    );
}


================================================
File: src/app/(root)/(auth)/change-password/page.tsx
================================================
import ChangePasswordForm from "./_components/ChangePasswordForm";

export default async function ChangePasswordPage(props: { searchParams: Promise<{ email: string }> }) {
    const searchParams = await props.searchParams;
    const { email } = searchParams;

    return <ChangePasswordForm email={email} />;
}


================================================
File: src/app/(root)/(auth)/change-password/_components/ChangePasswordForm.tsx
================================================
"use client";

import { Visibility, VisibilityOff } from "@mui/icons-material";
import { Box, Button, FormControl, FormLabel, IconButton, InputAdornment, TextField, Typography } from "@mui/material";
import LockOutlinedIcon from "@mui/icons-material/LockOutlined";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { showToast } from "@/utils/helpers/toast";
import PasswordIcon from "@mui/icons-material/Password";
import { useForm, Controller } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

interface IChangePassword {
    email: string;
}

const registerSchema = z
    .object({
        newPassword: z
            .string()
            .min(8, { message: "Password must be at least 8 characters" })
            .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/, {
                message:
                    "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character",
            })
            .min(1, { message: "New password is required" }),
        confirmPassword: z.string().min(1, "Please confirm your password"),
    })
    .superRefine((data, ctx) => {
        if (data.newPassword !== data.confirmPassword) {
            ctx.addIssue({
                code: "custom",
                path: ["confirmPassword"],
                message: "Passwords must match",
            });
        }
    });

export default function ChangePasswordForm({ email }: IChangePassword) {
    const [showNewPassword, setShowNewPassword] = useState(false);
    const [showConfirmPassword, setShowConfirmPassword] = useState(false);

    const handleClickShowNewPassword = () => setShowNewPassword(!showNewPassword);
    const handleClickShowConfirmPassword = () => setShowConfirmPassword(!showConfirmPassword);

    const router = useRouter();

    async function handleSubmitChangePassword(values: { newPassword: string; confirmPassword: string }) {
        try {
            const response = await fetch("/api/changePassword", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ newPassword: values.newPassword, email }),
            });

            if (response.ok) {
                showToast("success", "Your password has been changed successfully.");
                router.push("/login");
            } else {
                const data = await response.json();
                showToast("error", data.message || "An error occurred. Please try again.");
            }
        } catch (error) {
            showToast("error", "An error occurred. Please try again later.");
        }
    }

    const {
        control,
        handleSubmit,
        formState: { errors, isSubmitting },
    } = useForm({
        resolver: zodResolver(registerSchema),
        defaultValues: {
            newPassword: "",
            confirmPassword: "",
        },
    });

    return (
        <form onSubmit={handleSubmit(handleSubmitChangePassword)}>
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    alignItems: "center",
                    padding: 6,
                    height: "100vh",
                }}
            >
                <Box display={"flex"} flexDirection="row" columnGap={1} sx={{ pb: 4 }}>
                    <LockOutlinedIcon fontSize="large" />
                    <Typography variant="h2" textAlign={"center"}>
                        Change Password
                    </Typography>
                </Box>
                <Box display={"flex"} flexDirection={"row"} columnGap={3}>
                    <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                        <Box display={"flex"} flexDirection="row" columnGap={1}>
                            <PasswordIcon />
                            <FormLabel component={"label"}>New Password</FormLabel>
                        </Box>
                        <FormControl variant="outlined" fullWidth size="small">
                            <Box sx={{ minHeight: "100px" }}>
                                <Controller
                                    name="newPassword"
                                    control={control}
                                    render={({ field }) => (
                                        <TextField
                                            {...field}
                                            type={showNewPassword ? "text" : "password"}
                                            size="small"
                                            slotProps={{
                                                input: {
                                                    endAdornment: (
                                                        <InputAdornment position="end">
                                                            <IconButton onClick={handleClickShowNewPassword}>
                                                                {showNewPassword ? <Visibility /> : <VisibilityOff />}
                                                            </IconButton>
                                                        </InputAdornment>
                                                    ),
                                                },
                                            }}
                                            error={!!errors.newPassword}
                                            helperText={errors.newPassword?.message}
                                            sx={{
                                                "& .MuiFormHelperText-root": {
                                                    whiteSpace: "normal",
                                                    overflowWrap: "break-word",
                                                    wordWrap: "break-word",
                                                    maxWidth: "200px",
                                                },
                                            }}
                                        />
                                    )}
                                />
                            </Box>
                        </FormControl>
                    </Box>
                    <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                        <Box display={"flex"} flexDirection="row" columnGap={1}>
                            <PasswordIcon />
                            <FormLabel component={"label"}>Confirm New Password</FormLabel>
                        </Box>
                        <FormControl variant="outlined" fullWidth size="small">
                            <Box sx={{ minHeight: "100px" }}>
                                <Controller
                                    name="confirmPassword"
                                    control={control}
                                    render={({ field }) => (
                                        <TextField
                                            {...field}
                                            type={showConfirmPassword ? "text" : "password"}
                                            size="small"
                                            slotProps={{
                                                input: {
                                                    endAdornment: (
                                                        <InputAdornment position="end">
                                                            <IconButton onClick={handleClickShowConfirmPassword}>
                                                                {showConfirmPassword ? (
                                                                    <Visibility />
                                                                ) : (
                                                                    <VisibilityOff />
                                                                )}
                                                            </IconButton>
                                                        </InputAdornment>
                                                    ),
                                                },
                                            }}
                                            error={!!errors.confirmPassword}
                                            helperText={errors.confirmPassword?.message}
                                            sx={{
                                                "& .MuiFormHelperText-root": {
                                                    whiteSpace: "normal",
                                                    overflowWrap: "break-word",
                                                    wordWrap: "break-word",
                                                    maxWidth: "200px",
                                                },
                                            }}
                                        />
                                    )}
                                />
                            </Box>
                        </FormControl>
                    </Box>
                </Box>
                <Button type="submit" variant="outlined" sx={{ fontWeight: 600, py: 1 }} disabled={isSubmitting}>
                    <LockOutlinedIcon />
                    <Typography component={"span"} sx={{ fontSize: 16, paddingLeft: 1, textTransform: "capitalize" }}>
                        Change Password
                    </Typography>
                </Button>
            </Box>
        </form>
    );
}


================================================
File: src/app/(root)/(auth)/login/page.tsx
================================================
import { Box, Paper } from "@mui/material";
import type { Metadata } from "next";
import LoginForm from "./_components/LoginForm";
import Image from "next/image";

export const metadata: Metadata = {
    title: "Login - MovieLandia24 - Your Ultimate Destination for Movies",
    description: "Login to the page",
};

export default async function Login() {
    return (
        <Box
            sx={{
                position: "relative",
                display: "flex",
                placeContent: "center",
                placeItems: "center",
                paddingTop: 10,
                paddingBottom: 10,
            }}
            component="section"
        >
            <Box
                sx={{
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    zIndex: -1,
                }}
            >
                <Image
                    src="/images/backgrounds/netflix.png"
                    alt="Background Image"
                    fill
                    priority={true}
                    style={{
                        objectFit: "cover",
                    }}
                />
                <Box
                    sx={{
                        position: "absolute",
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: "rgba(0, 0, 0, 0.6)",
                        filter: "blur(2px)",
                    }}
                />
            </Box>
            <Paper
                sx={{
                    px: 10,
                    py: 4,
                    borderRadius: 4,
                    position: "relative",
                    zIndex: 1,
                }}
            >
                <LoginForm />
            </Paper>
        </Box>
    );
}


================================================
File: src/app/(root)/(auth)/login/_components/LoginForm.tsx
================================================
"use client";

import { Visibility, VisibilityOff } from "@mui/icons-material";
import {
    Box,
    Button,
    FormControl,
    FormLabel,
    IconButton,
    InputAdornment,
    TextField,
    Typography,
    Link as MuiLink,
    Divider,
} from "@mui/material";
import { useState } from "react";
import Link from "next/link";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { showToast } from "@/utils/helpers/toast";
import EmailIcon from "@mui/icons-material/Email";
import PasswordIcon from "@mui/icons-material/Password";
import GoogleIcon from "@mui/icons-material/Google";
import LockOutlinedIcon from "@mui/icons-material/LockOutlined";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { loginSchema } from "@/schemas/auth.schema";

export default function LoginForm() {
    const [showPassword, setShowPassword] = useState(false);
    const router = useRouter();

    const {
        control,
        handleSubmit,
        formState: { errors, isSubmitting },
    } = useForm({
        resolver: zodResolver(loginSchema),
        defaultValues: { email: "", password: "" },
        mode: "onChange",
    });

    const handleClickShowPassword = () => setShowPassword(!showPassword);
    const handleMouseDownPassword = () => setShowPassword(!showPassword);

    async function handleSubmitLogin(values: { email: string; password: string }) {
        const result = await signIn("credentials", {
            redirect: false,
            email: values.email,
            password: values.password,
            callbackUrl: "/",
        });

        if (result?.error) {
            showToast("error", result?.error);
        } else if (result?.url) {
            router.push(result.url);
            router.refresh();
            showToast("success", "You are successfully logged in!");
        }
    }

    return (
        <Box sx={{ width: "100%", maxWidth: "400px", margin: "0 auto" }}>
            <form onSubmit={handleSubmit(handleSubmitLogin)}>
                <Box sx={{ display: "flex", flexDirection: "column", rowGap: 1 }}>
                    <Box
                        display={"flex"}
                        flexDirection="row"
                        columnGap={1}
                        alignItems={"center"}
                        justifyContent={"center"}
                        sx={{ pb: 4 }}
                    >
                        <LockOutlinedIcon fontSize="large" />
                        <Typography variant="h2" textAlign={"center"}>
                            Sign In
                        </Typography>
                    </Box>
                    <Box sx={{ display: "flex", flexDirection: "column", rowGap: 2 }}>
                        <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                            <Box display={"flex"} flexDirection="row" columnGap={1}>
                                <EmailIcon />
                                <FormLabel component={"label"}>Email</FormLabel>
                            </Box>
                            <FormControl>
                                <Controller
                                    name="email"
                                    control={control}
                                    render={({ field }) => (
                                        <TextField
                                            {...field}
                                            type="email"
                                            autoComplete="username"
                                            size="small"
                                            fullWidth
                                            error={!!errors.email}
                                            helperText={errors.email?.message}
                                            sx={{
                                                "& .MuiFormHelperText-root": {
                                                    whiteSpace: "normal",
                                                    overflowWrap: "break-word",
                                                    wordWrap: "break-word",
                                                    maxWidth: "200px",
                                                },
                                            }}
                                        />
                                    )}
                                />
                            </FormControl>
                        </Box>
                        <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                            <Box display={"flex"} flexDirection="row" columnGap={1}>
                                <PasswordIcon />
                                <FormLabel component={"label"}>Password</FormLabel>
                            </Box>
                            <FormControl>
                                <Controller
                                    name="password"
                                    control={control}
                                    render={({ field }) => (
                                        <TextField
                                            {...field}
                                            type={showPassword ? "text" : "password"}
                                            autoComplete="current-password"
                                            size="small"
                                            fullWidth
                                            error={!!errors.password}
                                            helperText={errors.password?.message}
                                            slotProps={{
                                                input: {
                                                    endAdornment: (
                                                        <InputAdornment position="end">
                                                            <IconButton
                                                                onClick={handleClickShowPassword}
                                                                onMouseDown={handleMouseDownPassword}
                                                                edge="end"
                                                            >
                                                                {showPassword ? <Visibility /> : <VisibilityOff />}
                                                            </IconButton>
                                                        </InputAdornment>
                                                    ),
                                                },
                                            }}
                                            sx={{
                                                "& .MuiFormHelperText-root": {
                                                    whiteSpace: "normal",
                                                    overflowWrap: "break-word",
                                                    wordWrap: "break-word",
                                                    maxWidth: "200px",
                                                },
                                            }}
                                        />
                                    )}
                                />
                            </FormControl>
                        </Box>
                    </Box>
                    <Box
                        sx={{
                            display: "flex",
                            justifyContent: "center",
                            marginTop: 2,
                            flexDirection: "column",
                            rowGap: 1,
                        }}
                    >
                        <Button
                            type="submit"
                            variant="outlined"
                            sx={{ fontWeight: 600, py: 1, px: 4 }}
                            disabled={isSubmitting}
                        >
                            <LockOutlinedIcon />
                            <Typography
                                component={"span"}
                                sx={{ fontSize: 16, paddingLeft: 1, textTransform: "capitalize" }}
                            >
                                Sign In
                            </Typography>
                        </Button>
                        <Box sx={{ display: "flex", alignItems: "center", width: "100%", my: 1 }}>
                            <Divider sx={{ flexGrow: 1 }} />
                            <Typography
                                variant="body2"
                                component="span"
                                sx={{
                                    px: 2,
                                    color: "text.secondary",
                                    fontWeight: 500,
                                    fontSize: "0.875rem",
                                }}
                            >
                                OR
                            </Typography>
                            <Divider sx={{ flexGrow: 1 }} />
                        </Box>
                        <Button
                            onClick={() => signIn("google", { callbackUrl: "/" })}
                            variant="outlined"
                            sx={{ fontWeight: 600, py: 1 }}
                        >
                            <GoogleIcon />
                            <Typography
                                component={"span"}
                                sx={{ fontSize: 16, paddingLeft: 1, textTransform: "capitalize" }}
                            >
                                Continue with Google
                            </Typography>
                        </Button>
                    </Box>
                    <Box>
                        <MuiLink
                            component={Link}
                            href="/reset-password"
                            underline="none"
                            sx={{ textAlign: "right", mt: 1, fontSize: 12, pl: 4, textTransform: "capitalize" }}
                        >
                            Forgot Password?
                        </MuiLink>
                    </Box>
                    <Box>
                        <Typography component={"span"} sx={{ fontSize: 14, pl: 4, textTransform: "capitalize" }}>
                            Don&apos;t have an account?
                        </Typography>
                        <MuiLink
                            component={Link}
                            href="/register"
                            underline="none"
                            sx={{ textAlign: "right", mt: 1, fontSize: 14, pl: 4, textTransform: "capitalize" }}
                        >
                            Sign Up
                        </MuiLink>
                    </Box>
                </Box>
            </form>
        </Box>
    );
}


================================================
File: src/app/(root)/(auth)/register/page.tsx
================================================
import { Box, Paper } from "@mui/material";
import type { Metadata } from "next";
import RegisterForm from "./_components/RegisterForm";
import Image from "next/image";

export const metadata: Metadata = {
    title: "Register - MovieLandia24 - Your Ultimate Destination for Movies",
    description: "Register to the page",
};

export default async function Register() {
    return (
        <Box
            sx={{
                position: "relative",
                display: "flex",
                placeContent: "center",
                placeItems: "center",
                paddingTop: 10,
                paddingBottom: 10,
            }}
            component="section"
        >
            <Box
                sx={{
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    zIndex: -1,
                }}
            >
                <Image
                    src="/images/backgrounds/netflix.png"
                    alt="Background Image"
                    fill
                    priority={true}
                    style={{
                        objectFit: "cover",
                    }}
                />
                <Box
                    sx={{
                        position: "absolute",
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: "rgba(0, 0, 0, 0.6)",
                        filter: "blur(2px)",
                    }}
                />
            </Box>

            <Paper
                sx={{
                    px: 8,
                    py: 4,
                    borderRadius: 4,
                    position: "relative",
                    zIndex: 1,
                }}
            >
                <RegisterForm />
            </Paper>
        </Box>
    );
}


================================================
File: src/app/(root)/(auth)/register/_components/RegisterForm.tsx
================================================
"use client";

import { Visibility, VisibilityOff } from "@mui/icons-material";
import {
    Box,
    Button,
    FormControl,
    FormLabel,
    IconButton,
    InputAdornment,
    TextField,
    Typography,
    Divider,
    Checkbox,
    FormHelperText,
    Link,
} from "@mui/material";
import { useState } from "react";
import { showToast } from "@/utils/helpers/toast";
import { signUp } from "@/actions/auth.actions";
import EmailIcon from "@mui/icons-material/Email";
import PasswordIcon from "@mui/icons-material/Password";
import PersonIcon from "@mui/icons-material/Person";
import LockOutlinedIcon from "@mui/icons-material/LockOutlined";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import GoogleIcon from "@mui/icons-material/Google";
import { signIn } from "next-auth/react";
import { registerSchema } from "@/schemas/auth.schema";

export default function RegisterForm() {
    const [showPassword, setShowPassword] = useState(false);
    const [showPasswordConfirm, setShowPasswordConfirm] = useState(false);

    const {
        control,
        handleSubmit,
        formState: { errors, isSubmitting },
    } = useForm({
        resolver: zodResolver(registerSchema),
        defaultValues: {
            userName: "",
            email: "",
            password: "",
            confirmPassword: "",
            acceptTerms: false,
        },
        mode: "onChange",
    });

    const handleClickShowPassword = () => setShowPassword(!showPassword);
    const handleMouseDownPassword = () => setShowPassword(!showPassword);

    const handleClickShowPasswordConfirm = () => setShowPasswordConfirm(!showPasswordConfirm);
    const handleMouseDownPasswordConfirm = () => setShowPasswordConfirm(!showPasswordConfirm);

    async function handleSubmitRegister(values: {
        userName: string;
        email: string;
        password: string;
        confirmPassword: string;
        acceptTerms: boolean;
    }) {
        const userData = {
            userName: values.userName,
            email: values.email,
            password: values.password,
        };

        try {
            await signUp(userData);
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while registering the user.");
            }
        }
    }

    return (
        <form onSubmit={handleSubmit(handleSubmitRegister)}>
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    rowGap: 2,
                    maxWidth: "300px",
                    margin: "0 auto",
                    width: "100%",
                }}
            >
                <Box
                    display={"flex"}
                    flexDirection="row"
                    columnGap={1}
                    alignItems={"center"}
                    justifyContent={"center"}
                    sx={{ pb: 1 }}
                >
                    <LockOutlinedIcon fontSize="large" />
                    <Typography variant="h2" sx={{ textTransform: "capitalize" }}>
                        Sign Up
                    </Typography>
                </Box>
                <Box sx={{ display: "flex", flexDirection: "column", rowGap: 2 }}>
                    <FormControl variant="outlined" size="small" sx={{ rowGap: 1 }}>
                        <Box display={"flex"} flexDirection="row" alignItems="center" columnGap={1}>
                            <PersonIcon />
                            <FormLabel>Username</FormLabel>
                        </Box>
                        <Controller
                            name="userName"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    size="small"
                                    error={!!errors.userName}
                                    helperText={errors.userName?.message}
                                    sx={{
                                        "& .MuiFormHelperText-root": {
                                            whiteSpace: "normal",
                                            overflowWrap: "break-word",
                                            wordWrap: "break-word",
                                            maxWidth: "100%",
                                        },
                                    }}
                                />
                            )}
                        />
                    </FormControl>
                    <FormControl variant="outlined" size="small" sx={{ rowGap: 1 }}>
                        <Box display={"flex"} flexDirection="row" alignItems="center" columnGap={1}>
                            <EmailIcon />
                            <FormLabel>Email</FormLabel>
                        </Box>
                        <Controller
                            name="email"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    size="small"
                                    error={!!errors.email}
                                    helperText={errors.email?.message}
                                    sx={{
                                        "& .MuiFormHelperText-root": {
                                            whiteSpace: "normal",
                                            overflowWrap: "break-word",
                                            wordWrap: "break-word",
                                            maxWidth: "100%",
                                        },
                                    }}
                                />
                            )}
                        />
                    </FormControl>
                    <FormControl variant="outlined" size="small" sx={{ rowGap: 1 }}>
                        <Box display={"flex"} flexDirection="row" alignItems="center" columnGap={1}>
                            <PasswordIcon />
                            <FormLabel>Password</FormLabel>
                        </Box>
                        <Controller
                            name="password"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    type={showPassword ? "text" : "password"}
                                    size="small"
                                    slotProps={{
                                        input: {
                                            endAdornment: (
                                                <InputAdornment position="end">
                                                    <IconButton
                                                        onClick={handleClickShowPassword}
                                                        onMouseDown={handleMouseDownPassword}
                                                    >
                                                        {showPassword ? <Visibility /> : <VisibilityOff />}
                                                    </IconButton>
                                                </InputAdornment>
                                            ),
                                        },
                                    }}
                                    error={!!errors.password}
                                    helperText={errors.password?.message}
                                    sx={{
                                        "& .MuiFormHelperText-root": {
                                            whiteSpace: "normal",
                                            overflowWrap: "break-word",
                                            wordWrap: "break-word",
                                            maxWidth: "100%",
                                        },
                                    }}
                                />
                            )}
                        />
                    </FormControl>
                    <FormControl variant="outlined" size="small" sx={{ rowGap: 1 }}>
                        <Box display={"flex"} flexDirection="row" alignItems="center" columnGap={1}>
                            <PasswordIcon />
                            <FormLabel>Confirm Password</FormLabel>
                        </Box>
                        <Controller
                            name="confirmPassword"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    type={showPasswordConfirm ? "text" : "password"}
                                    size="small"
                                    slotProps={{
                                        input: {
                                            endAdornment: (
                                                <InputAdornment position="end">
                                                    <IconButton
                                                        onClick={handleClickShowPasswordConfirm}
                                                        onMouseDown={handleMouseDownPasswordConfirm}
                                                    >
                                                        {showPasswordConfirm ? <Visibility /> : <VisibilityOff />}
                                                    </IconButton>
                                                </InputAdornment>
                                            ),
                                        },
                                    }}
                                    error={!!errors.confirmPassword}
                                    helperText={errors.confirmPassword?.message}
                                    sx={{
                                        "& .MuiFormHelperText-root": {
                                            whiteSpace: "normal",
                                            overflowWrap: "break-word",
                                            wordWrap: "break-word",
                                            maxWidth: "100%",
                                        },
                                    }}
                                />
                            )}
                        />
                    </FormControl>
                    <FormControl variant="outlined" size="small">
                        <Controller
                            name="acceptTerms"
                            control={control}
                            render={({ field }) => (
                                <Box
                                    sx={{
                                        display: "flex",
                                        alignItems: "center",
                                        gap: 1,
                                    }}
                                >
                                    <Checkbox
                                        {...field}
                                        size="medium"
                                        checked={field.value}
                                        sx={{
                                            p: 0.5,
                                            mt: "-2px",
                                        }}
                                    />
                                    <Box
                                        sx={{
                                            display: "flex",
                                            alignItems: "center",
                                            flexWrap: "wrap",
                                            gap: 0.5,
                                            fontSize: "0.95rem",
                                        }}
                                    >
                                        <Typography
                                            component="span"
                                            sx={{
                                                fontSize: "inherit",
                                                lineHeight: 1.5,
                                                fontWeight: 500,
                                                color: "text.primary",
                                            }}
                                        >
                                            I agree to the
                                        </Typography>
                                        <Link
                                            href="/terms"
                                            target="_blank"
                                            sx={{
                                                textDecoration: "none",
                                                color: "primary.main",
                                                fontSize: "inherit",
                                                lineHeight: 1.5,
                                                "&:hover": {
                                                    textDecoration: "underline",
                                                },
                                            }}
                                        >
                                            Terms of Service
                                        </Link>
                                        <Typography
                                            component="span"
                                            sx={{
                                                fontSize: "inherit",
                                                lineHeight: 1.5,
                                            }}
                                        >
                                            and
                                        </Typography>
                                        <Link
                                            href="/privacy"
                                            target="_blank"
                                            sx={{
                                                textDecoration: "none",
                                                color: "primary.main",
                                                fontSize: "inherit",
                                                lineHeight: 1.5,
                                                "&:hover": {
                                                    textDecoration: "underline",
                                                },
                                            }}
                                        >
                                            Privacy Policy
                                        </Link>
                                    </Box>
                                </Box>
                            )}
                        />
                        {errors.acceptTerms && (
                            <FormHelperText error sx={{ mt: 0.5, ml: "32px" }}>
                                {errors.acceptTerms.message}
                            </FormHelperText>
                        )}
                    </FormControl>
                </Box>
                <Box
                    sx={{ display: "flex", justifyContent: "center", marginTop: 2, flexDirection: "column", rowGap: 1 }}
                >
                    <Button
                        type="submit"
                        variant="outlined"
                        fullWidth
                        disabled={isSubmitting}
                        sx={{
                            fontWeight: 600,
                            py: 1,
                            px: 4,
                        }}
                    >
                        <LockOutlinedIcon />
                        <Typography
                            component={"span"}
                            sx={{
                                fontSize: 16,
                                paddingLeft: 1,
                                textTransform: "capitalize",
                            }}
                        >
                            Sign Up
                        </Typography>
                    </Button>

                    <Box sx={{ display: "flex", alignItems: "center", width: "100%", my: 1 }}>
                        <Divider sx={{ flexGrow: 1 }} />
                        <Typography
                            variant="body2"
                            component="span"
                            sx={{
                                px: 2,
                                color: "text.secondary",
                                fontWeight: 500,
                                fontSize: "0.875rem",
                            }}
                        >
                            OR
                        </Typography>
                        <Divider sx={{ flexGrow: 1 }} />
                    </Box>

                    <Button
                        onClick={() => signIn("google", { callbackUrl: "/" })}
                        variant="outlined"
                        sx={{ fontWeight: 600, py: 1 }}
                    >
                        <GoogleIcon />
                        <Typography
                            component={"span"}
                            sx={{
                                fontSize: 16,
                                paddingLeft: 1,
                                textTransform: "capitalize",
                            }}
                        >
                            Continue with Google
                        </Typography>
                    </Button>

                    <Typography
                        variant="body2"
                        sx={{
                            textAlign: "center",
                            mt: 1,
                            fontSize: 14,
                        }}
                    >
                        Already have an account?{" "}
                        <Link
                            href="/login"
                            sx={{
                                textDecoration: "none",
                                pl: 1,
                                fontSize: 14,
                                textTransform: "capitalize",
                                "&:hover": {
                                    textDecoration: "underline",
                                },
                            }}
                        >
                            Sign In
                        </Link>
                    </Typography>
                </Box>
            </Box>
        </form>
    );
}


================================================
File: src/app/(root)/(home)/_components/HomeHero.tsx
================================================
"use client";

import { Typography, Button, Box } from "@mui/material";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import MovieIcon from "@mui/icons-material/Movie";
import Link from "next/link";
import Image from "next/image";
import { motion } from "framer-motion";

const HomeHeroSection = () => {
    const containerVariants = {
        hidden: { opacity: 0 },
        visible: {
            opacity: 1,
            transition: { staggerChildren: 0.2, ease: "easeOut" },
        },
    };

    const itemVariants = {
        hidden: { opacity: 0, y: 50 },
        visible: { opacity: 1, y: 0, transition: { duration: 0.7, ease: "easeOut" } },
    };

    return (
        <Box
            sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                minHeight: "100vh",
                position: "relative",
                textAlign: "center",
                overflow: "hidden",
                padding: "3rem 0",
            }}
        >
            <Box
                sx={{
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    zIndex: -1,
                    "&::after": {
                        content: '""',
                        position: "absolute",
                        top: 0,
                        left: 0,
                        width: "100%",
                        height: "100%",
                        background: "linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%)",
                    },
                }}
            >
                <Image
                    src="/images/backgrounds/netflix.png"
                    alt="Background Image"
                    fill
                    priority={true}
                    style={{ objectFit: "cover", objectPosition: "center" }}
                />
            </Box>
            <motion.div
                initial="hidden"
                animate="visible"
                variants={containerVariants}
                style={{
                    maxWidth: "75%",
                    margin: "0 auto",
                    display: "flex",
                    flexDirection: "column",
                    gap: "1.5rem",
                    zIndex: 1,
                }}
            >
                <motion.div variants={itemVariants}>
                    <Typography
                        variant="h1"
                        fontSize={{ xs: 36, sm: 48, md: 64, lg: 72 }}
                        fontWeight={900}
                        letterSpacing={{ xs: 1, md: 2 }}
                        sx={{ color: "#fff", textShadow: "2px 2px 4px rgba(0,0,0,0.5)" }}
                    >
                        Dive into MovieLandia24
                    </Typography>
                </motion.div>
                <motion.div variants={itemVariants}>
                    <Typography
                        variant="h2"
                        fontSize={{ xs: 22, sm: 28, md: 36, lg: 42 }}
                        fontWeight={700}
                        sx={{ color: "#fff", textShadow: "1px 1px 3px rgba(0,0,0,0.4)", opacity: 0.95 }}
                    >
                        Your Gateway to the World of Cinema!
                    </Typography>
                </motion.div>
                <motion.div variants={itemVariants}>
                    <Typography
                        variant="body1"
                        fontSize={{ xs: 16, sm: 18, md: 20 }}
                        fontWeight={500}
                        sx={{
                            color: "grey.100",
                            maxWidth: { xs: "100%", md: "80%" },
                            mx: "auto",
                            opacity: 0.9,
                        }}
                    >
                        Explore the latest blockbusters and timeless classics in our curated collection of movies and
                        series.
                    </Typography>
                </motion.div>
                <Box
                    sx={{
                        display: "flex",
                        gap: "1.5rem",
                        justifyContent: "center",
                        marginTop: "1rem",
                        flexWrap: "wrap",
                    }}
                >
                    <motion.div variants={itemVariants}>
                        <Button
                            component={Link}
                            href="/movies"
                            variant="outlined"
                            size="large"
                            startIcon={<LocalMoviesIcon />}
                            sx={{
                                px: { xs: 3, md: 4 },
                                py: { xs: 1.5, md: 2 },
                                fontSize: { xs: 16, md: 18 },
                                fontWeight: 700,
                                borderRadius: 2,
                                textTransform: "none",
                                borderWidth: 2,
                                color: "common.white",
                                borderColor: "common.white",
                                backdropFilter: "blur(4px)",
                                backgroundColor: "rgba(255,255,255,0.05)",
                                "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                            }}
                        >
                            Explore Movies
                        </Button>
                    </motion.div>
                    <motion.div variants={itemVariants}>
                        <Button
                            component={Link}
                            href="/series"
                            variant="outlined"
                            size="large"
                            startIcon={<MovieIcon />}
                            sx={{
                                px: { xs: 3, md: 4 },
                                py: { xs: 1.5, md: 2 },
                                fontSize: { xs: 16, md: 18 },
                                fontWeight: 700,
                                borderRadius: 2,
                                textTransform: "none",
                                borderWidth: 2,
                                color: "common.white",
                                borderColor: "common.white",
                                backdropFilter: "blur(4px)",
                                backgroundColor: "rgba(255,255,255,0.05)",
                                "&:hover": { backgroundColor: "rgba(255,255,255,0.1)" },
                            }}
                        >
                            Browse Series
                        </Button>
                    </motion.div>
                </Box>
            </motion.div>
        </Box>
    );
};

export default HomeHeroSection;


================================================
File: src/app/(root)/(home)/_components/ListHomeSection.tsx
================================================
"use client";

import CardItem from "@/components/root/cardItem/CardItem";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { Genre, Movie, Serie } from "@prisma/client";
import NextLink from "next/link";
import type {} from "@mui/material/themeCssVarsAugmentation";

type MovieWithBookmark = Movie & {
    isBookmarked?: boolean;
};

type SerieWithBookmark = Serie & {
    isBookmarked?: boolean;
};

interface IListHomeSectionProps {
    data: Array<MovieWithBookmark | SerieWithBookmark | Genre>;
    type: "movie" | "serie";
    link: string;
    linkText: string;
    path?: string;
}

const ListHomeSection = ({ data, type, link, linkText, path }: IListHomeSectionProps) => {
    const theme = useTheme();

    const getSectionTitle = () => {
        switch (type) {
            case "movie":
                return "Trending Movies";
            case "serie":
                return "Trending Series";
            default:
                return "";
        }
    };

    const transformItemToCardData = (item: MovieWithBookmark | SerieWithBookmark | Genre) => {
        if (type === "movie") {
            const movieData = item as MovieWithBookmark;

            return {
                id: movieData.id,
                photoSrcProd: movieData.photoSrcProd,
                description: movieData.description,
                title: movieData.title,
                ratingImdb: movieData.ratingImdb,
                dateAired: movieData.dateAired,
                isBookmarked: movieData.isBookmarked,
            };
        } else if (type === "serie") {
            const serieData = item as SerieWithBookmark;

            return {
                id: serieData.id,
                photoSrcProd: serieData.photoSrcProd,
                description: serieData.description,
                title: serieData.title,
                ratingImdb: serieData.ratingImdb,
                dateAired: serieData.dateAired,
                isBookmarked: serieData.isBookmarked,
            };
        }

        return null;
    };

    return (
        <Box
            component="section"
            sx={{
                py: { xs: 3, md: 4 },
                px: { xs: 2, sm: 3, md: 4 },
            }}
        >
            <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: { xs: 1, md: 2 } }}>
                <Typography
                    variant="h2"
                    sx={{
                        fontWeight: 800,
                        fontSize: { xs: 24, sm: 28, md: 32 },
                        color: theme.vars.palette.text.primary,
                        position: "relative",
                        display: "inline-block",
                        "&::after": {
                            content: '""',
                            position: "absolute",
                            bottom: -8,
                            left: 0,
                            width: "100%",
                            height: 3,
                            backgroundColor: theme.vars.palette.primary.main,
                            borderRadius: 1,
                        },
                    }}
                >
                    {getSectionTitle()}
                </Typography>
                <NextLink
                    href={link}
                    style={{
                        textDecoration: "none",
                        color: "inherit",
                        display: "flex",
                        alignItems: "center",
                        gap: "4px",
                        transition: "all 0.2s ease",
                    }}
                >
                    <Typography
                        sx={{
                            fontWeight: 700,
                            fontSize: { xs: 14, sm: 16 },
                            color: theme.vars.palette.primary.main,
                            transition: "opacity 0.2s ease",
                            "&:hover": {
                                opacity: 0.8,
                            },
                        }}
                    >
                        {linkText}
                    </Typography>
                </NextLink>
            </Stack>
            <Box
                sx={{
                    width: "100%",
                    overflow: "hidden",
                    mt: { xs: 4, md: 5 },
                }}
            >
                <Stack
                    direction="row"
                    flexWrap="wrap"
                    sx={{
                        columnGap: { xs: 1, sm: 2, md: 3 },
                        rowGap: { xs: 3, sm: 4, md: 5 },
                        justifyContent: {
                            xs: "center",
                            md: "flex-start",
                        },
                        mx: { xs: 1, sm: 2 },
                        mb: { xs: 3, md: 4 },
                    }}
                >
                    {data?.map((item, index) => {
                        const cardData = transformItemToCardData(item);

                        if (!cardData) {
                            return null;
                        }

                        return <CardItem key={index} data={cardData} type={type} path={path} />;
                    })}
                </Stack>
            </Box>
        </Box>
    );
};

export default ListHomeSection;


================================================
File: src/app/(root)/(home)/_components/MarketingSection.tsx
================================================
"use client";

import { Box, Container, Typography, useTheme } from "@mui/material";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import UpdateIcon from "@mui/icons-material/Update";
import CollectionsIcon from "@mui/icons-material/Collections";
import DevicesIcon from "@mui/icons-material/Devices";
import { motion } from "framer-motion";

const features = [
    {
        icon: <CollectionsIcon sx={{ fontSize: 40 }} />,
        title: "Extensive Library",
        description: "Access thousands of movies and TV shows, from latest releases to timeless classics.",
    },
    {
        icon: <LocalMoviesIcon sx={{ fontSize: 40 }} />,
        title: "Curated Collections",
        description: "Discover handpicked selections organized by genre, mood, and themes.",
    },
    {
        icon: <UpdateIcon sx={{ fontSize: 40 }} />,
        title: "Regular Updates",
        description: "New content added weekly to keep you entertained with fresh releases.",
    },
    {
        icon: <DevicesIcon sx={{ fontSize: 40 }} />,
        title: "Cross-Platform Support",
        description: "Watch seamlessly across all your devices, anytime and anywhere.",
    },
];

const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: { staggerChildren: 0.2, ease: "easeOut" },
    },
};

const itemVariants = {
    hidden: { opacity: 0, y: 50 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.7, ease: "easeOut" } },
};

const MarketingSection = () => {
    const theme = useTheme();

    return (
        <Box
            component="section"
            sx={{
                py: { xs: 4, md: 5 },
                backgroundColor: theme.palette.background.default,
                position: "relative",
                width: "100%",
            }}
        >
            <Container
                maxWidth="lg"
                sx={{
                    px: { xs: 2, sm: 3, md: 4 },
                }}
            >
                <motion.div
                    initial="hidden"
                    whileInView="visible"
                    viewport={{ once: true, amount: 0.3 }}
                    variants={containerVariants}
                >
                    <motion.div variants={itemVariants}>
                        <Box
                            sx={{
                                textAlign: "center",
                                mb: { xs: 5, md: 8 },
                                maxWidth: "800px",
                                mx: "auto",
                            }}
                        >
                            <Typography
                                variant="h2"
                                sx={{
                                    fontSize: { xs: 28, sm: 32, md: 40 },
                                    fontWeight: 800,
                                    mb: 2,
                                    background: `linear-gradient(45deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,
                                    backgroundClip: "text",
                                    WebkitBackgroundClip: "text",
                                    color: "transparent",
                                    WebkitTextFillColor: "transparent",
                                }}
                            >
                                Welcome to MovieLandia24
                            </Typography>
                            <Typography
                                variant="h3"
                                sx={{
                                    fontSize: { xs: 16, sm: 18, md: 20 },
                                    color: "text.secondary",
                                    lineHeight: 1.6,
                                }}
                            >
                                Your premier destination for cinematic entertainment. We bring you a vast collection of
                                movies and series, carefully curated to provide the best streaming experience.
                            </Typography>
                        </Box>
                    </motion.div>

                    <Box
                        sx={{
                            maxWidth: "1200px",
                            mx: "auto",
                            display: "grid",
                            gridTemplateColumns: {
                                xs: "1fr",
                                sm: "repeat(2, 1fr)",
                                md: "repeat(4, 1fr)",
                            },
                            gap: 4,
                        }}
                    >
                        {features.map((feature, index) => (
                            <motion.div key={index} variants={itemVariants} style={{ height: "100%" }}>
                                <Box
                                    sx={{
                                        textAlign: "center",
                                        p: 3,
                                        borderRadius: 4,
                                        backgroundColor: theme.palette.background.paper,
                                        height: "100%",
                                    }}
                                >
                                    <Box
                                        sx={{
                                            color: theme.palette.primary.main,
                                            mb: 2,
                                            display: "flex",
                                            justifyContent: "center",
                                        }}
                                    >
                                        {feature.icon}
                                    </Box>
                                    <Typography
                                        variant="h6"
                                        sx={{
                                            fontWeight: 700,
                                            mb: 1,
                                            fontSize: { xs: 18, md: 20 },
                                        }}
                                    >
                                        {feature.title}
                                    </Typography>
                                    <Typography
                                        variant="body1"
                                        sx={{
                                            color: "text.secondary",
                                            fontSize: { xs: 14, md: 16 },
                                            lineHeight: 1.6,
                                        }}
                                    >
                                        {feature.description}
                                    </Typography>
                                </Box>
                            </motion.div>
                        ))}
                    </Box>
                </motion.div>
            </Container>
        </Box>
    );
};

export default MarketingSection;


================================================
File: src/app/(root)/(home)/_components/NewsletterSection.tsx
================================================
"use client";

import { Box, Button, Container, TextField, Typography, useTheme } from "@mui/material";
import MailOutlineIcon from "@mui/icons-material/MailOutline";
import { useState } from "react";
import { motion } from "framer-motion";
import { subscribeNewsletter } from "../../../../actions/auth.actions";
import { showToast } from "@/utils/helpers/toast";

const NewsletterSection = () => {
    const theme = useTheme();
    const [email, setEmail] = useState("");

    const handleSubscribe = async () => {
        try {
            const message = await subscribeNewsletter({ email });
            const messageType = message.includes("successful") ? "success" : "error";
            showToast(messageType, message);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
            showToast("error", errorMessage);
        }
    };

    const containerVariants = {
        hidden: { opacity: 0 },
        visible: {
            opacity: 1,
            transition: { staggerChildren: 0.2, ease: "easeOut" },
        },
    };

    const itemVariants = {
        hidden: { opacity: 0, y: 50 },
        visible: { opacity: 1, y: 0, transition: { duration: 0.7, ease: "easeOut" } },
    };

    return (
        <Box
            component="section"
            sx={{
                py: { xs: 6, md: 8 },
                backgroundColor:
                    theme.palette.mode === "dark" ? "rgba(25, 118, 210, 0.05)" : "rgba(25, 118, 210, 0.02)",
                position: "relative",
                width: "100%",
                overflow: "hidden",
            }}
        >
            <Box
                sx={{
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    opacity: 0.03,
                    backgroundImage: "radial-gradient(circle at 1px 1px, #fff 1px, transparent 0)",
                    backgroundSize: "40px 40px",
                }}
            />
            <Container maxWidth="md">
                <motion.div
                    initial="hidden"
                    whileInView="visible"
                    viewport={{ once: true, amount: 0.3 }}
                    variants={containerVariants}
                >
                    <Box
                        sx={{
                            textAlign: "center",
                            position: "relative",
                            zIndex: 1,
                        }}
                    >
                        <motion.div variants={itemVariants}>
                            <Box
                                sx={{
                                    display: "inline-flex",
                                    alignItems: "center",
                                    backgroundColor: `${theme.palette.primary.main}15`,
                                    color: theme.palette.primary.main,
                                    px: 2,
                                    py: 1,
                                    borderRadius: 2,
                                    mb: 3,
                                }}
                            >
                                <MailOutlineIcon sx={{ mr: 1, fontSize: 20 }} />
                                <Typography variant="subtitle2" sx={{ fontWeight: 600, fontSize: 14 }}>
                                    Stay Updated
                                </Typography>
                            </Box>
                        </motion.div>
                        <motion.div variants={itemVariants}>
                            <Typography
                                variant="h2"
                                sx={{
                                    fontSize: { xs: 28, sm: 32, md: 40 },
                                    fontWeight: 800,
                                    mb: 2,
                                    background: `linear-gradient(45deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,
                                    backgroundClip: "text",
                                    WebkitBackgroundClip: "text",
                                    color: "transparent",
                                    WebkitTextFillColor: "transparent",
                                }}
                            >
                                Subscribe to Our Newsletter
                            </Typography>
                        </motion.div>
                        <motion.div variants={itemVariants}>
                            <Typography
                                variant="h3"
                                sx={{
                                    fontSize: { xs: 16, sm: 18 },
                                    color: "text.secondary",
                                    mb: 4,
                                    maxWidth: "600px",
                                    mx: "auto",
                                }}
                            >
                                Get notified about new releases, exclusive content, and special events. Join our
                                community of movie enthusiasts!
                            </Typography>
                        </motion.div>
                        <motion.div variants={itemVariants}>
                            <Box
                                component="form"
                                sx={{
                                    display: "flex",
                                    flexDirection: { xs: "column", sm: "row" },
                                    gap: 2,
                                    maxWidth: "500px",
                                    mx: "auto",
                                }}
                                noValidate
                            >
                                <motion.div variants={itemVariants} style={{ width: "100%" }}>
                                    <TextField
                                        fullWidth
                                        placeholder="Enter your email"
                                        variant="outlined"
                                        onChange={(e) => setEmail(e.target.value)}
                                        type="email"
                                        sx={{
                                            "& .MuiOutlinedInput-root": {
                                                backgroundColor: theme.palette.background.paper,
                                                height: 56,
                                            },
                                        }}
                                    />
                                </motion.div>
                                <motion.div variants={itemVariants}>
                                    <Button
                                        variant="contained"
                                        size="large"
                                        onClick={handleSubscribe}
                                        sx={{
                                            minWidth: { xs: "100%", sm: 180 },
                                            height: 56,
                                            textTransform: "none",
                                            fontSize: 16,
                                            fontWeight: 600,
                                            color: theme.palette.background.default,
                                            background: `linear-gradient(45deg, ${theme.palette.secondary.main}, ${theme.palette.primary.main})`,
                                            boxShadow: "0 8px 16px rgba(0, 0, 0, 0.1)",
                                            transition: "all 0.2s ease-in-out",
                                            "&:hover": {
                                                transform: "translateY(-2px)",
                                                boxShadow: "0 12px 20px rgba(0, 0, 0, 0.15)",
                                                background: `linear-gradient(45deg, ${theme.palette.primary.main}, ${theme.palette.secondary.main})`,
                                            },
                                            "&:active": {
                                                transform: "translateY(0)",
                                            },
                                        }}
                                    >
                                        Subscribe
                                    </Button>
                                </motion.div>
                            </Box>
                        </motion.div>
                        <motion.div variants={itemVariants}>
                            <Typography variant="caption" sx={{ display: "block", mt: 2, color: "text.secondary" }}>
                                By subscribing, you agree to our Privacy Policy and Terms of Service.
                            </Typography>
                        </motion.div>
                    </Box>
                </motion.div>
            </Container>
        </Box>
    );
};

export default NewsletterSection;


================================================
File: src/app/(root)/[...not-found]/page.tsx
================================================
import { notFound } from "next/navigation";

export default function NotFoundPage() {
    notFound();
}


================================================
File: src/app/(root)/about-us/page.tsx
================================================
import AboutUsContent from "./_components/AboutUsContent";
import type { Metadata } from "next";

export const metadata: Metadata = {
    title: "About Us | MovieLandia",
    description: "Learn more about MovieLandia - your premier destination for movies and TV series.",
};

export default function AboutUsPage() {
    return <AboutUsContent />;
}


================================================
File: src/app/(root)/about-us/_components/AboutUsContent.tsx
================================================
"use client";

import React from "react";
import { Container, Typography, Box, Stack, useTheme, Paper } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { motion } from "framer-motion";
import MovieIcon from "@mui/icons-material/Movie";
import TheatersIcon from "@mui/icons-material/Theaters";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";

const AboutUsContent = () => {
    const theme = useTheme();

    return (
        <Container maxWidth="lg" sx={{ py: 8 }}>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Paper
                    elevation={0}
                    sx={{
                        p: 4,
                        mb: 6,
                        borderRadius: 2,
                        background: `linear-gradient(135deg, ${theme.vars.palette.primary.main}22 0%, ${theme.vars.palette.primary.main}11 100%)`,
                    }}
                >
                    <Typography
                        variant="h2"
                        gutterBottom
                        sx={{
                            color: theme.vars.palette.primary.main,
                            fontWeight: 800,
                            textAlign: "center",
                            textTransform: "uppercase",
                            letterSpacing: "0.1em",
                        }}
                    >
                        About MovieLandia
                    </Typography>
                    <Typography
                        sx={{
                            textAlign: "center",
                            color: theme.vars.palette.text.secondary,
                            maxWidth: "800px",
                            mx: "auto",
                            mb: 4,
                        }}
                    >
                        Your premier destination for movies and TV series
                    </Typography>
                </Paper>

                <Stack spacing={6}>
                    <Box>
                        <Stack
                            direction={{ xs: "column", md: "row" }}
                            spacing={4}
                            alignItems="center"
                            component={motion.div}
                            initial={{ opacity: 0, x: -20 }}
                            animate={{ opacity: 1, x: 0 }}
                            transition={{ duration: 0.5, delay: 0.2 }}
                        >
                            <MovieIcon sx={{ fontSize: 80, color: theme.vars.palette.red.main }} />
                            <Box>
                                <Typography variant="h4" gutterBottom color="primary">
                                    Our Mission
                                </Typography>
                                <Typography variant="body1" color="text.secondary">
                                    At MovieLandia, we&apos;re passionate about bringing the magic of cinema and
                                    television television directly to you. Our platform is designed to be your ultimate
                                    companion discovering, tracking, and enjoying the best in entertainment.
                                </Typography>
                            </Box>
                        </Stack>
                    </Box>

                    <Box>
                        <Stack
                            direction={{ xs: "column", md: "row" }}
                            spacing={4}
                            alignItems="center"
                            component={motion.div}
                            initial={{ opacity: 0, x: 20 }}
                            animate={{ opacity: 1, x: 0 }}
                            transition={{ duration: 0.5, delay: 0.4 }}
                        >
                            <TheatersIcon sx={{ fontSize: 80, color: theme.vars.palette.red.main }} />
                            <Box>
                                <Typography variant="h4" gutterBottom color="primary">
                                    What We Offer
                                </Typography>
                                <Typography variant="body1" color="text.secondary">
                                    Our comprehensive database includes the latest movies and TV series, complete with
                                    detailed information, ratings, and reviews. We provide a user-friendly interface
                                    that makes it easy to find exactly what you&apos;re looking for, whether it&apos;s a
                                    classic film or the newest release.
                                </Typography>
                            </Box>
                        </Stack>
                    </Box>

                    <Box>
                        <Stack
                            direction={{ xs: "column", md: "row" }}
                            spacing={4}
                            alignItems="center"
                            component={motion.div}
                            initial={{ opacity: 0, x: -20 }}
                            animate={{ opacity: 1, x: 0 }}
                            transition={{ duration: 0.5, delay: 0.6 }}
                        >
                            <LocalMoviesIcon sx={{ fontSize: 80, color: theme.vars.palette.red.main }} />
                            <Box>
                                <Typography variant="h4" gutterBottom color="primary">
                                    Join Our Community
                                </Typography>
                                <Typography variant="body1" color="text.secondary">
                                    Become part of our growing community of movie and TV enthusiasts. Share your
                                    thoughts, rate your favorite content, and connect with others who share your passion
                                    for entertainment. MovieLandia is more than just a platform &ndash; it&apos;s a
                                    community.
                                </Typography>
                            </Box>
                        </Stack>
                    </Box>
                </Stack>
            </motion.div>
        </Container>
    );
};

export default AboutUsContent;


================================================
File: src/app/(root)/actors/page.tsx
================================================
import { Suspense } from "react";
import type { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import ActorsPageContent from "./_components/ActorsPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface IActorsProps {
    searchParams?: Promise<{ actorsAscOrDesc?: string; page?: string; actorsSortBy?: string }>;
}

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export const metadata: Metadata = {
    title: "Check Actors | High-Quality and Always Updated",
    description: "Discover the most amazing actors.",
    openGraph: {
        type: "video.other",
        url: `${baseUrl}/actors`,
        title: "Actors",
        description: "Discover the most amazing actors in high quality.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "Actors",
        description: "Discover the most amazing actors in high quality.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Actors(props: IActorsProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <ActorsPageContent searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/page.tsx
================================================
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getActorById } from "@/actions/actor.actions";
import { Actor } from "@prisma/client";
import ActorPageContent from "./_components/ActorPageContent";
import { Suspense } from "react";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface IActorProps {
    params: {
        actorId: string;
    };
    searchParams?: Promise<{
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        starredMoviesPage?: string;
        starredSeriesPage?: string;
    }>;
}

export async function generateMetadata(props: IActorProps): Promise<Metadata> {
    const params = await props.params;
    const { actorId } = params;

    let actor: Actor;

    try {
        actor = await getActorById(Number(actorId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = actor;

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/actors/${actor.fullname}`;

    return {
        title: `${actor.fullname} | Actor`,
        description: `${actor.description}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${actor.fullname} | Actor`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 160,
                          height: 200,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${actor.fullname} | Actor`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function ActorPage(props: IActorProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const { actorId } = params;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams && searchParams.reviewsAscOrDesc;
    const reviewsPage = searchParams && searchParams.reviewsPage ? Number(searchParams.reviewsPage) : 1;
    const reviewsSortBy = searchParams && searchParams.reviewsSortBy ? searchParams.reviewsSortBy : "";

    const starredMoviesPage = searchParams?.starredMoviesPage ? Number(searchParams.starredMoviesPage) : 1;
    const starredSeriesPage = searchParams?.starredSeriesPage ? Number(searchParams.starredSeriesPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        starredMoviesPage,
        starredSeriesPage,
        userId: Number(session?.user?.id),
    };

    let actor;

    try {
        actor = await getActorById(Number(actorId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const perPage = 6;
    const reviewsPageCount = Math.ceil(actor.totalReviews / 5);
    const starredMoviesPageCount = Math.ceil(actor.totalMovies / perPage);
    const starredSeriesPageCount = Math.ceil(actor.totalSeries / perPage);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <ActorPageContent
                searchParamsValues={searchParamsValues}
                actor={actor}
                reviewsPageCount={reviewsPageCount}
                starredMoviesPageCount={starredMoviesPageCount}
                starredSeriesPageCount={starredSeriesPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/_components/ActorPageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import { useEffect } from "react";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import * as CONSTANTS from "@/constants/Constants";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { onBookmarkActor, onRemoveBookmarkActor } from "@/utils/features/actorFeaturesUtils";
import { removeDownvoteActorReview, addDownvoteActorReview } from "@/actions/user/userDownvotes.actions";
import { addReviewActor, removeReviewActor, updateReviewActor } from "@/actions/user/userReviews.actions";
import { removeUpvoteActorReview, addUpvoteActorReview } from "@/actions/user/userUpvotes.actions";

interface IActorPageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        starredMoviesPage: number;
        starredSeriesPage: number;
    };
    actor: any;
    reviewsPageCount: number;
    starredMoviesPageCount: number;
    starredSeriesPageCount: number;
}

export default function ActorPageContent({
    searchParamsValues,
    actor,
    reviewsPageCount,
    starredMoviesPageCount,
    starredSeriesPageCount,
}: IActorPageContentProps) {
    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();

    const theme = useTheme();
    // #endregion

    // #region "Handlers functions"

    // #region "Review"
    async function onSubmitReview() {
        if (!session?.user || !actor) return;

        try {
            await addReviewActor({
                actorId: actor.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !actor) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewActor({
                                actorId: actor.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !actor) return;

        try {
            await updateReviewActor({
                actorId: actor.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvote, Downvote"
    async function onUpvoteActor(actorReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !actorReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });
            } else {
                await removeDownvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });

                await addUpvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the actor.");
            }
        }
    }

    async function onDownVoteActor(actorReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!actor && !actorReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });
            } else {
                await removeUpvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });

                await addDownvoteActorReview({
                    userId: Number(session?.user?.id),
                    actorId: actor.id,
                    actorReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the actor.");
            }
        }
    }
    // #endregion

    // #region "Focus handlers"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={4}>
            <DetailsPageCard
                data={actor}
                type="actor"
                isBookmarked={actor.isBookmarked}
                onBookmark={() => onBookmarkActor(session!, actor)}
                onRemoveBookmark={() => onRemoveBookmarkActor(session!, actor)}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {actor.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({actor.totalReviews ? actor.totalReviews : 0})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {actor.reviews!.length > 0 ? (
                                <ReviewsHeader
                                    data={actor}
                                    sortBy={searchParamsValues.reviewsSortBy!}
                                    ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                    sortingDataType="reviews"
                                />
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this actor!
                                </Typography>
                            )}
                            {actor.reviews.map(
                                (review: any, index: number) =>
                                    (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                        <Review
                                            key={index}
                                            review={review}
                                            handleRemoveReview={onSubmitRemoveReview}
                                            isEditMode={isEditMode}
                                            setIsEditMode={setIsEditMode}
                                            setReview={setReview}
                                            handleFocusTextEditor={handleFocusTextEditor}
                                            ref={reviewRef}
                                            setRating={setRating}
                                            handleUpvote={onUpvoteActor}
                                            handleDownvote={onDownVoteActor}
                                            type="actor"
                                            data={actor}
                                        />
                                    ),
                            )}
                            {session?.user && (!actor.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {actor.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                <ListDetail data={actor.starredMovies} type="actor" roleData="Movies" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.starredMoviesPage)}
                    pageCount={starredMoviesPageCount}
                    urlParamName="starredMoviesPage"
                />
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 6 }}>
                <ListDetail data={actor.starredSeries} type="actor" roleData="Series" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.starredSeriesPage)}
                    pageCount={starredSeriesPageCount}
                    urlParamName="starredSeriesPage"
                />
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import ActorReviewDownvotesPageContent from "./_components/ActorReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "actor", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <ActorReviewDownvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/reviews/[reviewId]/downvotes/_components/ActorReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import ActorReviewUpvotesPageContent from "./_components/ActorReviewUpvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "actor", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <ActorReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/actors/[actorId]/[actorFullname]/reviews/[reviewId]/upvotes/_components/ActorReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/actors/_components/ActorsPageContent.tsx
================================================
import { Box, Stack, Typography } from "@mui/material";
import { Actor } from "@prisma/client";
import { getActorsWithFilters } from "@/actions/actor.actions";
import Carousel from "@/components/root/carousel/Carousel";
import CardItem from "@/components/root/cardItem/CardItem";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import SortSelect from "@/components/root/sortSelect/SortSelect";

interface ActorsPageContentProps {
    searchParams:
        | {
              actorsAscOrDesc?: string;
              pageActors?: string;
              actorsSortBy?: string;
          }
        | undefined;
    session: any;
}

export default async function ActorsPageContent({ searchParams, session }: ActorsPageContentProps) {
    const ascOrDesc = searchParams?.actorsAscOrDesc ?? "";
    const page = searchParams?.pageActors ? Number(searchParams.pageActors) : 1;
    const sortBy = searchParams?.actorsSortBy ?? "";

    const queryParams = {
        ascOrDesc,
        page,
        sortBy,
    };

    const itemsPerPage = 12;
    const actorsData = await getActorsWithFilters(queryParams, Number(session?.user?.id));
    const actors = actorsData.actors;
    const actorsCarouselImages: Actor[] = actorsData.actors.slice(0, 5);
    const actorsCount = actorsData.count;
    const pageCount = Math.ceil(actorsCount / itemsPerPage);

    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, actorsCount);

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                gap: { xs: 3, sm: 4, md: 5 },
            }}
        >
            <Box component="section">
                <Carousel data={actorsCarouselImages} type="actors" />
            </Box>
            <Box
                component="section"
                sx={{
                    maxWidth: "1200px",
                    margin: "0 auto",
                    width: "100%",
                    px: { xs: 2, sm: 3, md: 4 },
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "flex-start",
                        flexDirection: { xs: "column", sm: "row" },
                        gap: { xs: 2, sm: 3 },
                        mb: { xs: 3, md: 4 },
                    }}
                >
                    <Box
                        sx={{
                            display: "flex",
                            flexDirection: { xs: "column", sm: "row" },
                            alignItems: { xs: "flex-start", sm: "baseline" },
                            gap: { xs: 1, sm: 2 },
                        }}
                    >
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 24, sm: 28, md: 32 },
                                fontWeight: 800,
                                color: "text.primary",
                                position: "relative",
                                display: "inline-block",
                                "&::after": {
                                    content: '""',
                                    position: "absolute",
                                    bottom: -8,
                                    left: 0,
                                    width: "100%",
                                    height: 3,
                                    bgcolor: "primary.main",
                                    borderRadius: 1,
                                },
                            }}
                        >
                            Actors
                        </Typography>
                        <Typography
                            variant="h5"
                            sx={{
                                fontSize: { xs: 16, sm: 18 },
                                color: "text.secondary",
                                mt: { xs: 2, sm: 0 },
                                ml: { sm: 1 },
                                position: "relative",
                                top: { sm: 2 },
                            }}
                        >
                            {startIndex} – {endIndex} of {actorsCount} actors
                        </Typography>
                    </Box>
                    <Box>
                        <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="list" dataType="actors" />
                    </Box>
                </Box>
                <Box
                    sx={{
                        width: "100%",
                        overflow: "hidden",
                        mt: { xs: 4, md: 5 },
                    }}
                >
                    <Stack
                        direction="row"
                        flexWrap="wrap"
                        sx={{
                            columnGap: { xs: 1, sm: 2, md: 3 },
                            rowGap: { xs: 3, sm: 4, md: 5 },
                            justifyContent: {
                                xs: "center",
                                md: "flex-start",
                            },
                            mx: { xs: 1, sm: 2 },
                            mb: { xs: 3, md: 4 },
                        }}
                    >
                        {actors.map((actor: Actor) => (
                            <CardItem key={actor.id} data={actor} type="actor" path="actors" />
                        ))}
                    </Stack>
                    <PaginationControl currentPage={Number(page)} pageCount={pageCount} urlParamName="pageActors" />
                </Box>
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/contact-us/page.tsx
================================================
import ContactUsContent from "./_components/ContactUsContent";
import type { Metadata } from "next";

export const metadata: Metadata = {
    title: "Contact Us | MovieLandia",
    description: "Get in touch with MovieLandia - we'd love to hear from you!",
};

export default function ContactUsPage() {
    return <ContactUsContent />;
}


================================================
File: src/app/(root)/contact-us/_components/ContactUsContent.tsx
================================================
"use client";

import React from "react";
import { Container, Typography, Box, Stack, useTheme, Paper, TextField, Button } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { motion } from "framer-motion";
import EmailIcon from "@mui/icons-material/Email";
import PhoneIcon from "@mui/icons-material/Phone";
import LocationOnIcon from "@mui/icons-material/LocationOn";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { showToast } from "@/utils/helpers/toast";
import { ContactFormData, contactSchema } from "@/schemas/auth.schema";

const ContactUsContent = () => {
    const theme = useTheme();

    const {
        control,
        handleSubmit,
        reset,
        formState: { errors },
    } = useForm<ContactFormData>({
        resolver: zodResolver(contactSchema),
        defaultValues: {
            name: "",
            email: "",
            subject: "",
            message: "",
        },
    });

    const onSubmit = async () => {
        try {
            showToast("success", "Message sent successfully! We&apos;ll get back to you soon.");
            reset();
        } catch (error) {
            showToast("error", "Failed to send message. Please try again later.");
        }
    };

    return (
        <Container maxWidth="lg" sx={{ py: 8 }}>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Paper
                    elevation={0}
                    sx={{
                        p: { xs: 3, md: 4 },
                        mb: { xs: 4, md: 6 },
                        borderRadius: 2,
                        background: `linear-gradient(135deg, ${theme.vars.palette.primary.main}22 0%, ${theme.vars.palette.primary.main}11 100%)`,
                    }}
                >
                    <Typography
                        variant="h2"
                        gutterBottom
                        sx={{
                            color: theme.vars.palette.primary.main,
                            fontWeight: 800,
                            textAlign: "center",
                            textTransform: "uppercase",
                            letterSpacing: "0.1em",
                            fontSize: { xs: "2rem", md: "3rem" },
                        }}
                    >
                        Contact Us
                    </Typography>
                    <Typography
                        sx={{
                            textAlign: "center",
                            color: theme.vars.palette.text.secondary,
                            maxWidth: "800px",
                            mx: "auto",
                            mb: 4,
                            fontSize: { xs: "0.875rem", md: "1rem" },
                        }}
                    >
                        We&apos;d love to hear from you. Send us a message and we&apos;ll respond as soon as possible.
                    </Typography>
                </Paper>

                <Stack direction={{ xs: "column", md: "row" }} spacing={{ xs: 4, md: 6 }} alignItems="stretch">
                    <Box flex={1}>
                        <Stack spacing={4} height="100%" justifyContent="center">
                            <Box
                                component={motion.div}
                                initial={{ opacity: 0, x: -20 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ duration: 0.5, delay: 0.2 }}
                            >
                                <Stack direction="row" spacing={2} alignItems="center">
                                    <EmailIcon
                                        sx={{ color: theme.vars.palette.red.main, fontSize: { xs: 24, md: 30 } }}
                                    />
                                    <Box>
                                        <Typography
                                            variant="h6"
                                            color="primary"
                                            sx={{ fontSize: { xs: "1rem", md: "1.25rem" } }}
                                        >
                                            Email
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            info@movielandia.com
                                        </Typography>
                                    </Box>
                                </Stack>
                            </Box>

                            <Box
                                component={motion.div}
                                initial={{ opacity: 0, x: -20 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ duration: 0.5, delay: 0.4 }}
                            >
                                <Stack direction="row" spacing={2} alignItems="center">
                                    <PhoneIcon
                                        sx={{ color: theme.vars.palette.red.main, fontSize: { xs: 24, md: 30 } }}
                                    />
                                    <Box>
                                        <Typography
                                            variant="h6"
                                            color="primary"
                                            sx={{ fontSize: { xs: "1rem", md: "1.25rem" } }}
                                        >
                                            Phone
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            +1 (555) 123-4567
                                        </Typography>
                                    </Box>
                                </Stack>
                            </Box>

                            <Box
                                component={motion.div}
                                initial={{ opacity: 0, x: -20 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ duration: 0.5, delay: 0.6 }}
                            >
                                <Stack direction="row" spacing={2} alignItems="center">
                                    <LocationOnIcon
                                        sx={{ color: theme.vars.palette.red.main, fontSize: { xs: 24, md: 30 } }}
                                    />
                                    <Box>
                                        <Typography
                                            variant="h6"
                                            color="primary"
                                            sx={{ fontSize: { xs: "1rem", md: "1.25rem" } }}
                                        >
                                            Address
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            123 Movie Street
                                            <br />
                                            Hollywood, CA 90028
                                        </Typography>
                                    </Box>
                                </Stack>
                            </Box>
                        </Stack>
                    </Box>

                    <Box
                        flex={2}
                        component={motion.div}
                        initial={{ opacity: 0, x: 20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ duration: 0.5, delay: 0.4 }}
                    >
                        <Paper
                            elevation={0}
                            sx={{
                                p: { xs: 3, md: 4 },
                                borderRadius: 2,
                                background: `linear-gradient(135deg, ${theme.vars.palette.primary.main}11 0%, ${theme.vars.palette.primary.main}22 100%)`,
                                height: "100%",
                            }}
                        >
                            <form onSubmit={handleSubmit(onSubmit)} style={{ height: "100%" }}>
                                <Stack spacing={3} height="100%">
                                    <Controller
                                        name="name"
                                        control={control}
                                        render={({ field }) => (
                                            <TextField
                                                {...field}
                                                label="Name"
                                                error={!!errors.name}
                                                helperText={errors.name?.message}
                                                fullWidth
                                                variant="outlined"
                                                sx={{
                                                    "& .MuiOutlinedInput-root": {
                                                        backgroundColor: "background.paper",
                                                    },
                                                }}
                                            />
                                        )}
                                    />

                                    <Controller
                                        name="email"
                                        control={control}
                                        render={({ field }) => (
                                            <TextField
                                                {...field}
                                                label="Email"
                                                error={!!errors.email}
                                                helperText={errors.email?.message}
                                                fullWidth
                                                variant="outlined"
                                                sx={{
                                                    "& .MuiOutlinedInput-root": {
                                                        backgroundColor: "background.paper",
                                                    },
                                                }}
                                            />
                                        )}
                                    />

                                    <Controller
                                        name="subject"
                                        control={control}
                                        render={({ field }) => (
                                            <TextField
                                                {...field}
                                                label="Subject"
                                                error={!!errors.subject}
                                                helperText={errors.subject?.message}
                                                fullWidth
                                                variant="outlined"
                                                sx={{
                                                    "& .MuiOutlinedInput-root": {
                                                        backgroundColor: "background.paper",
                                                    },
                                                }}
                                            />
                                        )}
                                    />

                                    <Controller
                                        name="message"
                                        control={control}
                                        render={({ field }) => (
                                            <TextField
                                                {...field}
                                                label="Message"
                                                multiline
                                                rows={4}
                                                error={!!errors.message}
                                                helperText={errors.message?.message}
                                                fullWidth
                                                variant="outlined"
                                                sx={{
                                                    "& .MuiOutlinedInput-root": {
                                                        backgroundColor: "background.paper",
                                                    },
                                                }}
                                            />
                                        )}
                                    />

                                    <Box sx={{ mt: "auto", pt: 2 }}>
                                        <Button
                                            type="submit"
                                            variant="contained"
                                            size="large"
                                            fullWidth
                                            sx={{
                                                py: 1.5,
                                                color: "white",
                                                bgcolor: theme.vars.palette.red.main,
                                                "&:hover": {
                                                    bgcolor: theme.vars.palette.red.dark,
                                                },
                                                fontSize: { xs: "0.875rem", md: "1rem" },
                                                fontWeight: 600,
                                            }}
                                        >
                                            Send Message
                                        </Button>
                                    </Box>
                                </Stack>
                            </form>
                        </Paper>
                    </Box>
                </Stack>
            </motion.div>
        </Container>
    );
};

export default ContactUsContent;


================================================
File: src/app/(root)/crew/page.tsx
================================================
import { Suspense } from "react";
import type { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import CrewAllPageContent from "./_components/CrewAllPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface ICrewProps {
    searchParams?: Promise<{ crewAscOrDesc?: string; page?: string; crewSortBy?: string }>;
}

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export const metadata: Metadata = {
    title: "Crew of movies and series",
    description: "Discover the most amazing crews.",
    openGraph: {
        type: "video.other",
        url: `${baseUrl}/crews`,
        title: "Crews",
        description: "Discover the most amazing crews in high quality.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "Crews",
        description: "Discover the crew of movies and series.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Crews(props: ICrewProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <CrewAllPageContent searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/page.tsx
================================================
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getCrewMemberById } from "@/actions/crew.actions";
import { Crew } from "@prisma/client";
import CrewPageContent from "./_components/CrewPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface ICrewProps {
    params: {
        crewId: string;
    };
    searchParams?: Promise<{
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        producedMoviesPage: string;
        producedSeriesPage: string;
    }>;
}

export async function generateMetadata(props: ICrewProps): Promise<Metadata> {
    const params = await props.params;
    const { crewId } = params;

    let crew: Crew;

    try {
        crew = await getCrewMemberById(Number(crewId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = crew;

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/crew/${crew.fullname}`;

    return {
        title: `${crew.fullname} | Crew`,
        description: `${crew.description}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${crew.fullname} | Crew`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 160,
                          height: 200,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${crew.fullname} | Crew`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function CrewPage(props: ICrewProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const { crewId } = params;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams && searchParams.reviewsAscOrDesc;
    const reviewsPage = searchParams && searchParams.reviewsPage ? Number(searchParams.reviewsPage) : 1;
    const reviewsSortBy = searchParams && searchParams.reviewsSortBy ? searchParams.reviewsSortBy : "";

    const producedMoviesPage = searchParams?.producedMoviesPage ? Number(searchParams.producedMoviesPage) : 1;
    const producedSeriesPage = searchParams?.producedSeriesPage ? Number(searchParams.producedSeriesPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        producedMoviesPage,
        producedSeriesPage,
        userId: Number(session?.user?.id),
    };

    let crew;

    try {
        crew = await getCrewMemberById(Number(crewId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const perPage = 6;
    const reviewsPageCount = Math.ceil(crew.totalReviews / 5);
    const producedMoviesPageCount = Math.ceil(crew.totalMovies / perPage);
    const producedSeriesPageCount = Math.ceil(crew.totalSeries / perPage);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <CrewPageContent
                searchParamsValues={searchParamsValues}
                crew={crew}
                reviewsPageCount={reviewsPageCount}
                producedMoviesPageCount={producedMoviesPageCount}
                producedSeriesPageCount={producedSeriesPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/_components/CrewPageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { useEffect } from "react";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import * as CONSTANTS from "@/constants/Constants";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { onBookmarkCrew, onRemoveBookmarkCrew } from "@/utils/features/crewFeaturesUtils";
import { removeDownvoteCrewReview, addDownvoteCrewReview } from "@/actions/user/userDownvotes.actions";
import { addReviewCrew, removeReviewCrew, updateReviewCrew } from "@/actions/user/userReviews.actions";
import { removeUpvoteCrewReview, addUpvoteCrewReview } from "@/actions/user/userUpvotes.actions";

interface ICrewPageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        producedMoviesPage: number;
        producedSeriesPage: number;
    };
    crew: any;
    reviewsPageCount: number;
    producedMoviesPageCount: number;
    producedSeriesPageCount: number;
}

export default function CrewPageContent({
    searchParamsValues,
    crew,
    reviewsPageCount,
    producedMoviesPageCount,
    producedSeriesPageCount,
}: ICrewPageContentProps) {
    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();

    const theme = useTheme();
    // #endregion

    // #region "Handlers functions"

    // #region "Review"
    async function onSubmitReview() {
        if (!session?.user || !crew) return;

        try {
            await addReviewCrew({
                crewId: crew.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !crew) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewCrew({
                                crewId: crew.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !crew) return;

        try {
            await updateReviewCrew({
                crewId: crew.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvote, Downvote"
    async function onUpvoteCrew(crewReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !crewReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });
            } else {
                await removeDownvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });

                await addUpvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the crew.");
            }
        }
    }

    async function onDownVoteCrew(crewReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!crew && !crewReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });
            } else {
                await removeUpvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });

                await addDownvoteCrewReview({
                    userId: Number(session?.user?.id),
                    crewId: crew.id,
                    crewReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the crew.");
            }
        }
    }
    // #endregion

    // #region "Focus handlers"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={4}>
            <DetailsPageCard
                data={crew}
                type="crew"
                isBookmarked={crew.isBookmarked}
                onBookmark={() => onBookmarkCrew(session!, crew)}
                onRemoveBookmark={() => onRemoveBookmarkCrew(session!, crew)}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {crew.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({crew.totalReviews ? crew.totalReviews : 0})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {crew.reviews!.length > 0 ? (
                                <ReviewsHeader
                                    data={crew}
                                    sortBy={searchParamsValues.reviewsSortBy!}
                                    ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                    sortingDataType="reviews"
                                />
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this crew!
                                </Typography>
                            )}
                            {crew.reviews.map(
                                (review: any, index: number) =>
                                    (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                        <Review
                                            key={index}
                                            review={review}
                                            handleRemoveReview={onSubmitRemoveReview}
                                            isEditMode={isEditMode}
                                            setIsEditMode={setIsEditMode}
                                            setReview={setReview}
                                            handleFocusTextEditor={handleFocusTextEditor}
                                            ref={reviewRef}
                                            setRating={setRating}
                                            handleUpvote={onUpvoteCrew}
                                            handleDownvote={onDownVoteCrew}
                                            type="crew"
                                            data={crew}
                                        />
                                    ),
                            )}
                            {session?.user && (!crew.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {crew.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                <ListDetail data={crew.producedMovies} type="crew" roleData="Movies" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.producedMoviesPage)}
                    pageCount={producedMoviesPageCount}
                    urlParamName="producedMoviesPage"
                />
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 6 }}>
                <ListDetail data={crew.producedSeries} type="crew" roleData="Series" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.producedSeriesPage)}
                    pageCount={producedSeriesPageCount}
                    urlParamName="producedSeriesPage"
                />
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import CrewReviewDownvotesPageContent from "./_components/CrewReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "crew", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <CrewReviewDownvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/reviews/[reviewId]/downvotes/_components/CrewReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import CrewReviewUpvotesPageContent from "./_components/CrewReviewUpvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "crew", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <CrewReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/crew/[crewId]/[crewFullname]/reviews/[reviewId]/upvotes/_components/CrewReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/crew/_components/CrewAllPageContent.tsx
================================================
import { Box, Stack, Typography } from "@mui/material";
import { Crew } from "@prisma/client";
import { getCrewMembersWithFilters } from "@/actions/crew.actions";
import Carousel from "@/components/root/carousel/Carousel";
import CardItem from "@/components/root/cardItem/CardItem";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import SortSelect from "@/components/root/sortSelect/SortSelect";

interface CrewPageContentProps {
    searchParams:
        | {
              crewAscOrDesc?: string;
              pageCrews?: string;
              crewSortBy?: string;
          }
        | undefined;
    session: any;
}

export default async function CrewAllPageContent({ searchParams, session }: CrewPageContentProps) {
    const ascOrDesc = searchParams?.crewAscOrDesc ?? "";
    const page = searchParams?.pageCrews ? Number(searchParams.pageCrews) : 1;
    const sortBy = searchParams?.crewSortBy ?? "";

    const queryParams = {
        ascOrDesc,
        page,
        sortBy,
    };

    const itemsPerPage = 12;
    const crewData = await getCrewMembersWithFilters(queryParams, Number(session?.user?.id));
    const crewMembers = crewData.crewMembers;
    const crewCarouselImages: Crew[] = crewMembers.slice(0, 5);

    const crewCount = crewData.count;
    const pageCount = Math.ceil(crewCount / itemsPerPage);

    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, crewCount);

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                gap: { xs: 3, sm: 4, md: 5 },
            }}
        >
            <Box component="section">
                <Carousel data={crewCarouselImages} type="crew" />
            </Box>
            <Box
                component="section"
                sx={{
                    maxWidth: "1200px",
                    margin: "0 auto",
                    width: "100%",
                    px: { xs: 2, sm: 3, md: 4 },
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "flex-start",
                        flexDirection: { xs: "column", sm: "row" },
                        gap: { xs: 2, sm: 3 },
                        mb: { xs: 3, md: 4 },
                    }}
                >
                    <Box
                        sx={{
                            display: "flex",
                            flexDirection: { xs: "column", sm: "row" },
                            alignItems: { xs: "flex-start", sm: "baseline" },
                            gap: { xs: 1, sm: 2 },
                        }}
                    >
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 24, sm: 28, md: 32 },
                                fontWeight: 800,
                                color: "text.primary",
                                position: "relative",
                                display: "inline-block",
                                "&::after": {
                                    content: '""',
                                    position: "absolute",
                                    bottom: -8,
                                    left: 0,
                                    width: "100%",
                                    height: 3,
                                    bgcolor: "primary.main",
                                    borderRadius: 1,
                                },
                            }}
                        >
                            Crew
                        </Typography>
                        <Typography
                            variant="h5"
                            sx={{
                                fontSize: { xs: 16, sm: 18 },
                                color: "text.secondary",
                                mt: { xs: 2, sm: 0 },
                                ml: { sm: 1 },
                                position: "relative",
                                top: { sm: 2 },
                            }}
                        >
                            {startIndex} – {endIndex} of {crewCount} crews
                        </Typography>
                    </Box>
                    <Box>
                        <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="list" dataType="crew" />
                    </Box>
                </Box>
                <Box
                    sx={{
                        width: "100%",
                        overflow: "hidden",
                        mt: { xs: 4, md: 5 },
                    }}
                >
                    <Stack
                        direction="row"
                        flexWrap="wrap"
                        sx={{
                            columnGap: { xs: 1, sm: 2, md: 3 },
                            rowGap: { xs: 3, sm: 4, md: 5 },
                            justifyContent: {
                                xs: "center",
                                md: "flex-start",
                            },
                            mx: { xs: 1, sm: 2 },
                            mb: { xs: 3, md: 4 },
                        }}
                    >
                        {crewMembers.map((crewMember: Crew) => (
                            <CardItem key={crewMember.id} data={crewMember} type="crew" path="crew" />
                        ))}
                    </Stack>
                    <PaginationControl currentPage={Number(page)} pageCount={pageCount} urlParamName="pageCrews" />
                </Box>
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/genres/page.tsx
================================================
import GenreItem from "@/components/root/genreItem/GenreItem";
import { getGenres } from "@/actions/genre.actions";
import { Box, Stack, Typography } from "@mui/material";
import { Genre } from "@prisma/client";
import type { Metadata } from "next";

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export const metadata: Metadata = {
    title: "Watch the Latest Genres | High-Quality and Always Updated",
    description:
        "Discover and watch the latest and most amazing genres in high quality. Our collection is always updated with the newest episodes and releases.",
    openGraph: {
        type: "video.tv_show",
        url: `${baseUrl}/genres`,
        title: "Watch the Latest Genres | High-Quality and Always Updated",
        description:
            "Discover and watch the latest and most amazing genres in high quality. Our collection is always updated with the newest episodes and releases.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "Watch the Latest Genres | High-Quality and Always Updated",
        description:
            "Discover and watch the latest and most amazing genres in high quality. Our collection is always updated with the newest episodes and releases.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Genres() {
    const genres = await getGenres();

    return (
        <Box
            sx={{
                display: "flex",
                flexDirection: "column",
                placeItems: "center",
                pt: 4,
                mt: 4,
                mb: 4,
                mr: 3,
                ml: 3,
            }}
            component={"section"}
        >
            <Typography
                sx={{
                    mt: 4,
                }}
                fontSize={"26px"}
            >
                Choose your favorite genre
            </Typography>
            <Stack
                direction="row"
                flexWrap="wrap"
                alignItems={"start"}
                rowGap={5}
                columnGap={5}
                sx={{
                    pl: 3,
                    mt: 3,
                    mb: 4,
                    justifyContent: {
                        xs: "center",
                        sm: "center",
                        md: "start",
                        lg: "start",
                    },
                }}
            >
                {genres.map((genre: Genre, index: number) => (
                    <GenreItem key={index} genre={genre} />
                ))}
            </Stack>
        </Box>
    );
}


================================================
File: src/app/(root)/genres/[genreId]/[genreName]/page.tsx
================================================
import React, { Suspense } from "react";
import { Metadata } from "next";
import { Genre } from "@prisma/client";
import { getGenreById } from "@/actions/genre.actions";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import GenrePageContent from "./_components/GenrePageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface IGenreProps {
    params: {
        genreId: string;
        genreName: string;
    };
    searchParams?: Promise<{
        moviesAscOrDesc?: string;
        pageMovies?: string;
        moviesSortBy?: string;
        seriesAscOrDesc?: string;
        pageSeries?: string;
        seriesSortBy?: string;
    }>;
}

export async function generateMetadata(props: IGenreProps): Promise<Metadata> {
    const params = await props.params;
    const { genreId } = params;

    let genre: Genre;
    let genreData: any;

    try {
        genreData = await getGenreById(Number(genreId), { type: "movie" });
        genre = genreData.genre;
    } catch (error) {
        return notFound();
    }

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/genres/${genre.id}/${genre.name}}`;

    return {
        title: `${genre.name} | Watch the Latest Movies and Series of the genre`,
        description: `Discover and watch the latest and most amazing movies and series of genre titled "${genre.name}" in high quality. Our collection is always updated with the newest releases.`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${genre.name} | Genre`,
            description: `Discover and watch the latest and most amazing movies and series of genre titled "${genre.name}" in high quality. Our collection is always updated with the newest releases.`,
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${genre.name} | Genre`,
            description: `Discover and watch the latest and most amazing movies and series of genre titled "${genre.name}" in high quality. Our collection is always updated with the newest releases.`,
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function GenrePage(props: IGenreProps): Promise<React.JSX.Element> {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <GenrePageContent params={props.params} searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/genres/[genreId]/[genreName]/_components/GenreList.tsx
================================================
"use client";

import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import SortSelect from "@/components/root/sortSelect/SortSelect";
import CardItem from "@/components/root/cardItem/CardItem";
import { Box, Typography, useTheme } from "@mui/material";
import { Movie, Serie } from "@prisma/client";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { motion } from "framer-motion";

interface GenreListProps {
    title: string;
    data: (Movie | Serie)[];
    count: number;
    sortBy: string;
    ascOrDesc: string;
    page: number;
    pageCount: number;
    dataType: "Movies" | "Series";
    cardType: "movie" | "serie";
}

const GenreList = ({ title, data, count, sortBy, ascOrDesc, page, pageCount, dataType, cardType }: GenreListProps) => {
    const theme = useTheme();

    const itemsPerPage = 12;
    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, count);

    if (data.length === 0) return null;

    return (
        <Box
            component={motion.section}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            sx={{
                width: "100%",
                bgcolor: "background.paper",
                borderRadius: 2,
                boxShadow: theme.vars.shadows[1],
                overflow: "hidden",
                border: "1px solid",
                borderColor: "divider",
            }}
        >
            <Box
                sx={{
                    p: { xs: 2, sm: 3 },
                    borderBottom: `1px solid ${theme.vars.palette.divider}`,
                    bgcolor: "background.paper",
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: { xs: "column", sm: "row" },
                        justifyContent: "space-between",
                        alignItems: { xs: "flex-start", sm: "center" },
                        gap: 2,
                    }}
                >
                    <Box>
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 20, sm: 24 },
                                fontWeight: 700,
                                color: "text.primary",
                                mb: 0.5,
                            }}
                        >
                            {title}
                        </Typography>
                        <Typography
                            variant="body2"
                            sx={{
                                color: "text.secondary",
                            }}
                        >
                            {startIndex} – {endIndex} of {count} {dataType.toLowerCase()}
                        </Typography>
                    </Box>
                    <Box sx={{ minWidth: 200 }}>
                        <SortSelect
                            sortBy={sortBy}
                            ascOrDesc={ascOrDesc}
                            type="list"
                            dataType={dataType.toLowerCase()}
                        />
                    </Box>
                </Box>
            </Box>
            <Box sx={{ p: { xs: 2, sm: 3 }, bgcolor: "background.paper" }}>
                <Box
                    sx={{
                        display: "flex",
                        flexWrap: "wrap",
                        columnGap: { xs: 2, sm: 3 },
                        rowGap: { xs: 3, sm: 4 },
                        justifyContent: "flex-start",
                    }}
                >
                    {data.map((item) => (
                        <Box
                            key={item.id}
                            sx={{
                                display: "flex",
                                columnGap: { xs: 1, sm: 2, md: 3 },
                                paddingLeft: 1,
                                rowGap: { xs: 3, sm: 4, md: 5 },
                            }}
                        >
                            <CardItem data={item} type={cardType} />
                        </Box>
                    ))}
                </Box>
                <Box sx={{ mt: 4, display: "flex", justifyContent: "center" }}>
                    <PaginationControl
                        currentPage={Number(page)}
                        pageCount={pageCount}
                        urlParamName={dataType === "Movies" ? "pageMovies" : "pageSeries"}
                    />
                </Box>
            </Box>
        </Box>
    );
};

export default GenreList;


================================================
File: src/app/(root)/genres/[genreId]/[genreName]/_components/GenrePageContent.tsx
================================================
import { Box, Typography } from "@mui/material";
import { Genre, Movie, Serie } from "@prisma/client";
import { getGenreById } from "@/actions/genre.actions";
import { notFound } from "next/navigation";
import GenreList from "./GenreList";
import GenreTabs from "./GenreTabs";

interface GenrePageContentProps {
    params: {
        genreId: string;
        genreName: string;
    };
    searchParams?: {
        moviesAscOrDesc?: string;
        pageMovies?: string;
        moviesSortBy?: string;
        seriesAscOrDesc?: string;
        pageSeries?: string;
        seriesSortBy?: string;
        filters?: string;
    };
    session: any;
}

interface IQueryParams {
    page: number;
    type: string;
    ascOrDesc?: string;
    sortBy?: string;
}

export default async function GenrePageContent({ params, searchParams, session }: GenrePageContentProps) {
    const genreId = params.genreId;

    // #region "Movies data"
    const pageMovies = Number(searchParams?.pageMovies) || 1;
    const moviesSortBy = searchParams?.moviesSortBy ?? "";
    const moviesAscOrDesc = searchParams?.moviesAscOrDesc ?? "";
    const queryParamsMovies: IQueryParams = { page: pageMovies, type: "movie" };

    if (moviesSortBy) {
        queryParamsMovies.sortBy = moviesSortBy;
    }

    if (moviesAscOrDesc) {
        queryParamsMovies.ascOrDesc = moviesAscOrDesc;
    }

    let moviesByGenreData = [];

    try {
        moviesByGenreData = await getGenreById(Number(genreId), queryParamsMovies, Number(session?.user?.id));
    } catch (error) {
        return notFound();
    }

    const genre: Genre = moviesByGenreData.genre;
    const moviesByGenre: Movie[] = moviesByGenreData.movies;
    const moviesByGenreCount: number = moviesByGenreData.count;
    const itemsPerPage = 12;
    const pageCountMovies = Math.ceil(moviesByGenreCount / itemsPerPage);
    // #endregion

    // #region "Series data"
    const pageSeries = Number(searchParams?.pageSeries) || 1;
    const seriesSortBy = searchParams?.seriesSortBy ?? "";
    const seriesAscOrDesc = searchParams?.seriesAscOrDesc ?? "";
    const queryParamsSeries: IQueryParams = { page: pageSeries, type: "serie" };

    if (seriesSortBy) {
        queryParamsSeries.sortBy = seriesSortBy;
    }

    if (seriesAscOrDesc) {
        queryParamsSeries.ascOrDesc = seriesAscOrDesc;
    }

    let seriesByGenreData = [];

    try {
        seriesByGenreData = await getGenreById(Number(genreId), queryParamsSeries, Number(session?.user?.id));
    } catch (error) {
        return notFound();
    }

    const seriesByGenre: Serie[] = seriesByGenreData.series;
    const seriesByGenreCount: number = seriesByGenreData.count;
    const pageCountSeries = Math.ceil(seriesByGenreCount / itemsPerPage);
    // #endregion

    const totalCount = moviesByGenreCount + seriesByGenreCount;

    const shouldShowSection = (type: string) => {
        const selectedFilters = searchParams?.filters?.split(",") || ["all"];

        if (selectedFilters.includes("all")) {
            return true;
        }

        return selectedFilters.includes(type.toLowerCase());
    };

    const getSubtitleText = () => {
        const selectedFilters = searchParams?.filters?.split(",") || ["all"];

        if (selectedFilters.includes("all")) {
            return `Found ${totalCount} titles in ${genre.name} genre`;
        }

        if (selectedFilters.includes("movies") && !selectedFilters.includes("series")) {
            return `Found ${moviesByGenreCount} movies in ${genre.name} genre`;
        }

        if (selectedFilters.includes("series") && !selectedFilters.includes("movies")) {
            return `Found ${seriesByGenreCount} series in ${genre.name} genre`;
        }

        return `Found ${totalCount} titles in ${genre.name} genre`;
    };

    return (
        <Box
            sx={{
                maxWidth: "1400px",
                margin: "0 auto",
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 3, md: 4 },
            }}
        >
            <Box
                sx={{
                    mb: { xs: 4, md: 6 },
                    mt: { xs: 4, md: 6 },
                    textAlign: "center",
                }}
            >
                <Typography
                    variant="h1"
                    sx={{
                        fontSize: { xs: 28, sm: 32, md: 40 },
                        fontWeight: 800,
                        mb: 2,
                        mt: 8,
                    }}
                >
                    All Movies of Genre {genre.name}
                </Typography>
                <Typography
                    variant="body1"
                    sx={{
                        color: "text.secondary",
                        fontSize: { xs: 16, sm: 18 },
                        maxWidth: "600px",
                        margin: "0 auto",
                    }}
                >
                    {getSubtitleText()}
                </Typography>
            </Box>

            <GenreTabs />

            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    gap: { xs: 6, md: 8 },
                }}
            >
                {shouldShowSection("movies") && (
                    <GenreList
                        title={`Movies in ${genre.name}`}
                        data={moviesByGenre}
                        count={moviesByGenreCount}
                        sortBy={moviesSortBy}
                        ascOrDesc={moviesAscOrDesc}
                        page={Number(pageMovies)}
                        pageCount={pageCountMovies}
                        dataType="Movies"
                        cardType="movie"
                    />
                )}
                {shouldShowSection("series") && (
                    <GenreList
                        title={`Series in ${genre.name}`}
                        data={seriesByGenre}
                        count={seriesByGenreCount}
                        sortBy={seriesSortBy}
                        ascOrDesc={seriesAscOrDesc}
                        page={Number(pageSeries)}
                        pageCount={pageCountSeries}
                        dataType="Series"
                        cardType="serie"
                    />
                )}
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/genres/[genreId]/[genreName]/_components/GenreTabs.tsx
================================================
"use client";

import { Box, Typography } from "@mui/material";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import LiveTvIcon from "@mui/icons-material/LiveTv";
import AllInclusiveIcon from "@mui/icons-material/AllInclusive";
import { JSX } from "react";
import { useQueryState } from "nuqs";

interface TabOption {
    label: string;
    icon: JSX.Element;
    value: string;
}

const tabOptions: TabOption[] = [
    { label: "All", icon: <AllInclusiveIcon />, value: "all" },
    { label: "Movies", icon: <LocalMoviesIcon />, value: "movies" },
    { label: "Series", icon: <LiveTvIcon />, value: "series" },
];

const GenreTabs = () => {
    const [filters, setFilters] = useQueryState("filters", {
        defaultValue: "all",
        parse: (value) => value || "all",
        history: "push",
        shallow: false,
    });

    const selectedFilters = filters?.split(",") || ["all"];

    const handleTabClick = (value: string) => {
        let newFilters: string[];

        if (value === "all") {
            newFilters = ["all"];
        } else {
            if (selectedFilters.includes("all")) {
                newFilters = [value];
            } else {
                if (selectedFilters.includes(value)) {
                    newFilters = selectedFilters.filter((f) => f !== value);

                    if (newFilters.length === 0) newFilters = ["all"];
                } else {
                    newFilters = [...selectedFilters, value];
                }
            }
        }

        setFilters(newFilters.join(","));
    };

    return (
        <Box
            sx={{
                width: "100%",
                borderBottom: 1,
                borderColor: "divider",
                position: "relative",
                mb: 4,
            }}
        >
            <Box
                sx={{
                    display: "flex",
                    flexWrap: "wrap",
                    gap: 1,
                    p: { xs: 1, sm: 1.5 },
                    pb: { xs: 2, sm: 2.5 },
                    mx: -1,
                    justifyContent: { xs: "center", sm: "flex-start" },
                }}
            >
                {tabOptions.map((tab) => (
                    <Box
                        key={tab.value}
                        onClick={() => handleTabClick(tab.value)}
                        sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.75,
                            px: { xs: 1.25, sm: 1.5 },
                            py: { xs: 0.75, sm: 1 },
                            borderRadius: 1,
                            cursor: "pointer",
                            transition: "all 0.2s",
                            bgcolor: selectedFilters.includes(tab.value) ? "primary.main" : "transparent",
                            color: selectedFilters.includes(tab.value) ? "primary.contrastText" : "text.primary",
                            "&:hover": {
                                bgcolor: selectedFilters.includes(tab.value) ? "primary.light" : "action.hover",
                            },
                            "& .MuiSvgIcon-root": {
                                fontSize: { xs: "1.1rem", sm: "1.25rem" },
                            },
                            boxShadow: selectedFilters.includes(tab.value) ? 1 : "none",
                            transform: selectedFilters.includes(tab.value) ? "scale(1.02)" : "scale(1)",
                            "&:active": {
                                transform: "scale(0.98)",
                            },
                        }}
                    >
                        {tab.icon}
                        <Typography
                            sx={{
                                fontSize: { xs: "0.8125rem", sm: "0.875rem" },
                                fontWeight: selectedFilters.includes(tab.value) ? 600 : 400,
                                lineHeight: 1,
                            }}
                        >
                            {tab.label}
                        </Typography>
                    </Box>
                ))}
            </Box>
        </Box>
    );
};

export default GenreTabs;


================================================
File: src/app/(root)/messages/page.tsx
================================================
import { Suspense } from "react";
import MessagesPageContent from "./_components/MessagesPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import {
    getUserInbox,
    getSentMessages,
    searchUsers,
    getUserById,
    getMessageById,
} from "@/actions/user/userMessages.actions";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";

interface IMessagesPageProps {
    searchParams?: {
        section?: string;
        page?: string;
        search?: string;
        selectedUser?: string;
        editMessageId?: string;
    };
}

export default async function MessagesPage(props: IMessagesPageProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const section = searchParams?.section || "inbox";
    const page = Number(searchParams?.page) || 1;
    const searchQuery = searchParams?.search || "";
    const selectedUserId = searchParams?.selectedUser;
    const editMessageId = searchParams?.editMessageId;
    const searchParamsKey = JSON.stringify(searchParams);

    let messages: any = {
        items: [],
        total: 0,
    };

    if (section === "inbox") {
        messages = await getUserInbox(page, Number(session?.user.id));
    } else if (section === "sent") {
        messages = await getSentMessages(page, Number(session?.user.id));
    } else {
        messages = await getUserInbox(page, Number(session?.user.id));
    }

    const searchResults = searchQuery ? await searchUsers(searchQuery, Number(session?.user.id)) : [];
    const selectedUser = selectedUserId ? await getUserById(Number(selectedUserId)) : null;
    const messageToEdit = editMessageId ? await getMessageById(Number(editMessageId)) : null;
    const messagesPageCount = Math.ceil(messages.total / 10);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <MessagesPageContent
                initialMessages={messages}
                searchResults={searchResults}
                currentSection={section as "inbox" | "sent"}
                currentPage={page}
                userLoggedIn={session?.user}
                initialSelectedUser={selectedUser}
                messagesPageCount={messagesPageCount}
                initialMessageToEdit={messageToEdit}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/messages/[messageId]/page.tsx
================================================
import { getMessageById } from "@/actions/user/userMessages.actions";
import { notFound } from "next/navigation";
import MessagePageContent from "./_components/MessagePageContent";

interface MessageDetailsPageProps {
    params: {
        messageId: string;
    };
}

async function MessagePage(props: MessageDetailsPageProps) {
    const params = await props.params;
    const messageId = Number(params.messageId);
    let message;

    try {
        message = await getMessageById(messageId);
    } catch (error) {
        return notFound();
    }

    return <MessagePageContent message={message} />;
}

export default MessagePage;


================================================
File: src/app/(root)/messages/[messageId]/_components/MessagePageContent.tsx
================================================
"use client";

import { Box, Button, Paper, Typography, Avatar, Stack, Divider } from "@mui/material";
import { formatDistanceToNow } from "date-fns";
import { useRouter } from "next/navigation";
import PersonIcon from "@mui/icons-material/Person";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import Link from "next/link";

export default function MessagePageContent({ message }: { message: any }) {
    const router = useRouter();

    const handleBack = () => {
        router.back();
    };

    return (
        <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", p: 3 }}>
            <Paper
                sx={{
                    width: "100%",
                    maxWidth: 700,
                    p: 3,
                    mt: 10,
                    mb: 4,
                    display: "flex",
                    flexDirection: "column",
                    gap: 2,
                }}
            >
                <Typography variant="h5" component="h2" gutterBottom sx={{ fontWeight: 500, color: "primary.main" }}>
                    Message Details
                </Typography>
                <Divider />
                <Stack direction="row" spacing={2} alignItems="center">
                    <Avatar
                        alt={message.sender.userName}
                        src={message.sender.avatar?.photoSrc || undefined}
                        sx={{ width: 40, height: 40 }}
                    >
                        {!message.sender.avatar?.photoSrc && <PersonIcon />}
                    </Avatar>
                    <Typography variant="subtitle1" sx={{ fontWeight: 500 }}>
                        From:{" "}
                        <Link
                            href={`/users/${message.sender.id}/${message.sender.userName}`}
                            style={{
                                fontWeight: 400,
                                color: "text.secondary",
                                textDecoration: "none",
                            }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            {message.sender.userName}
                        </Link>
                    </Typography>
                </Stack>
                <Stack direction="row" spacing={2} alignItems="center">
                    <Avatar
                        alt={message.receiver.userName}
                        src={message.receiver.avatar?.photoSrc || undefined}
                        sx={{ width: 40, height: 40 }}
                    >
                        {!message.receiver.avatar?.photoSrc && <PersonIcon />}
                    </Avatar>
                    <Typography variant="subtitle1" sx={{ fontWeight: 500 }}>
                        To:{" "}
                        <Link
                            href={`/users/${message.receiver.id}/${message.receiver.userName}`}
                            style={{
                                fontWeight: 400,
                                color: "text.secondary",
                                textDecoration: "none",
                                "&:hover": {
                                    textDecoration: "underline",
                                },
                            }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            {message.receiver.userName}
                        </Link>
                    </Typography>
                </Stack>
                <Box
                    sx={{
                        mt: 2,
                        p: 2,
                        bgcolor: "background.paper",
                        borderRadius: 1,
                        boxShadow: 1,
                        wordWrap: "break-word",
                        overflowWrap: "break-word",
                        border: "1px solid rgba(0, 0, 0, 0.12)",
                    }}
                    dangerouslySetInnerHTML={{ __html: message.text }}
                />
                <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mt: 1 }}>
                    {message.editedAt && (
                        <Typography variant="caption" color="text.secondary" sx={{ fontStyle: "italic" }}>
                            Edited {formatDistanceToNow(new Date(message.editedAt), { addSuffix: true })}
                        </Typography>
                    )}
                    <Typography variant="caption" color="text.secondary">
                        Sent {formatDistanceToNow(new Date(message.createdAt), { addSuffix: true })}
                    </Typography>
                </Box>
                <Box sx={{ display: "flex", justifyContent: "flex-end", mt: 2 }}>
                    <Button
                        onClick={handleBack}
                        variant="outlined"
                        startIcon={<ArrowBackIcon />}
                        color="primary"
                        sx={{
                            textTransform: "capitalize",
                        }}
                    >
                        Back to Messages
                    </Button>
                </Box>
            </Paper>
        </Box>
    );
}


================================================
File: src/app/(root)/messages/_components/MessageCompose.tsx
================================================
"use client";

import { useState, useEffect, useTransition } from "react";
import {
    Box,
    Typography,
    TextField,
    Button,
    Paper,
    List,
    ListItemButton,
    ListItemText,
    InputAdornment,
    Chip,
    CircularProgress,
} from "@mui/material";
import { useRouter } from "next/navigation";
import TextEditor from "@/components/root/textEditor/TextEditor";
import { editMessage, sendMessage } from "@/actions/user/userMessages.actions";
import { showToast } from "@/utils/helpers/toast";
import SaveIcon from "@mui/icons-material/Save";
import CancelIcon from "@mui/icons-material/Cancel";
import { useTheme } from "@mui/material/styles";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";

interface User {
    id: number;
    userName: string;
    email: string;
    avatar?: {
        photoSrc: string;
    };
}

interface MessageComposeProps {
    searchResults: User[];
    userLoggedIn: any;
    initialSelectedUser?: User | null;
    initialMessageToEdit?: any | null;
}

export default function MessageCompose({
    searchResults,
    userLoggedIn,
    initialSelectedUser,
    initialMessageToEdit,
}: MessageComposeProps) {
    const theme = useTheme();
    const router = useRouter();

    const [search, setSearch] = useQueryState("search", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [selectedUserId, setSelectedUserId] = useQueryState("selectedUser", {
        defaultValue: null,
        parse: (value) => value || null,
        shallow: false,
    });

    const [editMessageId, setEditMessageId] = useQueryState("editMessageId", {
        defaultValue: null,
        parse: (value) => value || null,
        shallow: false,
    });

    const [section, setSection] = useQueryState("section", {
        defaultValue: "",
        parse: (value) => value || "",
        history: "push",
        shallow: false,
    });

    const [messageText, setMessageText] = useState("");
    const [selectedUser, setSelectedUser] = useState<User | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    const [initialText, setInitialText] = useState("");
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (initialSelectedUser) {
            setSelectedUser(initialSelectedUser);
        } else if (selectedUser) {
            const user = searchResults.find((user) => user.id === Number(selectedUserId));

            if (user) {
                setSelectedUser(user);
            }
        } else {
            setSelectedUser(null);
        }
    }, [selectedUserId, searchResults, initialSelectedUser]);

    useEffect(() => {
        if (initialMessageToEdit) {
            setMessageText(initialMessageToEdit.text);
            setIsEditing(true);

            if (selectedUserId) {
                setSelectedUser(initialMessageToEdit.receiver);
            }

            setInitialText(initialMessageToEdit.text);
        } else {
            setMessageText("");
            setIsEditing(false);
            setInitialText("");
        }
    }, [initialMessageToEdit]);

    function handleSearchChange(event: any) {
        const value = event.target.value;

        if (value) {
            setSearch(value);
            setSelectedUserId(null);
        } else {
            setSearch(null);
        }
    }

    const handleSelectUser = (user: User) => {
        setSearch(null);
        setSelectedUserId(user.id.toString());
    };

    const handleClearSelection = () => {
        setSearch(null);
        setSelectedUserId(null);
        setSelectedUser(null);
    };

    const handleSendMessage = async () => {
        if ((!selectedUser && !isEditing) || !messageText.trim() || isPending) return;

        startTransition(async () => {
            try {
                if (isEditing && initialMessageToEdit) {
                    await editMessage(initialMessageToEdit.id, messageText);
                    showToast("success", "Message edited successfully!");
                } else if (selectedUser) {
                    await sendMessage(selectedUser.id, messageText, Number(userLoggedIn.id));
                    showToast("success", "Message sent successfully!");
                }

                setSection("sent");
                setEditMessageId(null);
                setSelectedUserId(null);
            } catch (error) {
                console.error("Failed to send/edit message:", error);
                router.refresh();
            }
        });
    };

    const handleCancelEdit = () => {
        setMessageText(initialText);
    };

    const handleGoBack = () => {
        router.back();
    };

    return (
        <Box sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
            <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", mb: 2 }}>
                <Typography variant="h6">{isEditing ? "Edit Message" : "New Message"}</Typography>
                <Button onClick={handleGoBack} startIcon={<ArrowBackIcon />} sx={{ textTransform: "capitalize" }}>
                    Back
                </Button>
            </Box>
            {selectedUser ? (
                <TextField
                    label="To"
                    value=""
                    disabled
                    fullWidth
                    slotProps={{
                        input: {
                            startAdornment: (
                                <InputAdornment position="start">
                                    <Chip
                                        label={selectedUser.userName}
                                        onDelete={handleClearSelection}
                                        size="small"
                                        sx={{ mr: 1 }}
                                    />
                                </InputAdornment>
                            ),
                        },
                    }}
                />
            ) : (
                <TextField
                    label="To"
                    value={search}
                    onChange={handleSearchChange}
                    placeholder="Search users..."
                    fullWidth
                />
            )}
            {!selectedUser && search && searchResults.length > 0 && (
                <Paper sx={{ mt: 1, maxHeight: 200, overflow: "auto" }}>
                    <List>
                        {searchResults.map((user) => (
                            <ListItemButton key={user.id} onClick={() => handleSelectUser(user)}>
                                <ListItemText primary={user.userName} secondary={user.email} />
                            </ListItemButton>
                        ))}
                    </List>
                </Paper>
            )}
            <TextEditor onChange={(content: any) => setMessageText(content)} value={messageText} type="message" />
            <Box sx={{ display: "flex", gap: 2 }}>
                <Button
                    onClick={handleSendMessage}
                    sx={{
                        textTransform: "capitalize",
                        fontSize: 18,
                        fontWeight: 500,
                        bgcolor: theme.palette.success.main,
                        color: theme.palette.success.contrastText,
                        "&:disabled": {
                            bgcolor: theme.palette.grey[400],
                            color: theme.palette.grey[100],
                        },
                        padding: "5px 15px",
                        transition: "background-color 0.3s ease",
                        "&:hover": {
                            bgcolor: theme.palette.success.dark,
                        },
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                    }}
                    disabled={
                        (!selectedUser && !isEditing) ||
                        !messageText.trim() ||
                        isPending ||
                        (isEditing && messageText === initialText)
                    }
                    startIcon={!isPending ? <SaveIcon /> : null}
                >
                    {isPending ? <CircularProgress size={24} sx={{ mr: 1 }} /> : isEditing ? "Save" : "Send Message"}
                </Button>
                {isEditing && (
                    <Button
                        onClick={handleCancelEdit}
                        sx={{
                            textTransform: "capitalize",
                            fontSize: 18,
                            fontWeight: 500,
                            color: theme.palette.error.contrastText,
                            bgcolor: theme.palette.error.main,
                            "&:disabled": {
                                bgcolor: theme.palette.grey[100],
                                color: theme.palette.grey[500],
                            },
                            padding: "5px 15px",
                            transition: "background-color 0.3s ease",
                            "&:hover": {
                                bgcolor: theme.palette.error.dark,
                            },
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                        }}
                        startIcon={!isPending ? <CancelIcon /> : null}
                        disabled={isPending || (isEditing && messageText === initialText)}
                    >
                        Cancel
                    </Button>
                )}
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/messages/_components/MessagedSidebar.tsx
================================================
"use client";

import React from "react";
import { Box, List, ListItemButton, ListItemIcon, ListItemText, useTheme } from "@mui/material";
import InboxIcon from "@mui/icons-material/Inbox";
import SendIcon from "@mui/icons-material/Send";
import EditIcon from "@mui/icons-material/Edit";
import { useQueryState } from "nuqs";

interface MessagedSidebarProps {
    navigateToSection: (section: string) => void;
}

const MessagedSidebar: React.FC<MessagedSidebarProps> = ({ navigateToSection }) => {
    const [section, setSection] = useQueryState("section", {
        defaultValue: "inbox",
        parse: (value) => value || "inbox",
        history: "push",
        shallow: false,
    });

    const theme = useTheme();

    return (
        <Box sx={{ width: 250, display: "flex", flexDirection: "column" }}>
            <List sx={{ flexGrow: 1 }}>
                <ListItemButton
                    onClick={() => navigateToSection("inbox")}
                    sx={{
                        backgroundColor: section === "inbox" ? theme.palette.secondary.light : "transparent",
                        "&:hover": {
                            backgroundColor: theme.palette.secondary.light,
                        },
                    }}
                >
                    <ListItemIcon>
                        <InboxIcon />
                    </ListItemIcon>
                    <ListItemText primary="Inbox" />
                </ListItemButton>
                <ListItemButton
                    onClick={() => navigateToSection("sent")}
                    sx={{
                        backgroundColor: section === "sent" ? theme.palette.secondary.light : "transparent",
                        "&:hover": {
                            backgroundColor: theme.palette.secondary.light,
                        },
                    }}
                >
                    <ListItemIcon>
                        <SendIcon />
                    </ListItemIcon>
                    <ListItemText primary="Sent Messages" />
                </ListItemButton>
                <ListItemButton
                    onClick={() => navigateToSection("compose")}
                    sx={{
                        backgroundColor: section === "compose" ? theme.palette.secondary.light : "transparent",
                        "&:hover": {
                            backgroundColor: theme.palette.secondary.light,
                        },
                    }}
                >
                    <ListItemIcon>
                        <EditIcon />
                    </ListItemIcon>
                    <ListItemText primary="Compose New Message" />
                </ListItemButton>
            </List>
        </Box>
    );
};

export default MessagedSidebar;


================================================
File: src/app/(root)/messages/_components/MessagesList.tsx
================================================
"use client";

import { useTransition } from "react";
import {
    List,
    ListItemAvatar,
    Avatar,
    Typography,
    Box,
    Divider,
    IconButton,
    CircularProgress,
    ListItemButton,
} from "@mui/material";
import DeleteIcon from "@mui/icons-material/Delete";
import EditIcon from "@mui/icons-material/Edit";
import { formatDistanceToNow } from "date-fns";
import { useRouter } from "next/navigation";
import { Message } from "./MessagesPageContent";
import { deleteMessage, markMessageAsRead } from "@/actions/user/userMessages.actions";
import { useModal } from "@/providers/ModalProvider";
import { WarningOutlined, CheckOutlined, Circle, Email, MarkEmailRead } from "@mui/icons-material";
import * as CONSTANTS from "@/constants/Constants";
import { useSession } from "next-auth/react";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { showToast } from "@/utils/helpers/toast";
import Link from "next/link";
import { useQueryState } from "nuqs";

interface MessagesListProps {
    messages: any;
    currentSection: string;
    currentPage: number;
    isLoading: boolean;
    messagesPageCount: number;
    initialMessageToEdit?: Message | null;
}

const MessagesList: React.FC<MessagesListProps> = ({ messages, currentSection, currentPage, messagesPageCount }) => {
    const router = useRouter();
    const [isPending, startTransition] = useTransition();
    const { openModal } = useModal();
    const { data: session } = useSession();

    const [section, setSection] = useQueryState("section", {
        defaultValue: "inbox",
        parse: (value) => value || "inbox",
        history: "push",
        shallow: false,
    });

    const [editMessageId, setEditMessageId] = useQueryState("editMessageId", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [selectedUserId, setSelectedUserId] = useQueryState("selectedUser", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const handleDeleteMessage = async (messageId: number) => {
        startTransition(async () => {
            await deleteMessage(messageId);
        });

        showToast("success", "Message deleted successfully!");
        router.refresh();
    };

    const handleOpenMessage = async (message: Message) => {
        if (section === "inbox" && !message.read) {
            await markMessageAsRead(message.id);
        }

        router.push(`/messages/${message.id}`, { scroll: false });
    };

    const handleOpenDeleteDialog = (messageId: number) => {
        openModal({
            onClose: () => {},
            title: `Delete selected message`,
            subTitle: "Do you want to delete selected message?",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => {},
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        await handleDeleteMessage(messageId);
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
        });
    };

    if (isPending) {
        return (
            <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", height: 200 }}>
                <CircularProgress />
            </Box>
        );
    }

    const inboxMessages = messages.items.filter(
        (message: any) => currentSection === "inbox" && message.receiverId === Number(session?.user.id),
    );

    if (currentSection === "inbox" && (!inboxMessages || inboxMessages.length === 0)) {
        return (
            <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", height: 200 }}>
                <Typography variant="body1">No messages received.</Typography>
            </Box>
        );
    }

    if (!messages.items || messages.items.length === 0) {
        return (
            <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", height: 200 }}>
                <Typography variant="body1">No messages found.</Typography>
            </Box>
        );
    }

    return (
        <>
            <List>
                {messages.items.map((message: any) => (
                    <Box key={message.id} onClick={() => handleOpenMessage(message)}>
                        <ListItemButton
                            sx={{
                                "&:hover": {
                                    backgroundColor: "rgba(0, 0, 0, 0.04)",
                                },
                                padding: 2,
                                backgroundColor: message.read ? "rgba(0, 0, 0, 0.02)" : "transparent",
                            }}
                        >
                            <ListItemAvatar>
                                <Avatar
                                    src={
                                        currentSection === "inbox"
                                            ? message.sender?.avatar?.photoSrc
                                            : message.receiver?.avatar?.photoSrc
                                    }
                                >
                                    {currentSection === "inbox"
                                        ? message.sender?.userName.charAt(0).toUpperCase()
                                        : message.receiver?.userName.charAt(0).toUpperCase()}
                                </Avatar>
                            </ListItemAvatar>
                            <Box sx={{ display: "flex", flexDirection: "column", flex: 1 }}>
                                <Link
                                    href={`/users/${
                                        currentSection === "inbox" ? message.sender.id : message.receiver.id
                                    }/${
                                        currentSection === "inbox" ? message.sender.userName : message.receiver.userName
                                    }`}
                                    style={{
                                        fontWeight: message.read === false ? "bold" : "normal",
                                        color: "inherit",
                                        textDecoration: "none",
                                    }}
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    {currentSection === "inbox" ? message.sender.userName : message.receiver.userName}
                                </Link>
                                <Box
                                    sx={{
                                        display: "flex",
                                        justifyContent: "space-between",
                                        alignItems: "center",
                                    }}
                                >
                                    <Box
                                        sx={{
                                            overflow: "hidden",
                                            textOverflow: "ellipsis",
                                            whiteSpace: "nowrap",
                                            maxWidth: "200px",
                                        }}
                                        dangerouslySetInnerHTML={{
                                            __html: message.text.replace(/<[^>]*>/g, "").slice(0, 50),
                                        }}
                                    />
                                    <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                                        {message.editedAt && (
                                            <Typography
                                                variant="caption"
                                                color="text.secondary"
                                                sx={{ fontStyle: "italic" }}
                                            >
                                                (edited{" "}
                                                {formatDistanceToNow(new Date(message.editedAt), {
                                                    addSuffix: true,
                                                })}
                                                )
                                            </Typography>
                                        )}
                                        <Typography variant="caption" color="text.secondary">
                                            created{" "}
                                            {formatDistanceToNow(new Date(message.createdAt), { addSuffix: true })}
                                        </Typography>
                                        {currentSection === "inbox" && (
                                            <>
                                                {message.read ? (
                                                    <MarkEmailRead
                                                        sx={{
                                                            fontSize: "0.7rem",
                                                            color: "grey",
                                                            marginLeft: "0.2rem",
                                                        }}
                                                    />
                                                ) : (
                                                    <Email
                                                        sx={{
                                                            fontSize: "0.7rem",
                                                            color: "#30969f",
                                                            marginLeft: "0.2rem",
                                                        }}
                                                    />
                                                )}
                                                <Typography
                                                    variant="caption"
                                                    color="text.secondary"
                                                    sx={{ marginLeft: "0.2rem" }}
                                                >
                                                    {message.read ? "Read" : "Unread"}
                                                </Typography>
                                            </>
                                        )}
                                    </Box>
                                </Box>
                            </Box>
                            <Box sx={{ display: "flex", alignItems: "center" }}>
                                {currentSection !== "inbox" && (
                                    <>
                                        <IconButton
                                            edge="end"
                                            aria-label="edit"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                setEditMessageId(String(message.id));
                                                setSelectedUserId(message.receiverId);
                                                setSection("compose");
                                            }}
                                            sx={{ mr: 1 }}
                                        >
                                            <EditIcon color="success" />
                                        </IconButton>
                                        <IconButton
                                            edge="end"
                                            aria-label="delete"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                handleOpenDeleteDialog(message.id);
                                            }}
                                        >
                                            <DeleteIcon color="error" />
                                        </IconButton>
                                    </>
                                )}
                            </Box>
                        </ListItemButton>
                        <Divider />
                    </Box>
                ))}
            </List>
            <Box sx={{ mt: 2 }}>
                <PaginationControl pageCount={messagesPageCount} currentPage={currentPage} urlParamName="page" />
            </Box>
        </>
    );
};

export default MessagesList;


================================================
File: src/app/(root)/messages/_components/MessagesPageContent.tsx
================================================
"use client";

import { useState, useTransition } from "react";
import { Box, Container, Drawer, Paper, Typography, useTheme, useMediaQuery, IconButton } from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import { useRouter } from "next/navigation";
import MessagedSidebar from "./MessagedSidebar";
import MessagesList from "./MessagesList";
import MessageCompose from "./MessageCompose";
import { useQueryState } from "nuqs";

// #region "Interfaces"
export interface Message {
    id: number;
    text: string;
    senderId: number;
    receiverId: number;
    createdAt: Date;
    read: boolean;
    editedAt?: Date | null;
    sender: {
        userName: string;
        avatar?: {
            photoSrc: string;
        };
    };
    receiver: {
        userName: string;
        avatar?: {
            photoSrc: string;
        };
    };
}

interface MessagesData {
    items: any[];
    total: number;
}

interface MessagesPageContentProps {
    initialMessages: MessagesData;
    searchResults: any[];
    currentSection: "inbox" | "sent";
    currentPage: number;
    userLoggedIn: any;
    initialSelectedUser: any;
    messagesPageCount: number;
    initialMessageToEdit?: any | null;
}
// #endregion

export default function MessagesPageContent({
    initialMessages,
    searchResults,
    currentSection,
    currentPage,
    initialSelectedUser,
    userLoggedIn,
    messagesPageCount,
    initialMessageToEdit,
}: MessagesPageContentProps) {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down("md"));

    const [mobileOpen, setMobileOpen] = useState(false);
    const [isPending, startTransition] = useTransition();

    const router = useRouter();

    const [search, setSearch] = useQueryState("search", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [section, setSection] = useQueryState("section", {
        defaultValue: "inbox",
        parse: (value) => value || "inbox",
        history: "push",
        shallow: false,
    });

    const [editMessageId, setEditMessageId] = useQueryState("editMessageId", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    const navigateToSection = (section: string) => {
        setSection(section);
        setEditMessageId(null);
        setSearch(null);
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 14, mb: 10 }}>
            <Box sx={{ display: "flex" }}>
                {isMobile && (
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2 }}
                    >
                        <MenuIcon />
                    </IconButton>
                )}
                <Typography variant="h4" component="h1" gutterBottom>
                    Messages
                </Typography>
            </Box>
            <Box sx={{ display: "flex", mt: 2 }}>
                {isMobile ? (
                    <Drawer
                        variant="temporary"
                        anchor="left"
                        open={mobileOpen}
                        onClose={handleDrawerToggle}
                        ModalProps={{ keepMounted: true }}
                    >
                        <MessagedSidebar navigateToSection={navigateToSection} />
                    </Drawer>
                ) : (
                    <Paper sx={{ width: 250, mr: 2 }}>
                        <MessagedSidebar navigateToSection={navigateToSection} />
                    </Paper>
                )}
                <Paper sx={{ flexGrow: 1, p: 2 }}>
                    {section === "compose" ? (
                        <MessageCompose
                            searchResults={searchResults}
                            userLoggedIn={userLoggedIn}
                            initialSelectedUser={initialSelectedUser}
                            initialMessageToEdit={initialMessageToEdit}
                        />
                    ) : (
                        <MessagesList
                            messages={initialMessages}
                            currentSection={currentSection}
                            currentPage={currentPage}
                            isLoading={isPending}
                            messagesPageCount={messagesPageCount}
                            initialMessageToEdit={initialMessageToEdit}
                        />
                    )}
                </Paper>
            </Box>
        </Container>
    );
}


================================================
File: src/app/(root)/movies/page.tsx
================================================
import { Suspense } from "react";
import type { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import MoviesPageContent from "./_components/MoviesPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface IMoviesProps {
    searchParams?: Promise<{ moviesAscOrDesc?: string; page?: string; moviesSortBy?: string }>;
}

export const metadata: Metadata = {
    title: "Movies | MovieLandia",
    description: "Explore our vast collection of movies on MovieLandia",
    keywords: ["movies", "watch movies", "movie streaming", "online movies", "MovieLandia movies", "latest movies"],
    openGraph: {
        title: "Movies | MovieLandia",
        description: "Explore our vast collection of movies on MovieLandia",
        type: "website",
        locale: "en_US",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Movies(props: IMoviesProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <MoviesPageContent searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/page.tsx
================================================
import { getLatestMovies, getMovieById, getRelatedMovies } from "@/actions/movie.actions";
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { Movie } from "@prisma/client";
import MoviePageContent from "./_components/MoviePageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IMoviePageProps {
    params: {
        movieId: string;
    };
    searchParams?: Promise<{
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        crewPage: string;
        castPage: string;
    }>;
}

export async function generateMetadata(props: IMoviePageProps): Promise<Metadata> {
    const params = await props.params;
    const { movieId } = params;

    let movie: Movie | null = null;

    try {
        movie = await getMovieById(Number(movieId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = movie!;

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/movies/${movie?.title}`;

    return {
        title: `${movie?.title} | Movie`,
        description: `${movie?.description}`,
        openGraph: {
            type: "video.other",
            url: pageUrl,
            title: `${movie?.title} | Movie`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 160,
                          height: 200,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${movie?.title} | Movie`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function MoviePage(props: IMoviePageProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const movieId = params.movieId;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams && searchParams.reviewsAscOrDesc;
    const reviewsSortBy = searchParams && searchParams.reviewsSortBy ? searchParams.reviewsSortBy : "";
    const reviewsPage = searchParams?.reviewsPage ? Number(searchParams.reviewsPage) : 1;

    const castPage = searchParams?.castPage ? Number(searchParams.castPage) : 1;
    const crewPage = searchParams?.crewPage ? Number(searchParams.crewPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        castPage,
        crewPage,
        userId: Number(session?.user?.id),
    };

    let movie = null;

    try {
        movie = await getMovieById(Number(movieId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const relatedMovies = await getRelatedMovies(Number(movieId), Number(session?.user?.id));

    const reviewsPageCount = Math.ceil(movie.totalReviews / 5);
    const castPageCount = Math.ceil(movie.totalCast / 5);
    const crewPageCount = Math.ceil(movie.totalCrew / 5);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <MoviePageContent
                searchParamsValues={{
                    reviewsAscOrDesc,
                    reviewsPage: Number(reviewsPage),
                    reviewsSortBy,
                    castPage: Number(castPage) || 1,
                    crewPage: Number(crewPage) || 1,
                }}
                movie={movie}
                relatedMovies={relatedMovies}
                reviewsPageCount={reviewsPageCount}
                castPageCount={castPageCount}
                crewPageCount={crewPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/_components/MoviePageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { useEffect } from "react";
import * as CONSTANTS from "@/constants/Constants";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { Movie } from "@prisma/client";
import { onBookmarkMovie, onRemoveBookmarkMovie } from "@/utils/features/movieFeaturesUtils";
import { removeDownvoteMovieReview, addDownvoteMovieReview } from "@/actions/user/userDownvotes.actions";
import { addReviewMovie, removeReviewMovie, updateReviewMovie } from "@/actions/user/userReviews.actions";
import { removeUpvoteMovieReview, addUpvoteMovieReview } from "@/actions/user/userUpvotes.actions";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";

interface IMoviePageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        castPage: number;
        crewPage: number;
    };
    movie: any;
    relatedMovies: Movie[] | null;
    reviewsPageCount: number;
    castPageCount: number;
    crewPageCount: number;
}

export default function MoviePageContent({
    searchParamsValues,
    movie,
    relatedMovies,
    reviewsPageCount,
    castPageCount,
    crewPageCount,
}: IMoviePageContentProps) {
    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();

    const theme = useTheme();
    // #endregion

    // #region "Handlers functions"

    // #region "Review"
    async function onSubmitReview() {
        if (!session?.user || !movie) return;

        try {
            await addReviewMovie({
                movieId: movie.id,
                userId: Number(session.user.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !movie) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewMovie({
                                movieId: movie.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !movie) return;

        try {
            await updateReviewMovie({
                movieId: movie.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvote, Downvote"
    async function onUpvoteMovie(movieReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !movieReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteMovieReview({ userId: Number(session?.user?.id), movieId: movie.id, movieReviewId });
            } else {
                await removeDownvoteMovieReview({
                    userId: Number(session?.user?.id),
                    movieId: movie.id,
                    movieReviewId,
                });

                await addUpvoteMovieReview({ userId: Number(session?.user?.id), movieId: movie.id, movieReviewId });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the movie.");
            }
        }
    }

    async function onDownVoteMovie(movieReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!movie && !movieReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteMovieReview({
                    userId: Number(session?.user?.id),
                    movieId: movie.id,
                    movieReviewId,
                });
            } else {
                await removeUpvoteMovieReview({ userId: Number(session?.user?.id), movieId: movie.id, movieReviewId });
                await addDownvoteMovieReview({ userId: Number(session?.user?.id), movieId: movie.id, movieReviewId });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the movie.");
            }
        }
    }
    // #endregion

    // #region "Focus handlers"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={4}>
            <DetailsPageCard
                data={movie}
                type="movie"
                isBookmarked={movie.isBookmarked}
                onBookmark={() => onBookmarkMovie(session!, movie)}
                onRemoveBookmark={() => onRemoveBookmarkMovie(session!, movie)}
                cast={movie.cast}
                crew={movie.crew}
                currentCastPage={Number(searchParamsValues.castPage)!}
                castPageCount={castPageCount}
                currentCrewPage={Number(searchParamsValues.crewPage)!}
                crewPageCount={crewPageCount}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {movie.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({movie.totalReviews ? movie.totalReviews : 0})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {movie.reviews!.length > 0 ? (
                                <ReviewsHeader
                                    data={movie}
                                    sortingDataType="reviews"
                                    sortBy={searchParamsValues.reviewsSortBy!}
                                    ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                />
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this movie!
                                </Typography>
                            )}
                            {movie.reviews!.map(
                                (review: any, index: number) =>
                                    (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                        <Review
                                            key={index}
                                            review={review}
                                            handleRemoveReview={onSubmitRemoveReview}
                                            isEditMode={isEditMode}
                                            setIsEditMode={setIsEditMode}
                                            setReview={setReview}
                                            handleFocusTextEditor={handleFocusTextEditor}
                                            ref={reviewRef}
                                            setRating={setRating}
                                            handleUpvote={onUpvoteMovie}
                                            handleDownvote={onDownVoteMovie}
                                            type="movie"
                                            data={movie}
                                        />
                                    ),
                            )}
                            {session?.user && (!movie.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {movie.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)!}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            {relatedMovies && relatedMovies.length !== 0 && (
                <Box sx={{ mb: 6 }}>
                    <ListDetail data={relatedMovies} type="movie" roleData="related" />
                </Box>
            )}
        </Stack>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import MovieReviewDownvotesPageContent from "./_components/MovieReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "movie", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <MovieReviewDownvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/reviews/[reviewId]/downvotes/_components/MovieReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import MovieReviewUpvotesPageContent from "./_components/MovieReviewUpvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "movie", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <MovieReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/movies/[movieId]/[movieTitle]/reviews/[reviewId]/upvotes/_components/MovieReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/movies/_components/MoviesPageContent.tsx
================================================
import { Box, Stack, Typography } from "@mui/material";
import { Movie } from "@prisma/client";
import { getLatestMovies, getMoviesWithFilters } from "@/actions/movie.actions";
import Carousel from "@/components/root/carousel/Carousel";
import CardItem from "@/components/root/cardItem/CardItem";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { LatestList } from "@/components/root/latestList/LatestList";
import SortSelect from "@/components/root/sortSelect/SortSelect";

interface MoviesPageContentProps {
    searchParams:
        | {
              moviesAscOrDesc?: string;
              pageMovies?: string;
              moviesSortBy?: string;
          }
        | undefined;
    session: any;
}

export default async function MoviesPageContent({ searchParams, session }: MoviesPageContentProps) {
    const ascOrDesc = searchParams?.moviesAscOrDesc ?? "";
    const page = searchParams?.pageMovies ? Number(searchParams.pageMovies) : 1;
    const sortBy = searchParams?.moviesSortBy ?? "";
    const queryParams = {
        ascOrDesc,
        page,
        sortBy,
    };

    const moviesData = await getMoviesWithFilters(queryParams, Number(session?.user?.id));
    const movies = moviesData.movies;
    const moviesCount = moviesData.count;

    const moviesCarouselImages: Movie[] = moviesData.movies.slice(0, 5);
    const latestMovies = await getLatestMovies();

    const itemsPerPage = 12;
    const pageCount = Math.ceil(moviesCount / itemsPerPage);
    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, moviesCount);

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                gap: { xs: 3, sm: 4, md: 5 },
            }}
        >
            <Box component="section">
                <Carousel data={moviesCarouselImages} type="movies" />
            </Box>
            <Box
                component="section"
                sx={{
                    maxWidth: "1200px",
                    margin: "0 auto",
                    width: "100%",
                    px: { xs: 2, sm: 3, md: 4 },
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "flex-start",
                        flexDirection: { xs: "column", sm: "row" },
                        gap: { xs: 2, sm: 3 },
                        mb: { xs: 3, md: 4 },
                    }}
                >
                    <Box
                        sx={{
                            display: "flex",
                            flexDirection: { xs: "column", sm: "row" },
                            alignItems: { xs: "flex-start", sm: "baseline" },
                            gap: { xs: 1, sm: 2 },
                        }}
                    >
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 24, sm: 28, md: 32 },
                                fontWeight: 800,
                                color: "text.primary",
                                position: "relative",
                                display: "inline-block",
                                "&::after": {
                                    content: '""',
                                    position: "absolute",
                                    bottom: -8,
                                    left: 0,
                                    width: "100%",
                                    height: 3,
                                    bgcolor: "primary.main",
                                    borderRadius: 1,
                                },
                            }}
                        >
                            Movies
                        </Typography>
                        <Typography
                            variant="h5"
                            sx={{
                                fontSize: { xs: 16, sm: 18 },
                                color: "text.secondary",
                                mt: { xs: 2, sm: 0 },
                                ml: { sm: 1 },
                                position: "relative",
                                top: { sm: 2 },
                            }}
                        >
                            {startIndex} – {endIndex} of {moviesCount} movies
                        </Typography>
                    </Box>
                    <Box>
                        <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="list" dataType="movies" />
                    </Box>
                </Box>
                <Box
                    sx={{
                        width: "100%",
                        overflow: "hidden",
                        mt: { xs: 4, md: 5 },
                    }}
                >
                    <Stack
                        direction="row"
                        flexWrap="wrap"
                        sx={{
                            columnGap: { xs: 1, sm: 2, md: 3 },
                            rowGap: { xs: 3, sm: 4, md: 5 },
                            justifyContent: {
                                xs: "center",
                                md: "flex-start",
                            },
                            mx: { xs: 1, sm: 2 },
                            mb: { xs: 3, md: 4 },
                        }}
                    >
                        {movies.map((movie: Movie) => (
                            <CardItem key={movie.id} data={movie} type="movie" />
                        ))}
                    </Stack>
                    <PaginationControl currentPage={Number(page)} pageCount={pageCount} urlParamName="pageMovies" />
                </Box>
            </Box>
            <LatestList data={latestMovies} type="Movies" />
        </Box>
    );
}


================================================
File: src/app/(root)/notifications/page.tsx
================================================
import { getAllNotifications } from "@/actions/user/userFollow.actions";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { redirect } from "next/navigation";
import NotificationsPageContent from "./_components/NotificationsPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface INotificationsPageProps {
    searchParams?: Promise<{ page?: string }>;
}

export default async function NotificationsPage(props: INotificationsPageProps) {
    const session = await getServerSession(authOptions);
    const userName = session?.user.userName;
    const userId = Number(session?.user.id);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const notifications = await getAllNotifications(Number(session?.user.id), page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <NotificationsPageContent notifications={notifications} userName={userName!} userId={userId} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/notifications/_components/NotificationsPageContent.tsx
================================================
"use client";

import { Box, Container, Typography, Paper, Stack, Avatar, Button, CircularProgress } from "@mui/material";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { motion } from "framer-motion";
import NotificationsActiveIcon from "@mui/icons-material/NotificationsActive";
import { formatDistanceToNow } from "date-fns";
import Link from "next/link";
import { useQueryState } from "nuqs";

interface NotificationsPageContentProps {
    notifications: any;
    userName: string;
    userId: number;
}

export default function NotificationsPageContent({ notifications, userId, userName }: NotificationsPageContentProps) {
    const [page, setPage] = useQueryState("page", {
        defaultValue: 1,
        parse: (value) => Number(value) || 1,
        history: "push",
        shallow: false,
    });

    const totalPages = Math.ceil(notifications.total / 10);

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Typography variant="h4" gutterBottom sx={{ mb: 4 }}>
                Your Notifications
            </Typography>
            {notifications.items.length > 0 && userId && userName ? (
                <Box sx={{ mb: 4, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <Typography variant="body1" color="text.secondary">
                        Check all your follow requests for approval.
                    </Typography>
                    <Link href={`/users/${userId}/${userName}/followersRequests`} passHref>
                        <Button
                            variant="outlined"
                            size="small"
                            sx={{
                                textTransform: "none",
                                borderRadius: 2,
                                fontSize: "0.8rem",
                                fontWeight: 500,
                                boxShadow: 1,
                                bgcolor: "background.paper",
                                color: (theme) => theme.vars.palette.greyAccent.main,
                                borderWidth: 2,
                                height: 30,
                                minWidth: 100,
                                "&:hover": {
                                    bgcolor: "background.default",
                                },
                            }}
                        >
                            View Requests
                        </Button>
                    </Link>
                </Box>
            ) : null}

            <Stack spacing={2}>
                {notifications.items.length > 0 ? (
                    notifications.items.map((notification: any, index: number) => (
                        <motion.div
                            key={notification.id}
                            initial={{ opacity: 0, y: 20 }}
                            animate={{
                                opacity: 1,
                                y: 0,
                                transition: { delay: index * 0.1 },
                            }}
                        >
                            <Paper
                                sx={{
                                    p: 2,
                                    bgcolor: notification.status === "unread" ? "action.hover" : "background.paper",
                                    transition: "all 0.2s",
                                    "&:hover": {
                                        transform: "translateY(-2px)",
                                        boxShadow: (theme) => theme.shadows[4],
                                    },
                                }}
                                elevation={notification.status === "unread" ? 2 : 1}
                            >
                                <Stack direction="row" spacing={2} alignItems="center">
                                    <Avatar
                                        src={notification.sender.avatar?.photoSrc}
                                        alt={notification.sender.userName}
                                        sx={{ width: 50, height: 50 }}
                                    />
                                    <Box sx={{ flex: 1 }}>
                                        <Typography variant="body1" sx={{ fontWeight: 500 }}>
                                            {notification.sender.userName}
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                                            {notification.content}
                                        </Typography>
                                        <Typography
                                            variant="caption"
                                            color="text.secondary"
                                            sx={{ mt: 1, display: "block" }}
                                        >
                                            {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })}
                                        </Typography>
                                    </Box>
                                </Stack>
                            </Paper>
                        </motion.div>
                    ))
                ) : (
                    <Box
                        sx={{
                            py: 8,
                            display: "flex",
                            flexDirection: "column",
                            alignItems: "center",
                            gap: 2,
                        }}
                    >
                        <NotificationsActiveIcon
                            sx={{
                                fontSize: 64,
                                color: "text.disabled",
                            }}
                        />
                        <Typography variant="h6" color="text.secondary" align="center">
                            No notifications yet
                        </Typography>
                    </Box>
                )}
            </Stack>
            <Box sx={{ display: "flex", justifyContent: "center", mt: 4, mb: 2 }}>
                <PaginationControl currentPage={page} pageCount={totalPages} />
            </Box>
        </Container>
    );
}


================================================
File: src/app/(root)/privacy/page.tsx
================================================
import React from "react";
import PrivacyContentPage from "./_components/PrivacyContentPage";

export default function PrivacyPage() {
    return <PrivacyContentPage />;
}


================================================
File: src/app/(root)/privacy/_components/PrivacyContentPage.tsx
================================================
"use client";

import React from "react";
import { Container, Typography, Box, Stack, useTheme, Paper, Divider } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

const Section = ({
    title,
    content,
    items,
    subsections,
}: {
    title: string;
    content: string;
    items?: string[];
    subsections?: Array<{ title: string; content: string; items?: string[] }>;
}) => {
    const theme = useTheme();

    return (
        <Paper
            elevation={0}
            sx={{
                p: 4,
                borderRadius: 2,
                backgroundColor: "rgba(255, 255, 255, 0.05)",
                transition: "transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out",
                "&:hover": {
                    transform: "translateY(-2px)",
                    boxShadow: "0 4px 20px rgba(0, 0, 0, 0.1)",
                },
            }}
        >
            <Typography
                variant="h4"
                gutterBottom
                sx={{
                    color: theme.vars.palette.primary.main,
                    fontWeight: 700,
                    mb: 3,
                    borderBottom: `2px solid ${theme.vars.palette.primary.main}`,
                    pb: 1,
                }}
            >
                {title}
            </Typography>

            <Typography
                sx={{
                    mb: 2,
                    color: theme.vars.palette.text.primary,
                    lineHeight: 1.7,
                }}
            >
                {content}
            </Typography>

            {items && (
                <Box component="ul" sx={{ pl: 3, mb: 3 }}>
                    {items.map((item, index) => (
                        <Typography
                            component="li"
                            key={index}
                            sx={{
                                mb: 1,
                                color: theme.vars.palette.text.secondary,
                                "&::marker": {
                                    color: theme.vars.palette.primary.main,
                                },
                            }}
                        >
                            {item}
                        </Typography>
                    ))}
                </Box>
            )}

            {subsections && (
                <Stack spacing={3} sx={{ mt: 3 }}>
                    {subsections.map((subsection, index) => (
                        <Box key={index}>
                            <Typography
                                variant="h6"
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontWeight: 600,
                                    mb: 2,
                                }}
                            >
                                {subsection.title}
                            </Typography>
                            <Typography
                                sx={{
                                    mb: 2,
                                    color: theme.vars.palette.text.secondary,
                                }}
                            >
                                {subsection.content}
                            </Typography>
                            {subsection.items && (
                                <Box component="ul" sx={{ pl: 3 }}>
                                    {subsection.items.map((item, itemIndex) => (
                                        <Typography
                                            component="li"
                                            key={itemIndex}
                                            sx={{
                                                mb: 1,
                                                color: theme.vars.palette.text.secondary,
                                                "&::marker": {
                                                    color: theme.vars.palette.primary.main,
                                                },
                                            }}
                                        >
                                            {item}
                                        </Typography>
                                    ))}
                                </Box>
                            )}
                        </Box>
                    ))}
                </Stack>
            )}
        </Paper>
    );
};

const PrivacyContentPage = () => {
    const theme = useTheme();

    return (
        <Container maxWidth="lg" sx={{ py: 8 }}>
            <Paper
                elevation={0}
                sx={{
                    p: 4,
                    mb: 6,
                    borderRadius: 2,
                    background: `linear-gradient(135deg, ${theme.vars.palette.primary.main}22 0%, ${theme.vars.palette.primary.main}11 100%)`,
                }}
            >
                <Typography
                    variant="h2"
                    gutterBottom
                    sx={{
                        color: theme.vars.palette.primary.main,
                        fontWeight: 800,
                        textAlign: "center",
                        textTransform: "uppercase",
                        letterSpacing: "0.1em",
                    }}
                >
                    Privacy Policy
                </Typography>
                <Typography
                    sx={{
                        textAlign: "center",
                        color: theme.vars.palette.text.secondary,
                        mb: 2,
                    }}
                >
                    Last updated: {new Date().toLocaleDateString()}
                </Typography>
                <Divider sx={{ my: 3 }} />
                <Typography
                    sx={{
                        textAlign: "center",
                        color: theme.vars.palette.text.secondary,
                        maxWidth: "800px",
                        mx: "auto",
                    }}
                >
                    At MovieLandia24, we value your privacy and are committed to protecting your personal information.
                    This Privacy Policy explains how we collect, use, and safeguard your data.
                </Typography>
            </Paper>

            <Stack spacing={4}>
                <Section
                    title="1. Information We Collect"
                    content="We collect various types of information to provide and improve our services:"
                    subsections={[
                        {
                            title: "1.1 Personal Information",
                            content: "Information that you provide directly to us:",
                            items: [
                                "Name and email address",
                                "Profile information and preferences",
                                "Payment information (processed securely through our payment providers)",
                                "Communication preferences",
                            ],
                        },
                        {
                            title: "1.2 Automatically Collected Information",
                            content: "Information collected automatically when you use our service:",
                            items: [
                                "Device information (type, operating system, browser)",
                                "IP address and location data",
                                "Usage patterns and preferences",
                                "Cookies and similar tracking technologies",
                            ],
                        },
                    ]}
                />

                <Section
                    title="2. How We Use Your Information"
                    content="Your information helps us provide and improve our services:"
                    subsections={[
                        {
                            title: "2.1 Service Provision",
                            content: "We use your information to:",
                            items: [
                                "Create and manage your account",
                                "Process your requests and transactions",
                                "Provide customer support",
                                "Personalize your experience",
                            ],
                        },
                        {
                            title: "2.2 Service Improvement",
                            content: "We analyze usage patterns to:",
                            items: [
                                "Improve our website functionality",
                                "Develop new features",
                                "Enhance user experience",
                                "Fix bugs and issues",
                            ],
                        },
                    ]}
                />

                <Section
                    title="3. Data Protection"
                    content="We implement strong security measures to protect your information:"
                    subsections={[
                        {
                            title: "3.1 Security Measures",
                            content: "Our security practices include:",
                            items: [
                                "Encryption of sensitive data",
                                "Regular security audits",
                                "Secure data storage",
                                "Access controls and monitoring",
                            ],
                        },
                        {
                            title: "3.2 Data Retention",
                            content:
                                "We retain your information only as long as necessary to provide our services and comply with legal obligations.",
                            items: [
                                "Account information retained while account is active",
                                "Backup retention for disaster recovery",
                                "Legal compliance retention periods",
                                "Option to request data deletion",
                            ],
                        },
                    ]}
                />

                <Section
                    title="4. Information Sharing"
                    content="We share your information only in specific circumstances:"
                    subsections={[
                        {
                            title: "4.1 Third-Party Service Providers",
                            content: "We may share data with trusted service providers who assist us in:",
                            items: [
                                "Payment processing",
                                "Analytics and performance monitoring",
                                "Email and communication services",
                                "Customer support",
                            ],
                        },
                        {
                            title: "4.2 Legal Requirements",
                            content: "We may disclose information when required by law:",
                            items: [
                                "Court orders and legal processes",
                                "Government requests",
                                "Protection of rights and safety",
                                "Prevention of fraud or abuse",
                            ],
                        },
                    ]}
                />

                <Section
                    title="5. Your Rights"
                    content="You have several rights regarding your personal information:"
                    subsections={[
                        {
                            title: "5.1 Access and Control",
                            content: "You can request to:",
                            items: [
                                "Access your personal data",
                                "Correct inaccurate information",
                                "Delete your data",
                                "Export your data",
                            ],
                        },
                        {
                            title: "5.2 Preferences",
                            content: "You can manage your preferences for:",
                            items: [
                                "Marketing communications",
                                "Notification settings",
                                "Privacy settings",
                                "Cookie preferences",
                            ],
                        },
                    ]}
                />

                <Section
                    title="6. Cookies and Tracking"
                    content="We use cookies and similar technologies to enhance your experience:"
                    subsections={[
                        {
                            title: "6.1 Types of Cookies",
                            content: "We use different types of cookies:",
                            items: [
                                "Essential cookies for basic functionality",
                                "Performance cookies for analytics",
                                "Functionality cookies for preferences",
                                "Targeting cookies for personalized content",
                            ],
                        },
                        {
                            title: "6.2 Cookie Management",
                            content: "You have control over cookies:",
                            items: [
                                "Browser settings to manage cookies",
                                "Option to reject non-essential cookies",
                                "Cookie preference center",
                                "Third-party cookie controls",
                            ],
                        },
                    ]}
                />

                <Section
                    title="7. Children's Privacy"
                    content="We take special precautions to protect children's privacy:"
                    subsections={[
                        {
                            title: "7.1 Age Restrictions",
                            content:
                                "Our service is not intended for children under 13. We do not knowingly collect information from children under 13.",
                        },
                        {
                            title: "7.2 Parental Controls",
                            content: "Parents or guardians can request to:",
                            items: [
                                "Review their child's information",
                                "Request deletion of data",
                                "Control privacy settings",
                                "Manage account access",
                            ],
                        },
                    ]}
                />

                <Section
                    title="8. International Data Transfers"
                    content="We may transfer your data internationally:"
                    subsections={[
                        {
                            title: "8.1 Data Transfer Safeguards",
                            content: "We ensure appropriate safeguards for international data transfers:",
                            items: [
                                "Standard contractual clauses",
                                "Data protection agreements",
                                "Compliance with local laws",
                                "Security measures during transfer",
                            ],
                        },
                    ]}
                />

                <Section
                    title="9. Contact Information"
                    content="For privacy-related inquiries or concerns, please contact us:"
                    items={[
                        "Email: privacy@movielandia24.com",
                        "Address: 123 Movie Street, Cinema City, CC 12345",
                        "Phone: +1 (555) 123-4567",
                        "Data Protection Officer: dpo@movielandia24.com",
                    ]}
                />
            </Stack>
        </Container>
    );
};

export default PrivacyContentPage;


================================================
File: src/app/(root)/register-verification-sent/page.tsx
================================================
"use client";

import { Box, Container, Typography } from "@mui/material";
import { useQueryState } from "nuqs";

export default function VerifyRegisterPage() {
    const [email, setEmail] = useQueryState("email", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    return (
        <Container
            sx={{
                height: "100vh",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
            }}
        >
            {email && email.length > 0 ? (
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        p: 4,
                        boxShadow: 6,
                        borderRadius: 4,
                        backgroundColor: "background.paper",
                    }}
                >
                    <Typography variant="h4" component="h1" gutterBottom>
                        Verify Your Email
                    </Typography>
                    <Typography variant="body1" sx={{ mb: 3 }}>
                        We have sent a verification link to <strong>{email}</strong>.
                    </Typography>
                    <Typography variant="body2">
                        Please check your email and follow the instructions to verify your account.
                    </Typography>
                </Box>
            ) : (
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        p: 4,
                        boxShadow: 6,
                        borderRadius: 4,
                        backgroundColor: "background.paper",
                    }}
                >
                    <Typography variant="h4" component="h1" gutterBottom>
                        Email not provided
                    </Typography>
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/reset-password/page.tsx
================================================
"use client";

import { Box, Button, FormLabel, TextField, Typography, useTheme } from "@mui/material";
import EmailIcon from "@mui/icons-material/Email";
import { showToast } from "@/utils/helpers/toast";
import { resetPassword } from "@/actions/auth.actions";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { resetPasswordSchema } from "@/schemas/auth.schema";

export default function ResetPasswordPage() {
    const theme = useTheme();

    async function handleSubmitResetPassword(values: { email: string }) {
        const userData = {
            email: values.email,
        };

        try {
            await resetPassword(userData);
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while resetting the password.");
            }
        }
    }

    const {
        control,
        handleSubmit,
        formState: { errors, isSubmitting },
    } = useForm({
        resolver: zodResolver(resetPasswordSchema),
        defaultValues: {
            email: "",
        },
    });

    return (
        <Box
            sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                height: "100vh",
                rowGap: 4,
            }}
        >
            <Box
                sx={{
                    padding: 10,
                    borderRadius: 10,
                    backgroundColor: theme.vars.palette.primary.dark,
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: "row",
                        alignItems: "center",
                        justifyContent: "center",
                        pb: 2,
                    }}
                >
                    <Typography variant="h2" textAlign={"center"}>
                        Reset Password
                    </Typography>
                </Box>
                <form onSubmit={handleSubmit(handleSubmitResetPassword)}>
                    <Box
                        sx={{
                            display: "flex",
                            flexDirection: "column",
                            rowGap: 2,
                            width: 300,
                            maxWidth: "100%",
                        }}
                    >
                        <Box display={"flex"} flexDirection="row" columnGap={1}>
                            <EmailIcon />
                            <FormLabel component={"label"}>Email</FormLabel>
                        </Box>
                        <Controller
                            name="email"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    size="small"
                                    error={!!errors.email}
                                    helperText={errors.email?.message}
                                    placeholder="Enter your email address"
                                    autoComplete="email"
                                    hiddenLabel={true}
                                    aria-autocomplete="both"
                                    type="text"
                                />
                            )}
                        />
                        <Button
                            type="submit"
                            variant="text"
                            sx={{ fontWeight: 700, py: 1, fontSize: 18, textTransform: "capitalize" }}
                            disabled={isSubmitting}
                        >
                            {isSubmitting ? "Sending..." : "Send Reset Link"}
                        </Button>
                    </Box>
                </form>
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/reset-password-verification-sent/page.tsx
================================================
"use client";

import { Box, Container, Typography } from "@mui/material";
import { useQueryState } from "nuqs";

export default function ResetPasswordVerifyPage() {
    const [email, setEmail] = useQueryState("email", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    return (
        <Container
            sx={{
                height: "100vh",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
            }}
        >
            {email && email.length > 0 ? (
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        p: 4,
                        boxShadow: 6,
                        borderRadius: 4,
                        backgroundColor: "background.paper",
                    }}
                >
                    <Typography variant="body1" sx={{ mb: 3 }}>
                        We have sent a reset password verification link to <strong>{email}</strong>.
                    </Typography>
                    <Typography variant="body2">
                        Please check your email and follow the instructions to reset your password.
                    </Typography>
                </Box>
            ) : (
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        p: 4,
                        boxShadow: 6,
                        borderRadius: 4,
                        backgroundColor: "background.paper",
                    }}
                >
                    <Typography variant="h4" component="h1" gutterBottom>
                        Email not provided
                    </Typography>
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/search/page.tsx
================================================
import { Suspense } from "react";
import type { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import SearchPageContent from "./_components/SearchPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface ISearchProps {
    searchParams?: Promise<{
        moviesAscOrDesc?: string;
        pageMovies?: string;
        moviesSortBy?: string;
        seriesAscOrDesc?: string;
        pageSeries?: string;
        seriesSortBy?: string;
        actorsAscOrDesc?: string;
        pageActors?: string;
        actorsSortBy?: string;
        seasonsAscOrDesc?: string;
        pageSeasons?: string;
        seasonsSortBy?: string;
        episodesAscOrDesc?: string;
        pageEpisodes?: string;
        episodesSortBy?: string;
        usersAscOrDesc?: string;
        pageUsers?: string;
        usersSortBy?: string;
        term?: string;
    }>;
}

export const metadata: Metadata = {
    title: "Search Movies, Series, Actors and More | High-Quality and Always Updated",
    description:
        "Search through our vast collection of movies, series, actors, episodes, and more. Our content is always updated with the newest releases.",
    openGraph: {
        type: "website",
        url: `${process.env.NEXT_PUBLIC_PROJECT_URL}/search`,
        title: "Search Movies, Series, Actors and More",
        description: "Search through our vast collection of movies, series, actors, episodes, and more.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "Search Movies, Series, Actors and More",
        description: "Search through our vast collection of movies, series, actors, episodes, and more.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Search(props: ISearchProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SearchPageContent searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/search/_components/SearchList.tsx
================================================
"use client";

import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import SortSelect from "@/components/root/sortSelect/SortSelect";
import CardItem, { PathType } from "@/components/root/cardItem/CardItem";
import { Box, Typography, useTheme } from "@mui/material";
import { Actor, Crew, Episode, Movie, Season, Serie, User } from "@prisma/client";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { motion } from "framer-motion";

interface MediaListProps {
    title: string;
    data: Array<Movie | Serie | Actor | Season | Episode | User | Crew>;
    count: number;
    sortBy: string;
    ascOrDesc: string;
    page: number;
    pageCount: number;
    dataType: "Movies" | "Series" | "Actors" | "Seasons" | "Episodes" | "Users" | "Crew";
    cardType: "movie" | "serie" | "actor" | "season" | "episode" | "user" | "crew";
    path?: PathType;
}

const SearchList = ({
    title,
    data,
    count,
    sortBy,
    ascOrDesc,
    page,
    pageCount,
    dataType,
    cardType,
    path = null,
}: MediaListProps) => {
    const theme = useTheme();

    const itemsPerPage = 12;
    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, count);

    if (data.length === 0) {
        return null;
    }

    return (
        <Box
            component={motion.section}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.3 }}
            sx={{
                width: "100%",
                bgcolor: "background.paper",
                borderRadius: 2,
                boxShadow: theme.vars.shadows[1],
                overflow: "hidden",
            }}
        >
            <Box
                sx={{
                    p: { xs: 2, sm: 3 },
                    borderBottom: `1px solid ${theme.vars.palette.divider}`,
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        flexDirection: { xs: "column", sm: "row" },
                        justifyContent: "space-between",
                        alignItems: { xs: "flex-start", sm: "center" },
                        gap: 2,
                    }}
                >
                    <Box>
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 20, sm: 24 },
                                fontWeight: 700,
                                color: "text.primary",
                                mb: 0.5,
                            }}
                        >
                            {title}
                        </Typography>
                        <Typography
                            variant="body2"
                            sx={{
                                color: "text.secondary",
                            }}
                        >
                            {startIndex} – {endIndex} of {count} {dataType.toLowerCase()}
                        </Typography>
                    </Box>
                    <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="list" dataType={dataType.toLowerCase()} />
                </Box>
            </Box>
            <Box sx={{ p: { xs: 2, sm: 3 } }}>
                <Box
                    sx={{
                        display: "flex",
                        flexWrap: "wrap",
                        columnGap: { xs: 2, sm: 3 },
                        rowGap: { xs: 3, sm: 4 },
                        justifyContent: "flex-start",
                    }}
                >
                    {data.map((item) => (
                        <Box
                            key={item.id}
                            sx={{
                                display: "flex",
                                columnGap: { xs: 1, sm: 2, md: 3 },
                                paddingLeft: 1,
                                rowGap: { xs: 3, sm: 4, md: 5 },
                                transition: "transform 0.2s ease-in-out",
                                "&:hover": {
                                    transform: "translateY(-4px)",
                                },
                            }}
                        >
                            <CardItem data={item} type={cardType} path={path} />
                        </Box>
                    ))}
                </Box>
                <Box sx={{ mt: 4, display: "flex", justifyContent: "center" }}>
                    <PaginationControl
                        currentPage={Number(page)}
                        pageCount={pageCount}
                        urlParamName={`page${dataType}`}
                    />
                </Box>
            </Box>
        </Box>
    );
};

export default SearchList;


================================================
File: src/app/(root)/search/_components/SearchPageContent.tsx
================================================
// #region "Imports"
import { Box, Typography } from "@mui/material";
import { Actor, Crew, Episode, Movie, Season, Serie, User } from "@prisma/client";
import { searchMoviesByTitle } from "@/actions/movie.actions";
import { searchSeriesByTitle } from "@/actions/serie.actions";
import { searchActorsByTitle } from "@/actions/actor.actions";
import { searchSeasonsByTitle } from "@/actions/season.actions";
import { searchEpisodesByTitle } from "@/actions/episode.actions";
import { searchUsersByUsername } from "@/actions/user/user.actions";
import SearchList from "./SearchList";
import { searchCrewMembersByFullname } from "@/actions/crew.actions";
import SearchTabs from "./SearchTabs";
// #endregion

// #region "Interfaces"
interface SearchPageContentProps {
    searchParams?: {
        moviesAscOrDesc?: string;
        pageMovies?: string;
        moviesSortBy?: string;
        seriesAscOrDesc?: string;
        pageSeries?: string;
        seriesSortBy?: string;
        actorsAscOrDesc?: string;
        pageActors?: string;
        actorsSortBy?: string;
        crewAscOrDesc?: string;
        pageCrews?: string;
        crewSortBy?: string;
        seasonsAscOrDesc?: string;
        pageSeasons?: string;
        seasonsSortBy?: string;
        episodesAscOrDesc?: string;
        pageEpisodes?: string;
        episodesSortBy?: string;
        usersAscOrDesc?: string;
        pageUsers?: string;
        usersSortBy?: string;
        term?: string;
        filters?: string;
    };
    session: any;
}

interface IQueryParams {
    page: number;
    ascOrDesc?: string;
    sortBy?: string;
}
// #endregion

export default async function SearchPageContent({ searchParams, session }: SearchPageContentProps) {
    const term = searchParams?.term ?? "";
    const selectedFilters = searchParams?.filters?.split(",") || ["all"];
    const itemsPerPage = 12;

    let movies: Movie[] = [],
        moviesCount = 0,
        pageCountMovies = 0;
    let series: Serie[] = [],
        seriesCount = 0,
        pageCountSeries = 0;
    let actors: Actor[] = [],
        actorsCount = 0,
        pageCountActors = 0;
    let crews: Crew[] = [],
        crewsCount = 0,
        pageCountCrews = 0;
    let episodes: Episode[] = [],
        episodesCount = 0,
        pageCountEpisodes = 0;
    let seasons: Season[] = [],
        seasonsCount = 0,
        pageCountSeasons = 0;
    let users: User[] = [],
        usersCount = 0,
        pageCountUsers = 0;

    const shouldFetchData = (type: string) => selectedFilters.includes("all") || selectedFilters.includes(type);

    if (shouldFetchData("movies")) {
        const pageMovies = Number(searchParams?.pageMovies) || 1;
        const queryParamsMovies: IQueryParams = {
            page: pageMovies,
            sortBy: searchParams?.moviesSortBy ?? "",
            ascOrDesc: searchParams?.moviesAscOrDesc ?? "",
        };

        const moviesData = await searchMoviesByTitle(term, queryParamsMovies, Number(session?.user?.id));
        movies = moviesData.movies;
        moviesCount = moviesData.count;
        pageCountMovies = Math.ceil(moviesCount / itemsPerPage);
    }

    if (shouldFetchData("series")) {
        const pageSeries = Number(searchParams?.pageSeries) || 1;
        const queryParamsSeries: IQueryParams = {
            page: pageSeries,
            sortBy: searchParams?.seriesSortBy ?? "",
            ascOrDesc: searchParams?.seriesAscOrDesc ?? "",
        };

        const seriesData = await searchSeriesByTitle(term, queryParamsSeries, Number(session?.user?.id));
        series = seriesData.rows;
        seriesCount = seriesData.count;
        pageCountSeries = Math.ceil(seriesCount / itemsPerPage);
    }

    if (shouldFetchData("actors")) {
        const pageActors = Number(searchParams?.pageActors) || 1;
        const queryParamsActors: IQueryParams = {
            page: pageActors,
            sortBy: searchParams?.actorsSortBy ?? "",
            ascOrDesc: searchParams?.actorsAscOrDesc ?? "",
        };

        const actorsData = await searchActorsByTitle(term, queryParamsActors, Number(session?.user?.id));
        actors = actorsData.actors;
        actorsCount = actorsData.count;
        pageCountActors = Math.ceil(actorsCount / itemsPerPage);
    }

    if (shouldFetchData("crew")) {
        const pageCrews = Number(searchParams?.pageCrews) || 1;
        const queryParamsCrews: IQueryParams = {
            page: pageCrews,
            sortBy: searchParams?.crewSortBy ?? "",
            ascOrDesc: searchParams?.crewAscOrDesc ?? "",
        };

        const crewsData = await searchCrewMembersByFullname(term, queryParamsCrews, Number(session?.user?.id));
        crews = crewsData.crews;
        crewsCount = crewsData.count;
        pageCountCrews = Math.ceil(crewsCount / itemsPerPage);
    }

    if (shouldFetchData("episodes")) {
        const pageEpisodes = Number(searchParams?.pageEpisodes) || 1;
        const queryParamsEpisodes: IQueryParams = {
            page: pageEpisodes,
            sortBy: searchParams?.episodesSortBy ?? "",
            ascOrDesc: searchParams?.episodesAscOrDesc ?? "",
        };

        const episodesData = await searchEpisodesByTitle(term, queryParamsEpisodes, Number(session?.user?.id));
        episodes = episodesData.episodes;
        episodesCount = episodesData.count;
        pageCountEpisodes = Math.ceil(episodesCount / itemsPerPage);
    }

    if (shouldFetchData("seasons")) {
        const pageSeasons = Number(searchParams?.pageSeasons) || 1;
        const queryParamsSeasons: IQueryParams = {
            page: pageSeasons,
            sortBy: searchParams?.seasonsSortBy ?? "",
            ascOrDesc: searchParams?.seasonsAscOrDesc ?? "",
        };

        const seasonsData = await searchSeasonsByTitle(term, queryParamsSeasons, Number(session?.user?.id));
        seasons = seasonsData.seasons;
        seasonsCount = seasonsData.count;
        pageCountSeasons = Math.ceil(seasonsCount / itemsPerPage);
    }

    if (shouldFetchData("users")) {
        const pageUsers = Number(searchParams?.pageUsers) || 1;
        const queryParamsUsers: IQueryParams = {
            page: pageUsers,
            sortBy: searchParams?.usersSortBy ?? "",
            ascOrDesc: searchParams?.usersAscOrDesc ?? "",
        };

        const usersData = await searchUsersByUsername(term, queryParamsUsers);
        users = usersData.users;
        usersCount = usersData.count;
        pageCountUsers = Math.ceil(usersCount / itemsPerPage);
    }

    const totalResults =
        moviesCount + seriesCount + actorsCount + seasonsCount + episodesCount + usersCount + crewsCount;

    const shouldShowSection = (type: string) => {
        if (selectedFilters.includes("all")) return true;
        return selectedFilters.includes(type.toLowerCase());
    };

    const formatSelectedFilters = (filters: string[]) => {
        if (filters.includes("all")) return "across all categories";

        const formattedFilters = filters.map((filter) => filter.charAt(0).toUpperCase() + filter.slice(1));

        if (formattedFilters.length === 1) {
            return `in ${formattedFilters[0]}`;
        }

        if (formattedFilters.length === 2) {
            return `in ${formattedFilters.join(" and ")}`;
        }

        const lastFilter = formattedFilters.pop();
        return `in ${formattedFilters.join(", ")}, and ${lastFilter}`;
    };

    return (
        <Box
            sx={{
                maxWidth: "1400px",
                margin: "0 auto",
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 3, md: 4 },
            }}
        >
            <Box
                sx={{
                    mb: { xs: 4, md: 6 },
                    mt: { xs: 4, md: 6 },
                    textAlign: "center",
                }}
            >
                <Typography
                    variant="h1"
                    sx={{
                        fontSize: { xs: 28, sm: 32, md: 40 },
                        fontWeight: 800,
                        mb: 2,
                        mt: 8,
                    }}
                >
                    {term ? `Search Results for "${term}"` : "Browse All"}
                </Typography>
                <Typography
                    variant="body1"
                    sx={{
                        color: "text.secondary",
                        fontSize: { xs: 16, sm: 18 },
                        maxWidth: "600px",
                        margin: "0 auto",
                    }}
                >
                    {term
                        ? `Found ${totalResults} results ${formatSelectedFilters(selectedFilters)}`
                        : "Explore our vast collection of movies, series, actors and more"}
                </Typography>
            </Box>
            <SearchTabs />
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    gap: { xs: 6, md: 8 },
                    mt: 4,
                }}
            >
                {shouldShowSection("movies") && (
                    <SearchList
                        title={term ? `Movies matching "${term}"` : "Movies"}
                        data={movies}
                        count={moviesCount}
                        sortBy={searchParams?.moviesSortBy ?? ""}
                        ascOrDesc={searchParams?.moviesAscOrDesc ?? ""}
                        page={Number(searchParams?.pageMovies) || 1}
                        pageCount={pageCountMovies}
                        dataType="Movies"
                        cardType="movie"
                    />
                )}
                {shouldShowSection("series") && (!term || seriesCount > 0) && (
                    <SearchList
                        title={term ? `Series matching "${term}"` : "Series"}
                        data={series}
                        count={seriesCount}
                        sortBy={searchParams?.seriesSortBy ?? ""}
                        ascOrDesc={searchParams?.seriesAscOrDesc ?? ""}
                        page={Number(searchParams?.pageSeries) || 1}
                        pageCount={pageCountSeries}
                        dataType="Series"
                        cardType="serie"
                    />
                )}
                {shouldShowSection("actors") && (!term || actorsCount > 0) && (
                    <SearchList
                        title={term ? `Actors matching "${term}"` : "Actors"}
                        data={actors}
                        count={actorsCount}
                        sortBy={searchParams?.actorsSortBy ?? ""}
                        ascOrDesc={searchParams?.actorsAscOrDesc ?? ""}
                        page={Number(searchParams?.pageActors) || 1}
                        pageCount={pageCountActors}
                        dataType="Actors"
                        cardType="actor"
                        path="actors"
                    />
                )}
                {shouldShowSection("crew") && (!term || crewsCount > 0) && (
                    <SearchList
                        title={term ? `Crews matching "${term}"` : "Crews"}
                        data={crews}
                        count={crewsCount}
                        sortBy={searchParams?.crewSortBy ?? ""}
                        ascOrDesc={searchParams?.crewAscOrDesc ?? ""}
                        page={Number(searchParams?.pageCrews) || 1}
                        pageCount={pageCountCrews}
                        dataType="Crew"
                        cardType="crew"
                        path="crew"
                    />
                )}
                {shouldShowSection("seasons") && (!term || seasonsCount > 0) && (
                    <SearchList
                        title={term ? `Seasons matching "${term}"` : "Seasons"}
                        data={seasons}
                        count={seasonsCount}
                        sortBy={searchParams?.seasonsSortBy ?? ""}
                        ascOrDesc={searchParams?.seasonsAscOrDesc ?? ""}
                        page={Number(searchParams?.pageSeasons) || 1}
                        pageCount={pageCountSeasons}
                        dataType="Seasons"
                        cardType="season"
                    />
                )}
                {shouldShowSection("episodes") && (!term || episodesCount > 0) && (
                    <SearchList
                        title={term ? `Episodes matching "${term}"` : "Episodes"}
                        data={episodes}
                        count={episodesCount}
                        sortBy={searchParams?.episodesSortBy ?? ""}
                        ascOrDesc={searchParams?.episodesAscOrDesc ?? ""}
                        page={Number(searchParams?.pageEpisodes) || 1}
                        pageCount={pageCountEpisodes}
                        dataType="Episodes"
                        cardType="episode"
                    />
                )}
                {shouldShowSection("users") && (!term || usersCount > 0) && (
                    <SearchList
                        title={term ? `Users matching "${term}"` : "Users"}
                        data={users}
                        count={usersCount}
                        sortBy={searchParams?.usersSortBy ?? ""}
                        ascOrDesc={searchParams?.usersAscOrDesc ?? ""}
                        page={Number(searchParams?.pageUsers) || 1}
                        pageCount={pageCountUsers}
                        dataType="Users"
                        cardType="user"
                    />
                )}
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/search/_components/SearchTabs.tsx
================================================
"use client";

import { Box, Typography } from "@mui/material";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import LiveTvIcon from "@mui/icons-material/LiveTv";
import PlaylistPlayIcon from "@mui/icons-material/PlaylistPlay";
import PlayCircleOutlineIcon from "@mui/icons-material/PlayCircleOutline";
import PersonIcon from "@mui/icons-material/Person";
import GroupWorkIcon from "@mui/icons-material/GroupWork";
import PersonOutlineIcon from "@mui/icons-material/PersonOutline";
import AllInclusiveIcon from "@mui/icons-material/AllInclusive";
import { JSX } from "react";
import { useQueryState } from "nuqs";

interface TabOption {
    label: string;
    icon: JSX.Element;
    value: string;
}

const tabOptions: TabOption[] = [
    { label: "All", icon: <AllInclusiveIcon />, value: "all" },
    { label: "Movies", icon: <LocalMoviesIcon />, value: "movies" },
    { label: "Series", icon: <LiveTvIcon />, value: "series" },
    { label: "Seasons", icon: <PlaylistPlayIcon />, value: "seasons" },
    { label: "Episodes", icon: <PlayCircleOutlineIcon />, value: "episodes" },
    { label: "Actors", icon: <PersonIcon />, value: "actors" },
    { label: "Crew", icon: <GroupWorkIcon />, value: "crew" },
    { label: "Users", icon: <PersonOutlineIcon />, value: "users" },
];

export default function SearchTabs() {
    const [filters, setFilters] = useQueryState("filters", {
        defaultValue: "all",
        parse: (value) => value || "all",
        history: "push",
        shallow: false,
    });

    const selectedFilters = filters?.split(",") || ["all"];

    const handleTabClick = (value: string) => {
        let newFilters: string[];

        if (value === "all") {
            newFilters = ["all"];
        } else {
            if (selectedFilters.includes("all")) {
                newFilters = [value];
            } else {
                if (selectedFilters.includes(value)) {
                    newFilters = selectedFilters.filter((f) => f !== value);
                    if (newFilters.length === 0) newFilters = ["all"];
                } else {
                    newFilters = [...selectedFilters, value];
                }
            }
        }

        setFilters(newFilters.join(","));
    };

    return (
        <Box
            sx={{
                width: "100%",
                borderBottom: 1,
                borderColor: "divider",
                position: "relative",
            }}
        >
            <Box
                sx={{
                    display: "flex",
                    flexWrap: "wrap",
                    gap: 1,
                    p: { xs: 1, sm: 1.5 },
                    mx: -1,
                    justifyContent: { xs: "center", sm: "flex-start" },
                }}
            >
                {tabOptions.map((tab) => (
                    <Box
                        key={tab.value}
                        onClick={() => handleTabClick(tab.value)}
                        sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.75,
                            px: { xs: 1.25, sm: 1.5 },
                            py: { xs: 0.75, sm: 1 },
                            borderRadius: 1,
                            cursor: "pointer",
                            transition: "all 0.2s",
                            bgcolor: selectedFilters.includes(tab.value) ? "primary.main" : "transparent",
                            color: selectedFilters.includes(tab.value) ? "primary.contrastText" : "text.primary",
                            "&:hover": {
                                bgcolor: selectedFilters.includes(tab.value) ? "primary.light" : "action.hover",
                            },
                            "& .MuiSvgIcon-root": {
                                fontSize: { xs: "1.1rem", sm: "1.25rem" },
                            },
                            boxShadow: selectedFilters.includes(tab.value) ? 1 : "none",
                            transform: selectedFilters.includes(tab.value) ? "scale(1.02)" : "scale(1)",
                            "&:active": {
                                transform: "scale(0.98)",
                            },
                        }}
                    >
                        {tab.icon}
                        <Typography
                            sx={{
                                fontSize: { xs: "0.8125rem", sm: "0.875rem" },
                                fontWeight: selectedFilters.includes(tab.value) ? 600 : 400,
                                lineHeight: 1,
                            }}
                        >
                            {tab.label}
                        </Typography>
                    </Box>
                ))}
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/series/page.tsx
================================================
import { Suspense } from "react";
import type { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import SeriesPageContent from "./_components/SeriesPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";

interface ISeriesProps {
    searchParams?: Promise<{ seriesAscOrDesc?: string; page?: string; seriesSortBy?: string }>;
}

const baseUrl = process.env.NEXT_PUBLIC_PROJECT_URL;

export const metadata: Metadata = {
    title: "Watch the Latest Series | High-Quality and Always Updated",
    description:
        "Discover and watch the latest and most amazing series in high quality. Our collection is always updated with the newest episodes and releases.",
    openGraph: {
        type: "video.tv_show",
        url: `${baseUrl}/series`,
        title: "Watch the Latest Series | High-Quality and Always Updated",
        description:
            "Discover and watch the latest and most amazing series in high quality. Our collection is always updated with the newest episodes and releases.",
        siteName: "MovieLandia24",
    },
    twitter: {
        card: "summary_large_image",
        site: "@movieLandia24",
        creator: "movieLandia24",
        title: "Watch the Latest Series | High-Quality and Always Updated",
        description:
            "Discover and watch the latest and most amazing series in high quality. Our collection is always updated with the newest episodes and releases.",
    },
    robots: {
        index: true,
        follow: true,
    },
};

export default async function Series(props: ISeriesProps) {
    const session = await getServerSession(authOptions);

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SeriesPageContent searchParams={searchParams} session={session} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/page.tsx
================================================
import { getLatestSeries, getRelatedSeries, getSerieById } from "@/actions/serie.actions";
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { Serie } from "@prisma/client";
import SeriePageContent from "./_components/SeriePageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface ISerieProps {
    params: {
        serieId: string;
    };
    searchParams?: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        castPage?: string;
        crewPage?: string;
        seasonsPage?: string;
    };
}

export async function generateMetadata({ params }: ISerieProps): Promise<Metadata> {
    const { serieId } = params;

    let serie: Serie;

    try {
        serie = await getSerieById(Number(serieId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = serie!;

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/series/${serie.title}`;

    return {
        title: `${serie.title} | Serie`,
        description: `${serie.description}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${serie.title} | Serie`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 160,
                          height: 200,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${serie.title} | Serie`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function SeriePage(props: ISerieProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const serieId = params.serieId;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams?.reviewsAscOrDesc;
    const reviewsSortBy = searchParams?.reviewsSortBy || "";
    const reviewsPage = searchParams?.reviewsPage ? Number(searchParams.reviewsPage) : 1;

    const castPage = searchParams?.castPage ? Number(searchParams.castPage) : 1;
    const crewPage = searchParams?.crewPage ? Number(searchParams.crewPage) : 1;
    const seasonsPage = searchParams?.seasonsPage ? Number(searchParams.seasonsPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        castPage,
        crewPage,
        seasonsPage,
        userId: Number(session?.user?.id),
    };

    let serie = null;

    try {
        serie = await getSerieById(Number(serieId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const relatedSeries = await getRelatedSeries(Number(serieId), Number(session?.user?.id));

    const pageCountReviews = Math.ceil(serie.totalReviews / 5);
    const castPageCount = Math.ceil(serie.totalCast / 5);
    const crewPageCount = Math.ceil(serie.totalCrew / 5);
    const seasonsPageCount = Math.ceil(serie.totalSeasons / 6);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SeriePageContent
                searchParamsValues={{
                    reviewsAscOrDesc,
                    reviewsPage: Number(reviewsPage),
                    reviewsSortBy,
                    castPage: Number(castPage) || 1,
                    crewPage: Number(crewPage) || 1,
                    seasonsPage: Number(seasonsPage) || 1,
                }}
                serie={serie}
                relatedSeries={relatedSeries}
                reviewsPageCount={pageCountReviews}
                castPageCount={castPageCount}
                crewPageCount={crewPageCount}
                seasonsPageCount={seasonsPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/_components/SeriePageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { useEffect } from "react";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import * as CONSTANTS from "@/constants/Constants";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { Serie } from "@prisma/client";
import { onBookmarkSerie, onRemoveBookmarkSerie } from "@/utils/features/serieFeaturesUtils";
import { removeDownvoteSerieReview, addDownvoteSerieReview } from "@/actions/user/userDownvotes.actions";
import { addReviewSerie, removeReviewSerie, updateReviewSerie } from "@/actions/user/userReviews.actions";
import { removeUpvoteSerieReview, addUpvoteSerieReview } from "@/actions/user/userUpvotes.actions";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";

interface ISeriePageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        castPage: number;
        crewPage: number;
        seasonsPage: number;
    };
    serie: any;
    relatedSeries: Serie[] | null;
    reviewsPageCount: number;
    castPageCount: number;
    crewPageCount: number;
    seasonsPageCount: number;
}

export default function SeriePageContent({
    searchParamsValues,
    serie,
    relatedSeries,
    reviewsPageCount,
    castPageCount,
    crewPageCount,
    seasonsPageCount,
}: ISeriePageContentProps) {
    const theme = useTheme();

    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();
    // #endregion

    // #region "Handlers functions"

    // #region "Review"
    async function onSubmitReview() {
        if (!session?.user || !serie) return;

        try {
            await addReviewSerie({
                serieId: serie.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !serie) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewSerie({
                                serieId: serie.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !serie) return;

        try {
            await updateReviewSerie({
                serieId: serie.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvote, Downvote"
    async function onUpvoteSerie(serieReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !serieReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteSerieReview({ userId: Number(session?.user?.id), serieId: serie.id, serieReviewId });
            } else {
                await removeDownvoteSerieReview({
                    userId: Number(session?.user?.id),
                    serieId: serie.id,
                    serieReviewId,
                });

                await addUpvoteSerieReview({ userId: Number(session?.user?.id), serieId: serie.id, serieReviewId });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the serie.");
            }
        }
    }

    async function onDownVoteSerie(serieReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!serie && !serieReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteSerieReview({
                    userId: Number(session?.user?.id),
                    serieId: serie.id,
                    serieReviewId,
                });
            } else {
                await removeUpvoteSerieReview({ userId: Number(session?.user?.id), serieId: serie.id, serieReviewId });
                await addDownvoteSerieReview({ userId: Number(session?.user?.id), serieId: serie.id, serieReviewId });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the serie.");
            }
        }
    }
    // #endregion

    // #region "Focus handlers"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={4}>
            <DetailsPageCard
                data={serie}
                type="serie"
                isBookmarked={serie.isBookmarked}
                onBookmark={() => onBookmarkSerie(session!, serie)}
                onRemoveBookmark={() => onRemoveBookmarkSerie(session!, serie)}
                cast={serie.cast}
                crew={serie.crew}
                currentCastPage={Number(searchParamsValues.castPage)!}
                castPageCount={castPageCount}
                currentCrewPage={Number(searchParamsValues.crewPage)!}
                crewPageCount={crewPageCount}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {serie.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({serie.totalReviews})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {serie.reviews!.length > 0 ? (
                                <ReviewsHeader
                                    data={serie}
                                    sortingDataType="reviews"
                                    sortBy={searchParamsValues.reviewsSortBy!}
                                    ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                />
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this serie!
                                </Typography>
                            )}
                            {serie.reviews!.map(
                                (review: any, index: number) =>
                                    (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                        <Review
                                            key={index}
                                            review={review}
                                            handleRemoveReview={onSubmitRemoveReview}
                                            isEditMode={isEditMode}
                                            setIsEditMode={setIsEditMode}
                                            setReview={setReview}
                                            handleFocusTextEditor={handleFocusTextEditor}
                                            ref={reviewRef}
                                            setRating={setRating}
                                            handleUpvote={onUpvoteSerie}
                                            handleDownvote={onDownVoteSerie}
                                            type="serie"
                                            data={serie}
                                        />
                                    ),
                            )}
                            {session?.user && (!serie.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {serie.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            {relatedSeries && relatedSeries.length !== 0 && (
                <ListDetail data={relatedSeries} type="serie" roleData="related" />
            )}
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 6 }}>
                <ListDetail data={serie.seasons} type="season" roleData="season" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.seasonsPage)}
                    pageCount={seasonsPageCount}
                    urlParamName="seasonsPage"
                />
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import SerieReviewDownvotesPageContent from "./_components/SerieReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "serie", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SerieReviewDownvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/reviews/[reviewId]/downvotes/_components/SerieReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";
import SerieReviewUpvotesPageContent from "./_components/SerieReviewUpvotesPageContent";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "serie", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SerieReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/reviews/[reviewId]/upvotes/_components/SerieReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/page.tsx
================================================
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getRelatedSeasons, getSeasonById } from "@/actions/season.actions";
import { Season } from "@prisma/client";
import SeasonPageContent from "./_components/SeasonPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface ISeasonProps {
    params: {
        seasonId: string;
        serieId: string;
    };
    searchParams?: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        episodesPage?: string;
        relatedPage?: string;
    };
}

export async function generateMetadata({ params }: ISeasonProps): Promise<Metadata> {
    const { seasonId } = await params;

    let season: Season;

    try {
        season = await getSeasonById(Number(seasonId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = season;
    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/seasons/${season.title}`;

    return {
        title: `${season.title} | Season`,
        description: `${season.description}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${season.title} | Season`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 200,
                          height: 300,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${season.title} | Season`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function SeasonPage(props: ISeasonProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const { seasonId, serieId } = params;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams?.reviewsAscOrDesc;
    const reviewsSortBy = searchParams?.reviewsSortBy || "";

    const reviewsPage = searchParams?.reviewsPage ? Number(searchParams.reviewsPage) : 1;
    const episodesPage = searchParams?.episodesPage ? Number(searchParams.episodesPage) : 1;
    const relatedPage = searchParams?.relatedPage ? Number(searchParams.relatedPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        episodesPage,
        userId: Number(session?.user?.id),
    };

    let season = null;

    try {
        season = await getSeasonById(Number(seasonId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const { seasons: relatedSeasons, count: totalRelated } = await getRelatedSeasons(
        Number(seasonId),
        Number(serieId),
        relatedPage,
    );

    const pageCountReviews = Math.ceil(season.totalReviews / 5);
    const episodesPageCount = Math.ceil(season.totalEpisodes / 6);
    const relatedPageCount = Math.ceil(totalRelated / 6);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SeasonPageContent
                searchParamsValues={{
                    reviewsAscOrDesc,
                    reviewsPage: Number(reviewsPage),
                    reviewsSortBy,
                    episodesPage: Number(episodesPage),
                    relatedPage,
                }}
                season={season}
                relatedSeasons={relatedSeasons}
                reviewsPageCount={pageCountReviews}
                episodesPageCount={episodesPageCount}
                relatedPageCount={relatedPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/_components/SeasonPageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import { useEffect } from "react";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import * as CONSTANTS from "@/constants/Constants";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { Season } from "@prisma/client";
import { onBookmarkSeason, onRemoveBookmarkSeason } from "@/utils/features/seasonFeaturesUtils";
import { removeDownvoteSeasonReview, addDownvoteSeasonReview } from "@/actions/user/userDownvotes.actions";
import { addReviewSeason, removeReviewSeason, updateReviewSeason } from "@/actions/user/userReviews.actions";
import { removeUpvoteSeasonReview, addUpvoteSeasonReview } from "@/actions/user/userUpvotes.actions";
import { useRouter } from "next/navigation";
import { usePathname } from "next/navigation";

interface ISeasonPageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        episodesPage: number;
        relatedPage: number;
    };
    season: any;
    relatedSeasons: Season[] | null;
    reviewsPageCount: number;
    episodesPageCount: number;
    relatedPageCount: number;
}

export default function SeasonPageContent({
    searchParamsValues,
    season,
    relatedSeasons,
    reviewsPageCount,
    episodesPageCount,
    relatedPageCount,
}: ISeasonPageContentProps) {
    const theme = useTheme();
    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        setIsOpenVotesModal,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();

    const router = useRouter();
    const pathname = usePathname();
    // #endregion

    // #region "Handlers functions"

    // #region "Review"
    async function onSubmitReview() {
        if (!session?.user || !season) return;

        try {
            await addReviewSeason({
                seasonId: season.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !season) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewSeason({
                                seasonId: season.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !season) return;

        try {
            await updateReviewSeason({
                seasonId: season.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvote, Downvote"
    async function onUpvoteSeason(seasonReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !seasonReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });
            } else {
                await removeDownvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });

                await addUpvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the season.");
            }
        }
    }

    async function onDownVoteSeason(seasonReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!season && !seasonReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });
            } else {
                await removeUpvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });

                await addDownvoteSeasonReview({
                    userId: Number(session?.user?.id),
                    seasonId: season.id,
                    seasonReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the season.");
            }
        }
    }
    // #endregion

    // #region "Focus handlers"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={2}>
            <DetailsPageCard
                data={season}
                type="season"
                isBookmarked={season.isBookmarked}
                onBookmark={() => onBookmarkSeason(session!, season)}
                onRemoveBookmark={() => onRemoveBookmarkSeason(session!, season)}
                onGoBack={() => {
                    const currentPath = pathname;
                    const seasonsIndex = currentPath.indexOf("seasons/");
                    const newPath = seasonsIndex !== -1 ? currentPath.slice(0, seasonsIndex) : currentPath;

                    router.replace(newPath);
                    router.refresh();
                }}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {season.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({season.totalReviews ? season.totalReviews : 0})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {season.reviews?.length > 0 ? (
                                <>
                                    <ReviewsHeader
                                        data={season}
                                        sortingDataType="reviews"
                                        sortBy={searchParamsValues.reviewsSortBy!}
                                        ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                    />
                                    {season.reviews!.map(
                                        (review: any, index: number) =>
                                            (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                                <Review
                                                    key={index}
                                                    review={review}
                                                    handleRemoveReview={onSubmitRemoveReview}
                                                    isEditMode={isEditMode}
                                                    setIsEditMode={setIsEditMode}
                                                    setReview={setReview}
                                                    handleFocusTextEditor={handleFocusTextEditor}
                                                    ref={reviewRef}
                                                    setRating={setRating}
                                                    handleUpvote={onUpvoteSeason}
                                                    handleDownvote={onDownVoteSeason}
                                                    type="season"
                                                    data={season}
                                                />
                                            ),
                                    )}
                                </>
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this season!
                                </Typography>
                            )}
                            {session?.user && (!season.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {season.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)!}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                <ListDetail data={season.episodes} type="episode" roleData="episode" />
                <PaginationControl
                    currentPage={Number(searchParamsValues.episodesPage)}
                    pageCount={episodesPageCount}
                    urlParamName="episodesPage"
                />
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 6 }}>
                <ListDetail data={relatedSeasons!} type="season" roleData="related" />
                {relatedSeasons && (
                    <PaginationControl
                        currentPage={searchParamsValues.relatedPage}
                        pageCount={relatedPageCount}
                        urlParamName="relatedPage"
                    />
                )}
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/page.tsx
================================================
import { Metadata } from "next";
import { notFound } from "next/navigation";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getEpisodeById, getRelatedEpisodes } from "@/actions/episode.actions";
import { Episode } from "@prisma/client";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";
import EpisodePageContent from "./_components/EpisodePageContent";

interface IEpisodeProps {
    params: {
        episodeId: string;
        seasonId: string;
    };
    searchParams?: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: string;
        reviewsSortBy: string;
        relatedPage?: string;
    };
}

export async function generateMetadata({ params }: IEpisodeProps): Promise<Metadata> {
    const { episodeId } = await params;

    let episode: Episode;

    try {
        episode = await getEpisodeById(Number(episodeId), {});
    } catch (error) {
        return notFound();
    }

    const { description, photoSrcProd } = episode;
    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/episodes/${episode.title}`;

    return {
        title: `${episode.title} | Episode`,
        description: `${episode.description}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${episode.title} | Episode`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          width: 200,
                          height: 300,
                          alt: description,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${episode.title} | Episode`,
            description,
            images: photoSrcProd
                ? [
                      {
                          url: photoSrcProd,
                          alt: description,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function EpisodePage(props: IEpisodeProps) {
    const session = await getServerSession(authOptions);

    const params = await props.params;
    const { episodeId, seasonId } = params;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const reviewsAscOrDesc = searchParams?.reviewsAscOrDesc;
    const reviewsSortBy = searchParams?.reviewsSortBy || "";
    const reviewsPage = searchParams?.reviewsPage ? Number(searchParams.reviewsPage) : 1;
    const relatedPage = searchParams?.relatedPage ? Number(searchParams.relatedPage) : 1;

    const searchParamsValues = {
        reviewsAscOrDesc,
        reviewsPage,
        reviewsSortBy,
        userId: Number(session?.user?.id),
    };

    let episode = null;

    try {
        episode = await getEpisodeById(Number(episodeId), searchParamsValues);
    } catch (error) {
        return notFound();
    }

    const { episodes: relatedEpisodes, count: totalRelated } = await getRelatedEpisodes(
        Number(episodeId),
        Number(seasonId),
        relatedPage,
    );

    const pageCountReviews = Math.ceil(episode.totalReviews / 5);
    const relatedPageCount = Math.ceil(totalRelated / 6);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <EpisodePageContent
                searchParamsValues={{
                    reviewsAscOrDesc,
                    reviewsPage: Number(reviewsPage),
                    reviewsSortBy,
                    relatedPage,
                }}
                episode={episode}
                relatedEpisodes={relatedEpisodes}
                reviewsPageCount={pageCountReviews}
                relatedPageCount={relatedPageCount}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/_components/EpisodePageContent.tsx
================================================
"use client";

import { DetailsPageCard } from "@/components/root/detailsPageCard/DetailsPageCard";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { ListDetail } from "@/components/root/listDetail/ListDetail";
import Review from "@/components/root/review/Review";
import { Box, Stack, Typography, useTheme } from "@mui/material";
import { WarningOutlined, CheckOutlined } from "@mui/icons-material";
import { useEffect } from "react";
import { TextEditorForm } from "@/components/root/textEditorForm/TextEditorForm";
import * as CONSTANTS from "@/constants/Constants";
import { showToast } from "@/utils/helpers/toast";
import ReviewsHeader from "@/components/root/reviewsHeader/ReviewsHeader";
import { usePageDetailsData } from "@/hooks/usePageDetailsData";
import { Episode } from "@prisma/client";
import { onBookmarkEpisode, onRemoveBookmarkEpisode } from "@/utils/features/episodeFeaturesUtils";
import { removeDownvoteEpisodeReview, addDownvoteEpisodeReview } from "@/actions/user/userDownvotes.actions";
import { addReviewEpisode, removeReviewEpisode, updateReviewEpisode } from "@/actions/user/userReviews.actions";
import { removeUpvoteEpisodeReview, addUpvoteEpisodeReview } from "@/actions/user/userUpvotes.actions";
import { useRouter } from "next/navigation";
import { usePathname } from "next/navigation";
import { Accordion, AccordionDetails, AccordionSummary } from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";

interface IEpisodePageContentProps {
    searchParamsValues: {
        reviewsAscOrDesc: string | undefined;
        reviewsPage: number;
        reviewsSortBy: string;
        relatedPage: number;
    };
    episode: any;
    relatedEpisodes: Episode[] | null;
    reviewsPageCount: number;
    relatedPageCount: number;
}

export default function EpisodePage({
    searchParamsValues,
    episode,
    relatedEpisodes,
    reviewsPageCount,
    relatedPageCount,
}: IEpisodePageContentProps) {
    const theme = useTheme();
    // #region "Data for the page"
    const {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        setOpen,
        openModal,
        textEditorRef,
        reviewRef,
    } = usePageDetailsData();

    const router = useRouter();
    const pathname = usePathname();
    // #endregion

    // #region "Handlers functions"

    // #region "Reviews"
    async function onSubmitReview() {
        if (!session?.user || !episode) return;

        try {
            await addReviewEpisode({
                episodeId: episode.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            showToast("success", "Review submitted successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while submitting the review.");
            }
        }
    }

    async function onSubmitRemoveReview() {
        if (!session?.user || !episode) return;

        openModal({
            onClose: () => setOpen(false),
            title: "Remove Review",
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        try {
                            await removeReviewEpisode({
                                episodeId: episode.id,
                                userId: Number(session?.user?.id),
                            });

                            setReview("");
                            showToast("success", "Review removed successfully!");
                        } catch (error) {
                            if (error instanceof Error) {
                                showToast("error", `Error: ${error.message}`);
                            } else {
                                showToast("error", "An unexpected error occurred while deleting the review.");
                            }
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Are you sure that you want to delete this review ?",
        });
    }

    async function onSubmitUpdateReview() {
        if (!session?.user || !episode) return;

        try {
            await updateReviewEpisode({
                episodeId: episode.id,
                userId: Number(session?.user?.id),
                content: review,
                rating: rating ? rating : 0,
            });

            setReview("");
            setRating(null);
            setIsEditMode(false);
            handleFocusReview();
            showToast("success", "Review updated successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while updating the review.");
            }
        }
    }
    // #endregion

    // #region "Upvotes, Downvotes"
    async function onUpvoteEpisode(episodeReviewId: number, isAlreadyUpvoted: boolean) {
        if (!session?.user || !episodeReviewId) return;

        try {
            if (isAlreadyUpvoted) {
                await removeUpvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });
            } else {
                await removeDownvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });

                await addUpvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while upvoting the episode.");
            }
        }
    }

    async function onDownVoteEpisode(episodeReviewId: number, isAlreadyDownvoted: boolean) {
        if (!session?.user || (!episode && !episodeReviewId)) return;

        try {
            if (isAlreadyDownvoted) {
                await removeDownvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });
            } else {
                await removeUpvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });

                await addDownvoteEpisodeReview({
                    userId: Number(session?.user?.id),
                    episodeId: episode.id,
                    episodeReviewId,
                });
            }
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while downvoting the episode.");
            }
        }
    }
    // #endregion

    // #region "Focus functions"
    const handleFocusTextEditor = () => {
        if (textEditorRef.current) {
            textEditorRef.current.focus();
        }
    };

    const handleFocusReview = () => {
        if (reviewRef.current) {
            reviewRef.current.focus();
        }
    };

    useEffect(() => {
        if (isEditMode) {
            handleFocusTextEditor();
        }
    }, [isEditMode]);
    // #endregion

    // #endregion

    return (
        <Stack flexDirection={"column"} rowGap={2}>
            <DetailsPageCard
                data={episode}
                type="episode"
                isBookmarked={episode.isBookmarked}
                onBookmark={() => onBookmarkEpisode(session!, episode)}
                onRemoveBookmark={() => onRemoveBookmarkEpisode(session!, episode)}
                onGoBack={() => {
                    const currentPath = pathname;
                    const episodesIndex = currentPath.indexOf("episodes/");
                    const newPath = episodesIndex !== -1 ? currentPath.slice(0, episodesIndex) : currentPath;

                    router.replace(newPath);
                    router.refresh();
                }}
            />
            <Box
                sx={{
                    maxWidth: "900px",
                    width: "100%",
                    mx: "auto",
                    my: 4,
                    "& .MuiAccordion-root": {
                        mb: 2,
                    },
                }}
            >
                <Accordion
                    defaultExpanded={true}
                    sx={{
                        bgcolor: theme.vars.palette.secondary.light,
                        borderRadius: "12px",
                        "&:before": {
                            display: "none",
                        },
                        "& .MuiAccordionSummary-root": {
                            borderRadius: "12px",
                            transition: "background-color 0.2s",
                            "&:hover": {
                                bgcolor: theme.vars.palette.secondary.dark,
                            },
                        },
                        "& .MuiAccordionSummary-expandIconWrapper": {
                            color: theme.vars.palette.primary.main,
                            transition: "transform 0.3s",
                            "&.Mui-expanded": {
                                transform: "rotate(180deg)",
                            },
                        },
                    }}
                >
                    <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls="reviews-content"
                        id="reviews-header"
                    >
                        <Typography
                            variant="h6"
                            sx={{
                                fontWeight: 600,
                                color: theme.vars.palette.primary.main,
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                        >
                            Reviews
                            {episode.totalReviews >= 0 && (
                                <Typography
                                    component="span"
                                    sx={{
                                        color: theme.vars.palette.primary.main,
                                        fontSize: "0.9rem",
                                        fontWeight: 600,
                                        py: 0.5,
                                        borderRadius: "16px",
                                    }}
                                >
                                    ({episode.totalReviews ? episode.totalReviews : 0})
                                </Typography>
                            )}
                        </Typography>
                    </AccordionSummary>
                    <AccordionDetails
                        sx={{
                            p: { xs: 2, sm: 3 },
                            borderTop: `1px solid ${theme.vars.palette.divider}`,
                        }}
                    >
                        <Box
                            component="section"
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                rowGap: 2,
                            }}
                        >
                            {episode.reviews?.length > 0 ? (
                                <>
                                    <ReviewsHeader
                                        data={episode}
                                        sortingDataType="reviews"
                                        sortBy={searchParamsValues.reviewsSortBy!}
                                        ascOrDesc={searchParamsValues.reviewsAscOrDesc!}
                                    />
                                    {episode.reviews!.map(
                                        (review: any, index: number) =>
                                            (!isEditMode || review.user.id !== Number(session?.user?.id)) && (
                                                <Review
                                                    key={index}
                                                    review={review}
                                                    handleRemoveReview={onSubmitRemoveReview}
                                                    isEditMode={isEditMode}
                                                    setIsEditMode={setIsEditMode}
                                                    setReview={setReview}
                                                    handleFocusTextEditor={handleFocusTextEditor}
                                                    ref={reviewRef}
                                                    setRating={setRating}
                                                    handleUpvote={onUpvoteEpisode}
                                                    handleDownvote={onDownVoteEpisode}
                                                    type="episode"
                                                    data={episode}
                                                />
                                            ),
                                    )}
                                </>
                            ) : (
                                <Typography
                                    variant="body1"
                                    sx={{
                                        textAlign: "center",
                                        color: theme.vars.palette.text.secondary,
                                    }}
                                >
                                    No reviews yet. Be the first to review this episode!
                                </Typography>
                            )}
                            {session?.user && (!episode.isReviewed || isEditMode) && (
                                <TextEditorForm
                                    review={review}
                                    setReview={setReview}
                                    rating={rating}
                                    setRating={setRating}
                                    isEditMode={isEditMode}
                                    setIsEditMode={setIsEditMode}
                                    setOpen={setOpen}
                                    textEditorRef={textEditorRef}
                                    handleFocusReview={handleFocusReview}
                                    onSubmitReview={onSubmitReview}
                                    onSubmitUpdateReview={onSubmitUpdateReview}
                                />
                            )}
                            {episode.totalReviews > 0 && (
                                <PaginationControl
                                    currentPage={Number(searchParamsValues.reviewsPage)}
                                    pageCount={reviewsPageCount}
                                    urlParamName="reviewsPage"
                                />
                            )}
                        </Box>
                    </AccordionDetails>
                </Accordion>
            </Box>
            <Box component="section" sx={{ display: "flex", flexDirection: "column", gap: 2, mb: 6 }}>
                <ListDetail data={relatedEpisodes!} type="episode" roleData="related" />
                {relatedEpisodes && (
                    <PaginationControl
                        currentPage={searchParamsValues.relatedPage}
                        pageCount={relatedPageCount}
                        urlParamName="relatedPage"
                    />
                )}
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import EpisodeReviewDownvotesPageContent from "./_components/EpisodeReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "episode", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <EpisodeReviewDownvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/reviews/[reviewId]/downvotes/_components/EpisodeReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import EpisodeReviewUpvotesPageContent from "./_components/EpisodeReviewUpvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "episode", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <EpisodeReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/episodes/[episodeId]/[episodeTitle]/reviews/[reviewId]/upvotes/_components/EpisodeReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/reviews/[reviewId]/downvotes/page.tsx
================================================
import { getDownvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import SeasonReviewUpvotesPageContent from "./_components/SeasonReviewDownvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IDownvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function DownvotesPage(props: IDownvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const downvotes = await getDownvotesByReviewId(Number(params.reviewId), "season", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SeasonReviewUpvotesPageContent downvotes={downvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/reviews/[reviewId]/downvotes/_components/SeasonReviewDownvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface DownvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    downvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function DownvotesContent({ downvotes, userLoggedIn }: DownvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(downvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Downvotes
            </Typography>
            <Stack spacing={2}>
                {downvotes.items.length > 0 ? (
                    downvotes.items.map((downvote) => (
                        <UserListItem key={downvote.user.id} user={downvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No downvotes yet
                    </Typography>
                )}
            </Stack>
            {downvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/reviews/[reviewId]/upvotes/page.tsx
================================================
import { getUpvotesByReviewId } from "@/actions/review/reviewVotes.actions";
import SeasonReviewUpvotesPageContent from "./_components/SeasonReviewUpvotesPageContent";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IUpvotesPageProps {
    params: {
        reviewId: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function UpvotesPage(props: IUpvotesPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const upvotes = await getUpvotesByReviewId(Number(params.reviewId), "season", page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <SeasonReviewUpvotesPageContent upvotes={upvotes} userLoggedIn={userSession} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/series/[serieId]/[serieTitle]/seasons/[seasonId]/[seasonTitle]/reviews/[reviewId]/upvotes/_components/SeasonReviewUpvotesPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";
import UserListItem from "@/app/(root)/users/[userId]/[userName]/_components/UserListItem";

interface UpvotesContentProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    upvotes: {
        items: Array<{
            user: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
            };
        }>;
        total: number;
    };
}

export default function UpvotesContent({ upvotes, userLoggedIn }: UpvotesContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(upvotes.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.back();
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                Upvotes
            </Typography>
            <Stack spacing={2}>
                {upvotes.items.length > 0 ? (
                    upvotes.items.map((upvote) => (
                        <UserListItem key={upvote.user.id} user={upvote.user} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No upvotes yet
                    </Typography>
                )}
            </Stack>
            {upvotes.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/series/_components/SeriesPageContent.tsx
================================================
import { Box, Stack, Typography } from "@mui/material";
import { Serie } from "@prisma/client";
import { getLatestSeries, getSeriesWithFilters } from "@/actions/serie.actions";
import Carousel from "@/components/root/carousel/Carousel";
import CardItem from "@/components/root/cardItem/CardItem";
import PaginationControl from "@/components/root/paginationControl/PaginationControl";
import { LatestList } from "@/components/root/latestList/LatestList";
import SortSelect from "@/components/root/sortSelect/SortSelect";

interface SeriesPageContentProps {
    searchParams:
        | {
              seriesAscOrDesc?: string;
              pageSeries?: string;
              seriesSortBy?: string;
          }
        | undefined;
    session: any;
}

export default async function SeriesPageContent({ searchParams, session }: SeriesPageContentProps) {
    const ascOrDesc = searchParams?.seriesAscOrDesc ?? "";
    const page = searchParams?.pageSeries ? Number(searchParams.pageSeries) : 1;
    const sortBy = searchParams?.seriesSortBy ?? "";
    const queryParams = {
        ascOrDesc,
        page,
        sortBy,
    };

    const seriesData = await getSeriesWithFilters(queryParams, Number(session?.user?.id));
    const series = seriesData.rows;
    const seriesCount = seriesData.count;

    const seriesCarouselImages: Serie[] = seriesData.rows.slice(0, 5);
    const latestSeries = await getLatestSeries();

    const itemsPerPage = 12;
    const pageCount = Math.ceil(seriesCount / itemsPerPage);
    const startIndex = (page - 1) * itemsPerPage + 1;
    const endIndex = Math.min(startIndex + itemsPerPage - 1, seriesCount);

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                gap: { xs: 3, sm: 4, md: 5 },
            }}
        >
            <Box component="section">
                <Carousel data={seriesCarouselImages} type="series" />
            </Box>
            <Box
                component="section"
                sx={{
                    maxWidth: "1200px",
                    margin: "0 auto",
                    width: "100%",
                    px: { xs: 2, sm: 3, md: 4 },
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "flex-start",
                        flexDirection: { xs: "column", sm: "row" },
                        gap: { xs: 2, sm: 3 },
                        mb: { xs: 3, md: 4 },
                    }}
                >
                    <Box
                        sx={{
                            display: "flex",
                            flexDirection: { xs: "column", sm: "row" },
                            alignItems: { xs: "flex-start", sm: "baseline" },
                            gap: { xs: 1, sm: 2 },
                        }}
                    >
                        <Typography
                            variant="h2"
                            sx={{
                                fontSize: { xs: 24, sm: 28, md: 32 },
                                fontWeight: 800,
                                color: "text.primary",
                                position: "relative",
                                display: "inline-block",
                                "&::after": {
                                    content: '""',
                                    position: "absolute",
                                    bottom: -8,
                                    left: 0,
                                    width: "100%",
                                    height: 3,
                                    bgcolor: "primary.main",
                                    borderRadius: 1,
                                },
                            }}
                        >
                            Series
                        </Typography>
                        <Typography
                            variant="h5"
                            sx={{
                                fontSize: { xs: 16, sm: 18 },
                                color: "text.secondary",
                                mt: { xs: 2, sm: 0 },
                                ml: { sm: 1 },
                                position: "relative",
                                top: { sm: 2 },
                            }}
                        >
                            {startIndex} – {endIndex} of {seriesCount} series
                        </Typography>
                    </Box>
                    <Box>
                        <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="list" dataType="series" />
                    </Box>
                </Box>
                <Box
                    sx={{
                        width: "100%",
                        overflow: "hidden",
                        mt: { xs: 4, md: 5 },
                    }}
                >
                    <Stack
                        direction="row"
                        flexWrap="wrap"
                        sx={{
                            columnGap: { xs: 1, sm: 2, md: 3 },
                            rowGap: { xs: 3, sm: 4, md: 5 },
                            justifyContent: {
                                xs: "center",
                                md: "flex-start",
                            },
                            mx: { xs: 1, sm: 2 },
                            mb: { xs: 3, md: 4 },
                        }}
                    >
                        {series.map((serie: Serie) => (
                            <CardItem key={serie.id} data={serie} type="serie" />
                        ))}
                    </Stack>
                    <PaginationControl currentPage={Number(page)} pageCount={pageCount} urlParamName="pageSeries" />
                </Box>
            </Box>
            <LatestList data={latestSeries} type="Series" />
        </Box>
    );
}


================================================
File: src/app/(root)/terms/page.tsx
================================================
import React from "react";
import TermsContentPage from "./_components/TermsContentPage";

export default function TermsPage() {
    return <TermsContentPage />;
}


================================================
File: src/app/(root)/terms/_components/TermsContentPage.tsx
================================================
"use client";

import React from "react";
import { Container, Typography, Box, Stack, useTheme, Paper, Divider } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

const Section = ({
    title,
    content,
    items,
    subsections,
}: {
    title: string;
    content: string;
    items?: string[];
    subsections?: Array<{ title: string; content: string; items?: string[] }>;
}) => {
    const theme = useTheme();

    return (
        <Paper
            elevation={0}
            sx={{
                p: 4,
                borderRadius: 2,
                backgroundColor: "rgba(255, 255, 255, 0.05)",
                transition: "transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out",
                "&:hover": {
                    transform: "translateY(-2px)",
                    boxShadow: "0 4px 20px rgba(0, 0, 0, 0.1)",
                },
            }}
        >
            <Typography
                variant="h4"
                gutterBottom
                sx={{
                    color: theme.vars.palette.primary.main,
                    fontWeight: 700,
                    mb: 3,
                    borderBottom: `2px solid ${theme.vars.palette.primary.main}`,
                    pb: 1,
                }}
            >
                {title}
            </Typography>

            <Typography
                sx={{
                    mb: 2,
                    color: theme.vars.palette.text.primary,
                    lineHeight: 1.7,
                }}
            >
                {content}
            </Typography>

            {items && (
                <Box component="ul" sx={{ pl: 3, mb: 3 }}>
                    {items.map((item, index) => (
                        <Typography
                            component="li"
                            key={index}
                            sx={{
                                mb: 1,
                                color: theme.vars.palette.text.secondary,
                                "&::marker": {
                                    color: theme.vars.palette.primary.main,
                                },
                            }}
                        >
                            {item}
                        </Typography>
                    ))}
                </Box>
            )}

            {subsections && (
                <Stack spacing={3} sx={{ mt: 3 }}>
                    {subsections.map((subsection, index) => (
                        <Box key={index}>
                            <Typography
                                variant="h6"
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    fontWeight: 600,
                                    mb: 2,
                                }}
                            >
                                {subsection.title}
                            </Typography>
                            <Typography
                                sx={{
                                    mb: 2,
                                    color: theme.vars.palette.text.secondary,
                                }}
                            >
                                {subsection.content}
                            </Typography>
                            {subsection.items && (
                                <Box component="ul" sx={{ pl: 3 }}>
                                    {subsection.items.map((item, itemIndex) => (
                                        <Typography
                                            component="li"
                                            key={itemIndex}
                                            sx={{
                                                mb: 1,
                                                color: theme.vars.palette.text.secondary,
                                                "&::marker": {
                                                    color: theme.vars.palette.primary.main,
                                                },
                                            }}
                                        >
                                            {item}
                                        </Typography>
                                    ))}
                                </Box>
                            )}
                        </Box>
                    ))}
                </Stack>
            )}
        </Paper>
    );
};

const TermsContentPage = () => {
    const theme = useTheme();

    return (
        <Container maxWidth="lg" sx={{ py: 8 }}>
            <Paper
                elevation={0}
                sx={{
                    p: 4,
                    mb: 6,
                    borderRadius: 2,
                    background: `linear-gradient(135deg, ${theme.vars.palette.primary.main}22 0%, ${theme.vars.palette.primary.main}11 100%)`,
                }}
            >
                <Typography
                    variant="h2"
                    gutterBottom
                    sx={{
                        color: theme.vars.palette.primary.main,
                        fontWeight: 800,
                        textAlign: "center",
                        textTransform: "uppercase",
                        letterSpacing: "0.1em",
                    }}
                >
                    Terms of Service
                </Typography>
                <Typography
                    sx={{
                        textAlign: "center",
                        color: theme.vars.palette.text.secondary,
                        mb: 2,
                    }}
                >
                    Last updated: {new Date().toLocaleDateString()}
                </Typography>
                <Divider sx={{ my: 3 }} />
                <Typography
                    sx={{
                        textAlign: "center",
                        color: theme.vars.palette.text.secondary,
                        maxWidth: "800px",
                        mx: "auto",
                    }}
                >
                    Please read these terms of service carefully before using MovieLandia24. By accessing or using our
                    service, you agree to be bound by these terms.
                </Typography>
            </Paper>

            <Stack spacing={4}>
                <Section
                    title="1. Acceptance of Terms"
                    content="By accessing and using MovieLandia24, you acknowledge that you have read, understood, and agree to be bound by these Terms of Service and our Privacy Policy."
                    subsections={[
                        {
                            title: "1.1 Eligibility",
                            content:
                                "You must be at least 13 years old to use our service. If you are under 18, you must have parental consent.",
                        },
                        {
                            title: "1.2 Changes to Terms",
                            content:
                                "We reserve the right to modify these terms at any time. We will notify users of any material changes via email or through our platform.",
                        },
                    ]}
                />

                <Section
                    title="2. User Accounts"
                    content="Your account security is important to us. When creating and maintaining your account:"
                    items={[
                        "You must provide accurate and complete information",
                        "You are responsible for maintaining the security of your account credentials",
                        "You must notify us immediately of any unauthorized access",
                        "You are responsible for all activities under your account",
                    ]}
                    subsections={[
                        {
                            title: "2.1 Account Termination",
                            content:
                                "We reserve the right to suspend or terminate accounts that violate our terms or for any other reason at our discretion.",
                            items: [
                                "Violation of these Terms of Service",
                                "Extended periods of inactivity",
                                "Fraudulent or illegal activities",
                                "Harassment of other users",
                            ],
                        },
                        {
                            title: "2.2 Account Recovery",
                            content:
                                "We provide account recovery options through email verification. Multiple failed recovery attempts may result in temporary account lockout.",
                        },
                    ]}
                />

                <Section
                    title="3. Content Guidelines"
                    content="Users must adhere to our content guidelines when interacting with our platform:"
                    items={[
                        "No illegal or unauthorized content",
                        "No harassment or hate speech",
                        "No spam or misleading information",
                        "No copyright infringement",
                        "No impersonation of others",
                    ]}
                    subsections={[
                        {
                            title: "3.1 User-Generated Content",
                            content:
                                "By posting content on our platform, you grant us a non-exclusive, worldwide license to use, display, and distribute your content.",
                        },
                        {
                            title: "3.2 Content Moderation",
                            content:
                                "We reserve the right to remove or modify any content that violates our guidelines or terms of service.",
                            items: [
                                "Content is reviewed by our moderation team",
                                "Automated systems may flag potentially inappropriate content",
                                "Users can report violations",
                                "Appeals process available for content removal",
                            ],
                        },
                    ]}
                />

                <Section
                    title="4. Privacy and Data Protection"
                    content="We take your privacy seriously and handle your data in accordance with our Privacy Policy."
                    subsections={[
                        {
                            title: "4.1 Data Collection",
                            content: "We collect and process personal data as described in our Privacy Policy.",
                            items: [
                                "Account information",
                                "Usage data",
                                "Device information",
                                "Communication preferences",
                            ],
                        },
                        {
                            title: "4.2 Data Security",
                            content: "We implement industry-standard security measures to protect your data.",
                            items: [
                                "Encryption of sensitive data",
                                "Regular security audits",
                                "Access controls and monitoring",
                                "Incident response procedures",
                            ],
                        },
                    ]}
                />

                <Section
                    title="5. Intellectual Property"
                    content="All content and materials available on MovieLandia24 are protected by intellectual property rights."
                    subsections={[
                        {
                            title: "5.1 Ownership",
                            content:
                                "MovieLandia24 owns or licenses all content on our platform, including but not limited to text, graphics, logos, and software.",
                        },
                        {
                            title: "5.2 Limited License",
                            content:
                                "We grant you a limited, non-exclusive license to access and use our service for personal, non-commercial purposes.",
                            items: [
                                "No redistribution of content",
                                "No unauthorized copying or scraping",
                                "No reverse engineering",
                                "No commercial use without permission",
                            ],
                        },
                    ]}
                />

                <Section
                    title="6. Limitation of Liability"
                    content="To the maximum extent permitted by law, MovieLandia24 shall not be liable for any indirect, incidental, special, consequential, or punitive damages."
                    subsections={[
                        {
                            title: "6.1 Warranty Disclaimer",
                            content:
                                "Our service is provided 'as is' without any warranties of any kind, either express or implied.",
                        },
                        {
                            title: "6.2 Force Majeure",
                            content:
                                "We are not liable for any failure or delay in performance due to circumstances beyond our reasonable control.",
                        },
                    ]}
                />

                <Section
                    title="7. Dispute Resolution"
                    content="Any disputes arising from these terms or our service shall be resolved through:"
                    items={[
                        "Initial informal negotiations",
                        "Mediation if informal negotiations fail",
                        "Binding arbitration as a last resort",
                        "Class action waiver",
                    ]}
                    subsections={[
                        {
                            title: "7.1 Governing Law",
                            content:
                                "These terms are governed by and construed in accordance with the laws of the jurisdiction where MovieLandia24 is registered.",
                        },
                        {
                            title: "7.2 Legal Compliance",
                            content:
                                "Users must comply with all applicable laws and regulations when using our service.",
                        },
                    ]}
                />

                <Section
                    title="8. Contact Information"
                    content="For any questions or concerns about these Terms of Service, please contact us:"
                    items={[
                        "Email: legal@movielandia24.com",
                        "Address: 123 Movie Street, Cinema City, CC 12345",
                        "Phone: +1 (555) 123-4567",
                        "Support Hours: Monday to Friday, 9 AM - 6 PM EST",
                    ]}
                />
            </Stack>
        </Container>
    );
};

export default TermsContentPage;


================================================
File: src/app/(root)/users/[userId]/[userName]/page.tsx
================================================
import { Metadata } from "next";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { notFound } from "next/navigation";
import UserPageContent from "./_components/UserPageContent";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";
import { getUserById } from "@/actions/user/user.actions";
import { getFollowers, getFollowing, getPendingFollowRequests } from "@/actions/user/userFollow.actions";
import { getUserFavorites, getUserReviews, getUserVotes } from "@/actions/user/userProfile.actions";

interface IUserDetailsProps {
    params: {
        userId: string;
    };
    searchParams?: Promise<{ maintab?: string; subtab?: string; page?: string; search?: string }>;
}

export async function generateMetadata(props: IUserDetailsProps): Promise<Metadata> {
    const params = await props.params;
    const { userId } = params;
    let userInPage: any;

    try {
        userInPage = await getUserById(Number(userId));
    } catch (error) {
        return notFound();
    }

    const pageUrl = `${process.env.NEXT_PUBLIC_PROJECT_URL}/users/${userInPage.id}/${userInPage.userName}`;

    return {
        title: `${userInPage.userName} | User`,
        description: `${userInPage.bio}`,
        openGraph: {
            type: "video.tv_show",
            url: pageUrl,
            title: `${userInPage.userName} | User`,
            description: userInPage.bio,
            images: userInPage.avatar?.photoSrc
                ? [
                      {
                          url: userInPage.avatar?.photoSrc,
                          width: 160,
                          height: 200,
                          alt: userInPage.bio,
                      },
                  ]
                : [],
            siteName: "MovieLandia24",
        },
        twitter: {
            card: "summary_large_image",
            site: "@movieLandia24",
            creator: "movieLandia24",
            title: `${userInPage.userName} | User`,
            description: userInPage.bio,
            images: userInPage.avatar?.photoSrc
                ? [
                      {
                          url: userInPage.avatar?.photoSrc,
                          alt: userInPage.bio,
                      },
                  ]
                : [],
        },
        robots: {
            index: true,
            follow: true,
        },
    };
}

export default async function UserPage(props: IUserDetailsProps) {
    const session = await getServerSession(authOptions);

    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const userId = params.userId;

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);

    const mainTab = searchParams?.maintab || "bookmarks";
    const subTab = searchParams?.subtab || "movies";
    const page = searchParams?.page ? Number(searchParams.page) : 1;
    const search = searchParams?.search || "";

    let userInPage;
    let additionalData: any = { items: [], total: 0 };
    let userFollowers: any;
    let userFollowing: any;
    let userPendingFollowers: any;

    try {
        userInPage = await getUserById(Number(userId), userSession?.id);
        userFollowers = await getFollowers(Number(userId));
        userFollowing = await getFollowing(Number(userId));
        userPendingFollowers = await getPendingFollowRequests(Number(userId));

        if (!userInPage) {
            return notFound();
        }

        if (mainTab === "bookmarks") {
            additionalData = await getUserFavorites(
                Number(userId),
                subTab.toLowerCase() as "movies" | "series" | "actors" | "crew" | "seasons" | "episodes",
                page,
                search,
            );
        } else if (mainTab === "reviews") {
            additionalData = await getUserReviews(
                Number(userId),
                subTab as "movies" | "series" | "actors" | "crew" | "seasons" | "episodes",
                page,
                search,
            );
        } else if (mainTab === "upvotes" || mainTab === "downvotes") {
            additionalData = await getUserVotes(
                Number(userId),
                subTab as "movies" | "series" | "actors" | "crew" | "seasons" | "episodes",
                mainTab,
                search,
                page,
            );
        }
    } catch (error) {
        return notFound();
    }

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <UserPageContent
                userLoggedIn={userSession}
                userInPage={userInPage}
                additionalData={additionalData}
                userFollowers={userFollowers}
                userFollowing={userFollowing}
                userPendingFollowers={userPendingFollowers}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/CardItemProfile.tsx
================================================
"use client";

import React, { useTransition } from "react";
import { motion } from "framer-motion";
import ClearIcon from "@mui/icons-material/Clear";
import Link from "next/link";
import Image from "next/image";
import { Box, IconButton, Typography, useTheme, CircularProgress } from "@mui/material";
import { Actor, Crew, Episode, Movie, Season, Serie, User } from "@prisma/client";
import { showToast } from "@/utils/helpers/toast";
import {
    removeFavoriteMovieToUser,
    removeFavoriteSerieToUser,
    removeFavoriteSeasonToUser,
    removeFavoriteEpisodeToUser,
    removeFavoriteActorToUser,
    removeFavoriteCrewToUser,
} from "@/actions/user/userBookmarks.actions";

export type FavoriteType = "Movies" | "Series" | "Actors" | "Crew" | "Seasons" | "Episodes";

interface FavoriteMovie {
    id: number;
    movie: Movie;
}

interface FavoriteSerie {
    id: number;
    serie: Serie;
}

interface FavoriteActor {
    id: number;
    actor: Actor;
}

interface FavoriteCrew {
    id: number;
    crew: Crew;
}

interface FavoriteSeason {
    id: number;
    season: Season;
}

interface FavoriteEpisode {
    id: number;
    episode: Episode;
}

type FavoriteItem = FavoriteMovie | FavoriteSerie | FavoriteActor | FavoriteCrew | FavoriteSeason | FavoriteEpisode;

interface CardItemProfileProps {
    favItem: FavoriteItem;
    type: FavoriteType;
    getItemUrl: (favItem: FavoriteItem) => string | undefined;
    userLoggedIn: User | null;
    userInPage: User | null;
}

const CardItemProfile: React.FC<CardItemProfileProps> = ({ favItem, type, userLoggedIn, getItemUrl, userInPage }) => {
    const theme = useTheme();
    const [isPending, startTransition] = useTransition();

    // #region "Removing bookmark"
    async function onRemoveBookmarkMovie(movie: Movie) {
        if (!userLoggedIn || !movie) return;

        try {
            await removeFavoriteMovieToUser(
                Number(userLoggedIn.id),
                movie.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favMovies`,
            );

            showToast("success", "Movie unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }

    async function onRemoveBookmarkSerie(serie: Serie) {
        if (!userLoggedIn || !serie) return;

        try {
            await removeFavoriteSerieToUser(
                Number(userLoggedIn.id),
                serie.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favSeries`,
            );

            showToast("success", "Serie unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }

    async function onRemoveBookmarkSeason(season: Season) {
        if (!userLoggedIn || !season) return;

        try {
            await removeFavoriteSeasonToUser(
                Number(userLoggedIn.id),
                season.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favSeason`,
            );

            showToast("success", "Season unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }

    async function onRemoveBookmarkEpisode(episode: Episode) {
        if (!userLoggedIn || !episode) return;

        try {
            await removeFavoriteEpisodeToUser(
                Number(userLoggedIn.id),
                episode.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favEpisodes`,
            );

            showToast("success", "Episode unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }

    async function onRemoveBookmarkActor(actor: Actor) {
        if (!userLoggedIn || !actor) return;

        try {
            await removeFavoriteActorToUser(
                Number(userLoggedIn.id),
                actor.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favActors`,
            );

            showToast("success", "Actor unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }

    async function onRemoveBookmarkCrew(crew: Crew) {
        if (!userLoggedIn || !crew) return;

        try {
            await removeFavoriteCrewToUser(
                Number(userLoggedIn.id),
                crew.id,
                `/users/${userLoggedIn.id}/${userLoggedIn.userName}?tab=favCrew`,
            );

            showToast("success", "Crew unbookmarked successfully!");
        } catch (error) {
            if (error instanceof Error) {
                showToast("error", `Error: ${error.message}`);
            } else {
                showToast("error", "An unexpected error occurred while removing the bookmark");
            }
        }
    }
    // #endregion

    const getPhotoSrc = () => {
        switch (type) {
            case "Movies":
                return (favItem as FavoriteMovie).movie.photoSrcProd;
            case "Series":
                return (favItem as FavoriteSerie).serie.photoSrcProd;
            case "Actors":
                return (favItem as FavoriteActor).actor.photoSrcProd;
            case "Crew":
                return (favItem as FavoriteCrew).crew.photoSrcProd;
            case "Seasons":
                return (favItem as FavoriteSeason).season.photoSrcProd;
            case "Episodes":
                return (favItem as FavoriteEpisode).episode.photoSrcProd;
            default:
                return "";
        }
    };

    const getTitle = () => {
        switch (type) {
            case "Movies":
                return (favItem as FavoriteMovie).movie.title;
            case "Series":
                return (favItem as FavoriteSerie).serie.title;
            case "Actors":
                return (favItem as FavoriteActor).actor.fullname;
            case "Crew":
                return (favItem as FavoriteCrew).crew.fullname;
            case "Seasons":
                return (favItem as FavoriteSeason).season.title;
            case "Episodes":
                return (favItem as FavoriteEpisode).episode.title;
            default:
                return "";
        }
    };

    const handleRemoveBookmark = async (e: React.MouseEvent) => {
        if (isPending) return;

        e.preventDefault();
        e.stopPropagation();

        startTransition(async () => {
            switch (type) {
                case "Movies":
                    await onRemoveBookmarkMovie((favItem as FavoriteMovie).movie);
                    break;
                case "Series":
                    await onRemoveBookmarkSerie((favItem as FavoriteSerie).serie);
                    break;
                case "Actors":
                    await onRemoveBookmarkActor((favItem as FavoriteActor).actor);
                    break;
                case "Crew":
                    await onRemoveBookmarkCrew((favItem as FavoriteCrew).crew);
                    break;
                case "Seasons":
                    await onRemoveBookmarkSeason((favItem as FavoriteSeason).season);
                    break;
                case "Episodes":
                    await onRemoveBookmarkEpisode((favItem as FavoriteEpisode).episode);
                    break;
            }
        });
    };

    return (
        <motion.div
            whileHover={{ scale: 1.05 }}
            transition={{ duration: 0.2, ease: "easeInOut" }}
            style={{ position: "relative", width: 125, borderRadius: "8px", overflow: "hidden" }}
        >
            <Link href={getItemUrl(favItem)!} style={{ textDecoration: "none" }}>
                <Box sx={{ position: "relative", overflow: "hidden" }}>
                    <Image
                        src={getPhotoSrc()}
                        alt={getTitle()}
                        height={170}
                        width={125}
                        style={{
                            borderRadius: "8px",
                            objectFit: "cover",
                            transition: "transform 0.2s ease-in-out",
                        }}
                    />
                    <Box
                        sx={{
                            position: "absolute",
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            background: "linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.7) 100%)",
                            opacity: 0,
                            transition: "opacity 0.2s ease-in-out",
                            display: "flex",
                            flexDirection: "column",
                            justifyContent: "flex-end",
                            padding: 1,
                            "&:hover": {
                                opacity: 1,
                            },
                        }}
                    >
                        <Typography
                            variant="subtitle2"
                            sx={{
                                color: "white",
                                fontWeight: 600,
                                textShadow: "0px 1px 2px rgba(0,0,0,0.5)",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                display: "-webkit-box",
                                WebkitLineClamp: 2,
                                WebkitBoxOrient: "vertical",
                            }}
                        >
                            {getTitle()}
                        </Typography>
                    </Box>
                </Box>
            </Link>
            {userLoggedIn?.id === userInPage?.id && (
                <IconButton
                    onClick={handleRemoveBookmark}
                    size="small"
                    disabled={isPending}
                    sx={{
                        position: "absolute",
                        top: 4,
                        right: 4,
                        backgroundColor: "rgba(0, 0, 0, 0.6)",
                        color: theme.vars.palette.error.main,
                        "&:hover": {
                            backgroundColor: "rgba(0, 0, 0, 0.8)",
                        },
                        "&.Mui-disabled": {
                            backgroundColor: "rgba(0, 0, 0, 0.6)",
                            color: theme.vars.palette.error.main,
                        },
                        width: 24,
                        height: 24,
                        padding: 0,
                    }}
                >
                    {isPending ? (
                        <CircularProgress
                            size={16}
                            sx={{
                                color: theme.vars.palette.error.main,
                            }}
                        />
                    ) : (
                        <ClearIcon
                            sx={{
                                fontSize: 16,
                                transition: "transform 0.2s ease-in-out",
                                "&:hover": {
                                    transform: "rotate(90deg)",
                                },
                            }}
                        />
                    )}
                </IconButton>
            )}
        </motion.div>
    );
};

export default CardItemProfile;


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/PrivateProfileMessage.tsx
================================================
"use client";

import { Box, Paper, Stack, Typography } from "@mui/material";
import LockIcon from "@mui/icons-material/Lock";

export default function PrivateProfileMessage() {
    return (
        <Paper
            elevation={3}
            sx={{
                width: "100%",
                p: 4,
                mt: 3,
                textAlign: "center",
                bgcolor: (theme) => (theme.palette.mode === "dark" ? "background.paper" : "grey.50"),
            }}
        >
            <Stack spacing={3} alignItems="center">
                <LockIcon sx={{ fontSize: 48, color: "text.secondary" }} />
                <Box>
                    <Typography variant="h6" gutterBottom>
                        This Profile is Private
                    </Typography>
                    <Typography variant="body1" color="text.secondary">
                        Follow this user and wait for them to accept your request to see their content.
                    </Typography>
                </Box>
            </Stack>
        </Paper>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ProfileHeader.tsx
================================================
"use client";

import { Avatar, Box } from "@mui/material";

interface ProfileHeaderProps {
    avatar?: { photoSrc: string } | null;
    userName: string;
}

export default function ProfileHeader({ avatar, userName }: ProfileHeaderProps) {
    return (
        <Box
            sx={{
                position: "relative",
                width: { xs: 120, sm: 150 },
                height: { xs: 120, sm: 150 },
                flexShrink: 0,
            }}
        >
            <Avatar
                src={avatar?.photoSrc || "/images/default-avatar.png"}
                alt={userName}
                sx={{
                    width: "100%",
                    height: "100%",
                    border: "4px solid",
                    borderColor: "background.paper",
                    boxShadow: 2,
                }}
            />
        </Box>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ProfileInfo.tsx
================================================
"use client";

import { useState, useTransition, useRef, useEffect } from "react";
import { Box, Typography, Stack, IconButton, TextField, CircularProgress, Collapse } from "@mui/material";
import PersonIcon from "@mui/icons-material/Person";
import InfoIcon from "@mui/icons-material/Info";
import EditIcon from "@mui/icons-material/Edit";
import CheckIcon from "@mui/icons-material/Check";
import CloseIcon from "@mui/icons-material/Close";
import { useTheme } from "@mui/material/styles";
import { updateUserById } from "@/actions/user/user.actions";
import { showToast } from "@/utils/helpers/toast";
import { useRouter } from "next/navigation";
import { motion } from "framer-motion";

interface ProfileInfoProps {
    userInPage: {
        id: number;
        userName: string;
        bio: string;
    };
    userLoggedIn: {
        id: number;
    } | null;
}

export default function ProfileInfo({ userInPage, userLoggedIn }: ProfileInfoProps) {
    const theme = useTheme();
    const router = useRouter();

    const [isEditingUserName, setIsEditingUserName] = useState(false);
    const [isEditingBio, setIsEditingBio] = useState(false);
    const [userNamePending, startUserNameTransition] = useTransition();
    const [bioPending, startBioTransition] = useTransition();
    const [userName, setUserName] = useState(userInPage.userName);
    const [bio, setBio] = useState(userInPage.bio);
    const [isSaving, setIsSaving] = useState(false);

    const userNameRef = useRef<HTMLInputElement>(null);
    const bioRef = useRef<HTMLTextAreaElement>(null);

    useEffect(() => {
        if (isEditingUserName) {
            userNameRef.current?.focus();
        }
    }, [isEditingUserName]);

    useEffect(() => {
        if (isEditingBio) {
            bioRef.current?.focus();
        }
    }, [isEditingBio]);

    const handleEditUserName = () => {
        setIsEditingUserName(true);
    };

    const handleCancelEditUserName = () => {
        setIsEditingUserName(false);
        setUserName(userInPage.userName);
    };

    const handleEditBio = () => {
        setIsEditingBio(true);
    };

    const handleCancelEditBio = () => {
        setIsEditingBio(false);
        setBio(userInPage.bio);
    };

    const handleSaveUserName = async () => {
        if (!userLoggedIn || isSaving) return;
        setIsSaving(true);

        startUserNameTransition(async () => {
            try {
                await updateUserById({ userName, bio: userInPage.bio }, Number(userInPage.id));
                router.refresh();
                showToast("success", "Username updated successfully!");
                setIsEditingUserName(false);
            } catch (error: any) {
                console.error(`Error updating user info: ${error.message}`);
                showToast("error", error.message || "Error updating user info");
            } finally {
                setIsSaving(false);
            }
        });
    };

    const handleSaveBio = async () => {
        if (!userLoggedIn || isSaving) return;
        setIsSaving(true);

        startBioTransition(async () => {
            try {
                await updateUserById({ userName: userInPage.userName, bio }, Number(userInPage.id));
                router.refresh();
                showToast("success", "Bio updated successfully!");
                setIsEditingBio(false);
            } catch (error: any) {
                console.error(`Error updating user info: ${error.message}`);
                showToast("error", error.message || "Error updating user info");
            } finally {
                setIsSaving(false);
            }
        });
    };

    if (!userLoggedIn || userLoggedIn.id !== userInPage.id) {
        return (
            <Stack spacing={1} alignItems="center">
                <Stack direction="row" alignItems="center" spacing={1}>
                    <PersonIcon color="action" />
                    <Typography variant="h6" fontWeight={500} align="center">
                        {userInPage.userName}
                    </Typography>
                </Stack>
                <Stack direction="row" alignItems="center" spacing={1}>
                    <InfoIcon color="action" />
                    <Typography variant="body2" color="text.secondary" align="center">
                        {userInPage.bio}
                    </Typography>
                </Stack>
            </Stack>
        );
    }

    return (
        <Stack spacing={1} alignItems="center">
            <Stack direction="row" alignItems="center" spacing={1}>
                <PersonIcon color="action" />
                {isEditingUserName ? (
                    <motion.div
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 20 }}
                        transition={{ duration: 0.2 }}
                    >
                        <TextField
                            inputRef={userNameRef}
                            value={userName}
                            onChange={(e) => setUserName(e.target.value)}
                            variant="standard"
                            size="small"
                            sx={{
                                "& .MuiInputBase-input": {
                                    textAlign: "center",
                                    fontSize: "1.2rem",
                                    fontWeight: 500,
                                },
                            }}
                        />
                    </motion.div>
                ) : (
                    <>
                        <Typography color="text.secondary">Username:</Typography>
                        <Typography variant="h6" fontWeight={500} align="center">
                            {userInPage.userName}
                        </Typography>
                    </>
                )}
                {!isEditingUserName && (
                    <IconButton
                        onClick={handleEditUserName}
                        sx={{
                            color: theme.palette.grey[500],
                            "&:hover": {
                                color: theme.palette.primary.main,
                                transform: "scale(1.1)",
                            },
                        }}
                    >
                        <EditIcon />
                    </IconButton>
                )}
                {isEditingUserName && (
                    <Stack direction="row" spacing={1}>
                        <IconButton
                            onClick={handleSaveUserName}
                            disabled={userNamePending}
                            sx={{
                                color: "success.main",
                                "&:hover": {
                                    color: "success.dark",
                                    transform: "scale(1.1)",
                                },
                            }}
                        >
                            {userNamePending ? <CircularProgress size={20} color="inherit" /> : <CheckIcon />}
                        </IconButton>
                        <IconButton
                            onClick={handleCancelEditUserName}
                            disabled={userNamePending}
                            sx={{
                                color: "error.main",
                                "&:hover": {
                                    color: "error.dark",
                                    transform: "scale(1.1)",
                                },
                            }}
                        >
                            <CloseIcon />
                        </IconButton>
                    </Stack>
                )}
            </Stack>
            <Stack direction="row" alignItems="center" spacing={1}>
                <InfoIcon color="action" />
                {isEditingBio ? (
                    <motion.div
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 20 }}
                        transition={{ duration: 0.2 }}
                    >
                        <TextField
                            inputRef={bioRef}
                            value={bio}
                            onChange={(e) => setBio(e.target.value)}
                            variant="standard"
                            multiline
                            fullWidth
                            size="small"
                            sx={{
                                "& .MuiInputBase-input": {
                                    textAlign: "center",
                                },
                            }}
                        />
                    </motion.div>
                ) : (
                    <>
                        <Typography color="text.secondary">Bio:</Typography>
                        <Typography variant="body2" align="center">
                            {userInPage.bio}
                        </Typography>
                    </>
                )}
                {!isEditingBio && (
                    <IconButton
                        onClick={handleEditBio}
                        sx={{
                            color: theme.palette.grey[500],
                            "&:hover": {
                                color: theme.palette.primary.main,
                                transform: "scale(1.1)",
                            },
                        }}
                    >
                        <EditIcon />
                    </IconButton>
                )}
                {isEditingBio && (
                    <Stack direction="row" spacing={1}>
                        <IconButton
                            onClick={handleSaveBio}
                            disabled={bioPending}
                            sx={{
                                color: "success.main",
                                "&:hover": {
                                    color: "success.dark",
                                    transform: "scale(1.1)",
                                },
                            }}
                        >
                            {bioPending ? <CircularProgress size={20} color="inherit" /> : <CheckIcon />}
                        </IconButton>
                        <IconButton
                            onClick={handleCancelEditBio}
                            disabled={bioPending}
                            sx={{
                                color: "error.main",
                                "&:hover": {
                                    color: "error.dark",
                                    transform: "scale(1.1)",
                                },
                            }}
                        >
                            <CloseIcon />
                        </IconButton>
                    </Stack>
                )}
            </Stack>
        </Stack>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ProfileSearchBar.tsx
================================================
"use client";

import { Box, InputAdornment, TextField, CircularProgress, IconButton, ClickAwayListener } from "@mui/material";
import SearchIcon from "@mui/icons-material/Search";
import ClearIcon from "@mui/icons-material/Clear";
import { useCallback, useState, useMemo, useEffect } from "react";
import { useDebounce } from "@/hooks/useDebounce";
import { Options, useQueryState } from "nuqs";

interface IProfileSearchBar {
    search: string;
    page: number;
    mainTab: string;
    setPage: (value: string | ((old: string) => string | null) | null, options?: Options) => Promise<URLSearchParams>;
    setSearch: (value: string | ((old: string) => string | null) | null, options?: Options) => Promise<URLSearchParams>;
}

export default function ProfileSearchBar({ search, page, mainTab, setPage, setSearch }: IProfileSearchBar) {
    const [subTab, setSubTab] = useQueryState("subtab", {
        defaultValue: "movies",
        parse: (value) => value || "movies",
        history: "push",
        shallow: false,
    });

    const [inputValue, setInputValue] = useState(search);
    const [isSearching, setIsSearching] = useState(false);
    const debouncedSearch = useDebounce(inputValue, 50);

    const getPlaceholder = useMemo(() => {
        const contentType = subTab.toLowerCase();

        switch (mainTab) {
            case "reviews":
                return `Search ${contentType} reviews...`;
            case "upvotes":
                return `Search upvoted ${contentType} reviews...`;
            case "downvotes":
                return `Search downvoted ${contentType} reviews...`;
            default:
                return `Search ${contentType} bookmarks...`;
        }
    }, [mainTab, subTab]);

    const updateSearchParams = useCallback(() => {
        setIsSearching(true);

        if (debouncedSearch.trim()) {
            setSearch(debouncedSearch.trim());
            setPage("1");
        } else {
            setSearch(null);
            setPage("1");
        }

        setIsSearching(false);
    }, [debouncedSearch]);

    useEffect(() => {
        if (debouncedSearch !== search) {
            updateSearchParams();
        }
    }, [debouncedSearch]);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
    };

    const handleClear = () => {
        setInputValue("");
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        updateSearchParams();
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === "Enter") {
            e.preventDefault();
            updateSearchParams();
        }
    };

    return (
        <ClickAwayListener onClickAway={() => {}}>
            <Box sx={{ width: "100%", display: "flex", justifyContent: "center", mb: 2 }}>
                <form onSubmit={handleSubmit} style={{ width: "100%", maxWidth: "600px" }}>
                    <TextField
                        fullWidth
                        variant="outlined"
                        placeholder={getPlaceholder}
                        value={inputValue}
                        onChange={handleInputChange}
                        onKeyDown={handleKeyDown}
                        slotProps={{
                            input: {
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <IconButton type="submit" size="small" aria-label="search">
                                            <SearchIcon color="action" />
                                        </IconButton>
                                    </InputAdornment>
                                ),
                                endAdornment: (
                                    <InputAdornment position="end">
                                        {isSearching ? (
                                            <CircularProgress size={20} color="inherit" />
                                        ) : inputValue ? (
                                            <IconButton
                                                onClick={handleClear}
                                                size="small"
                                                aria-label="clear search"
                                                edge="end"
                                            >
                                                <ClearIcon />
                                            </IconButton>
                                        ) : null}
                                    </InputAdornment>
                                ),
                            },
                        }}
                        sx={{
                            "& .MuiOutlinedInput-root": {
                                borderRadius: 2,
                            },
                        }}
                    />
                </form>
            </Box>
        </ClickAwayListener>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ProfileStats.tsx
================================================
"use client";

import { Stack, Typography, Box } from "@mui/material";
import { useRouter } from "next/navigation";
import PeopleIcon from "@mui/icons-material/People";
import PersonIcon from "@mui/icons-material/Person";

interface ProfileStatsProps {
    userInPage: {
        id: number;
        userName: string;
    };
    followersCount: number;
    followingCount: number;
    canClickFollow: boolean;
}

export default function ProfileStats({
    userInPage,
    followersCount,
    followingCount,
    canClickFollow,
}: ProfileStatsProps) {
    const router = useRouter();

    return (
        <Stack spacing={2} alignItems="flex-end" sx={{ ml: "auto", mr: 2 }}>
            <Box
                onClick={() => {
                    if (canClickFollow) {
                        router.push(`/users/${userInPage.id}/${userInPage.userName}/followers`);
                    }
                }}
                sx={{
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                    cursor: canClickFollow ? "pointer" : "default",
                    "&:hover": canClickFollow
                        ? {
                              "& .MuiTypography-root, & .MuiSvgIcon-root": {
                                  color: "primary.main",
                              },
                          }
                        : undefined,
                }}
            >
                <PeopleIcon color="action" />
                <Typography variant="h6" color="text.primary" sx={{ fontWeight: 500 }}>
                    Followers:
                </Typography>
                <Typography variant="h6" color="text.primary" sx={{ fontWeight: 600 }}>
                    {followersCount}
                </Typography>
            </Box>
            <Box
                onClick={() => {
                    if (canClickFollow) {
                        router.push(`/users/${userInPage.id}/${userInPage.userName}/following`);
                    }
                }}
                sx={{
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                    cursor: canClickFollow ? "pointer" : "default",
                    "&:hover": canClickFollow
                        ? {
                              "& .MuiTypography-root, & .MuiSvgIcon-root": {
                                  color: "primary.main",
                              },
                          }
                        : undefined,
                }}
            >
                <PersonIcon color="action" />
                <Typography variant="h6" color="text.primary" sx={{ fontWeight: 500 }}>
                    Following:
                </Typography>
                <Typography variant="h6" color="text.primary" sx={{ fontWeight: 600 }}>
                    {followingCount}
                </Typography>
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ProfileTabs.tsx
================================================
"use client";

import { Tab, Tabs, Paper } from "@mui/material";
import { Options, useQueryState } from "nuqs";
import { JSX } from "react";

interface ProfileTabsProps {
    mainTabs: any[];
    subTabs: Record<string, string[]>;
    currentMainTab: number;
    currentSubTab: number;
    getSubTabIcon: (label: string) => JSX.Element;
    setMainTab: (
        value: string | ((old: string) => string | null) | null,
        options?: Options,
    ) => Promise<URLSearchParams>;
    setSubTab: (value: string | ((old: string) => string | null) | null, options?: Options) => Promise<URLSearchParams>;
}

export default function ProfileTabs({
    mainTabs,
    subTabs,
    getSubTabIcon,
    currentMainTab,
    currentSubTab,
    setMainTab,
    setSubTab,
}: ProfileTabsProps) {
    const [search, setSearch] = useQueryState("search", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => Number(value) || "1",
        history: "push",
        shallow: false,
    });

    const updateURL = (mainTabValue: string, subTabValue: string) => {
        const cleanSubTabValue = subTabValue.toLowerCase().replace(/\s+/g, "");
        setPage(null);
        setSearch(null);
        setMainTab(mainTabValue);
        setSubTab(cleanSubTabValue);
    };

    const handleMainTabChange = (_: React.SyntheticEvent, newValue: number) => {
        const mainTabParam = mainTabs[newValue].param;
        const firstSubTab = subTabs[mainTabParam as keyof typeof subTabs][0];
        updateURL(mainTabParam, firstSubTab);
    };

    const handleSubTabChange = (_: React.SyntheticEvent, newValue: number) => {
        const mainTabParam = mainTabs[currentMainTab].param;
        const selectedSubTab = subTabs[mainTabParam as keyof typeof subTabs][newValue];
        updateURL(mainTabParam, selectedSubTab);
    };

    return (
        <Paper
            elevation={1}
            sx={{
                borderRadius: 2,
                overflow: "hidden",
                bgcolor: "background.paper",
                transition: "all 0.3s ease",
                "&:hover": {
                    boxShadow: (theme) => theme.shadows[3],
                },
            }}
        >
            <Tabs
                value={currentMainTab}
                onChange={handleMainTabChange}
                variant="scrollable"
                scrollButtons="auto"
                allowScrollButtonsMobile
                sx={{
                    borderBottom: 2,
                    borderColor: "divider",
                    "& .MuiTabs-flexContainer": {
                        display: "flex",
                        "& > button": {
                            flex: 1,
                            maxWidth: "none",
                        },
                    },
                    "& .MuiTab-root": {
                        minHeight: 48,
                        textTransform: "none",
                        fontSize: { xs: "0.875rem", sm: "0.875rem" },
                        transition: "all 0.2s",
                        borderRight: "1px solid",
                        borderColor: "divider",
                        px: { xs: 1, sm: 2 },
                        py: 1,
                        margin: 0,
                        minWidth: 0,
                        "&:hover": {
                            bgcolor: "action.hover",
                            color: "primary.main",
                        },
                        "&:last-child": {
                            borderRight: "none",
                        },
                        "& .MuiSvgIcon-root": {
                            fontSize: "1.25rem",
                        },
                    },
                    "& .Mui-selected": {
                        fontWeight: 600,
                        bgcolor: "action.selected",
                        "&:hover": {
                            bgcolor: "action.selected",
                        },
                    },
                    "& .MuiTabs-indicator": {
                        height: 2,
                    },
                }}
            >
                {mainTabs.map((tab) => (
                    <Tab key={tab.label} icon={tab.icon} label={tab.label} iconPosition="start" sx={{ gap: 0.5 }} />
                ))}
            </Tabs>
            <Tabs
                value={currentSubTab}
                onChange={handleSubTabChange}
                variant="scrollable"
                scrollButtons="auto"
                allowScrollButtonsMobile
                sx={{
                    minHeight: 48,
                    borderBottom: 1,
                    borderColor: "divider",
                    "& .MuiTabs-flexContainer": {
                        display: "flex",
                        "& > button": {
                            flex: 1,
                            maxWidth: "none",
                        },
                    },
                    "& .MuiTab-root": {
                        minHeight: 48,
                        textTransform: "none",
                        fontSize: { xs: "0.875rem", sm: "0.875rem" },
                        px: { xs: 1, sm: 2 },
                        py: 1,
                        margin: 0,
                        minWidth: 0,
                        transition: "all 0.2s",
                        "&:hover": {
                            bgcolor: "action.hover",
                            color: "primary.main",
                        },
                    },
                    "& .Mui-selected": {
                        fontWeight: 500,
                        bgcolor: "action.selected",
                        "&:hover": {
                            bgcolor: "action.selected",
                        },
                    },
                    "& .MuiTabs-indicator": {
                        height: 2,
                    },
                }}
            >
                {subTabs[mainTabs[currentMainTab].param as keyof typeof subTabs].map((label) => (
                    <Tab key={label} label={label} icon={getSubTabIcon(label)} iconPosition="start" sx={{ gap: 0.5 }} />
                ))}
            </Tabs>
        </Paper>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/ReviewItemProfile.tsx
================================================
"use client";

import { Avatar, Box, Card, CardContent, Rating, Stack, Typography } from "@mui/material";
import { motion } from "framer-motion";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import dynamic from "next/dynamic";
import "react-quill-new/dist/quill.snow.css";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";

const ReactQuill = dynamic(() => import("react-quill-new"), { ssr: false });

interface ReviewItemProfileProps {
    review: any;
    type: any;
    variant?: "upvote" | "downvote";
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
}

export default function ReviewItemProfile({ review, type, userLoggedIn }: ReviewItemProfileProps) {
    const getContentInfo = () => {
        switch (type) {
            case "movie":
                return {
                    title: review.movie.title,
                    link: `/movies/${review.movie.id}/${review.movie.title.toLowerCase().replace(/\s+/g, "-")}`,
                };
            case "serie":
                return {
                    title: review.serie.title,
                    link: `/series/${review.serie.id}/${review.serie.title.toLowerCase().replace(/\s+/g, "-")}`,
                };
            case "season":
                return {
                    title: review.season.title,
                    link: `/seasons/${review.season.id}/${review.season.title.toLowerCase().replace(/\s+/g, "-")}`,
                };
            case "episode":
                return {
                    title: review.episode.title,
                    link: `/episodes/${review.episode.id}/${review.episode.title.toLowerCase().replace(/\s+/g, "-")}`,
                };
            default:
                return { title: "", link: "" };
        }
    };

    const { title, link } = getContentInfo();

    if (!title || !link) return null;

    const modules = {
        toolbar: false,
    };

    return (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.2 }}
        >
            <Card
                elevation={0}
                sx={{
                    backgroundColor: "background.paper",
                    borderRadius: 2,
                    overflow: "hidden",
                    transition: "transform 0.2s ease-in-out",
                    "&:hover": {
                        transform: "translateY(-4px)",
                    },
                    width: "100%",
                    maxWidth: "800px",
                    cursor: "pointer",
                }}
            >
                <CardContent>
                    <Stack spacing={2}>
                        <Link href={link} style={{ textDecoration: "none" }}>
                            <Typography
                                variant="h6"
                                sx={{
                                    color: "primary.main",
                                    "&:hover": { textDecoration: "underline" },
                                }}
                            >
                                {title}
                            </Typography>
                        </Link>
                        <Box
                            sx={{
                                "& .quill": {
                                    border: "none",
                                    "& .ql-container": {
                                        border: "none",
                                    },
                                    "& .ql-editor": {
                                        padding: 0,
                                        "& p": {
                                            color: "text.secondary",
                                        },
                                    },
                                },
                            }}
                        >
                            <ReactQuill value={review.content} readOnly={true} modules={modules} theme="snow" />
                        </Box>
                        <Stack
                            direction="row"
                            spacing={2}
                            alignItems="center"
                            sx={{
                                width: "100%",
                                justifyContent: "space-between",
                                flexWrap: "wrap",
                                gap: 2,
                            }}
                        >
                            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                                <Rating
                                    value={review.rating}
                                    max={10}
                                    readOnly
                                    precision={0.5}
                                    sx={{ "& .MuiRating-icon": { fontSize: "1.2rem" } }}
                                />
                                <Typography variant="body2" color="text.secondary">
                                    {review.rating.toFixed(1)}/10
                                </Typography>
                            </Box>
                            <Stack direction="row" spacing={2}>
                                <Stack direction="row" spacing={0.5} alignItems="center">
                                    <ThumbUpIcon
                                        sx={{
                                            fontSize: "1.2rem",
                                            color: "success.main",
                                        }}
                                    />
                                    <Typography variant="body2" color="text.secondary">
                                        {review._count?.upvotes || 0}
                                    </Typography>
                                </Stack>
                                <Stack direction="row" spacing={0.5} alignItems="center">
                                    <ThumbDownIcon
                                        sx={{
                                            fontSize: "1.2rem",
                                            color: "error.main",
                                        }}
                                    />
                                    <Typography variant="body2" color="text.secondary">
                                        {review._count?.downvotes || 0}
                                    </Typography>
                                </Stack>
                            </Stack>
                        </Stack>
                        <Stack direction="row" spacing={1} alignItems="center" sx={{ color: "text.secondary" }}>
                            <Avatar
                                src={review.user?.avatar?.photoSrc || "/default-avatar.jpg"}
                                alt={review.user?.userName || "User"}
                                sx={{ width: 24, height: 24 }}
                            />
                            <Stack direction="row" spacing={0.5} alignItems="center">
                                <Typography variant="body2">{review.user?.userName || "Anonymous"}</Typography>
                                {userLoggedIn?.id === review.userId && (
                                    <Typography
                                        variant="body2"
                                        sx={{
                                            color: "#2ecc71",
                                            fontWeight: "bold",
                                            backgroundColor: "rgba(46, 204, 113, 0.1)",
                                            px: 0.8,
                                            py: 0.2,
                                            borderRadius: 1,
                                        }}
                                    >
                                        (You)
                                    </Typography>
                                )}
                            </Stack>
                            <Typography variant="body2">
                                {formatDistanceToNow(new Date(review.createdAt), {
                                    addSuffix: true,
                                })}
                            </Typography>
                        </Stack>
                    </Stack>
                </CardContent>
            </Card>
        </motion.div>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/SocialSection.tsx
================================================
"use client";

import { useState, useTransition } from "react";
import {
    Box,
    Button,
    IconButton,
    Typography,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    useTheme,
    Stack,
    CircularProgress,
    Tooltip,
} from "@mui/material";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import CheckIcon from "@mui/icons-material/Check";
import CloseIcon from "@mui/icons-material/Close";
import PersonAddIcon from "@mui/icons-material/PersonAdd";
import PersonRemoveIcon from "@mui/icons-material/PersonRemove";
import { showToast } from "@/utils/helpers/toast";
import { useRouter } from "next/navigation";
import { follow, unfollow } from "@/actions/user/userFollow.actions";
import MessageIcon from "@mui/icons-material/Message";
import Link from "next/link";

interface SocialSectionProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    userInPage: {
        id: number;
        userName: string;
        email: string;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
        followers: any[];
        following: any[];
        isFollowed?: boolean;
        isFollowedStatus?: string | null;
    };
    userPendingFollowers: any;
    userLoggedInId?: number;
}

export default function SocialSection({
    userLoggedIn,
    userInPage,
    userPendingFollowers,
    userLoggedInId,
}: SocialSectionProps) {
    const theme = useTheme();
    const router = useRouter();

    const [isPending, startTransition] = useTransition();

    const handleFollowUser = async () => {
        if (!userLoggedIn || !userInPage || isPending) return;

        startTransition(async () => {
            try {
                await follow(Number(userLoggedIn.id), Number(userInPage.id));
                showToast("success", "Follow request sent successfully!");
                router.refresh();
            } catch (error: any) {
                console.error(`Error following user: ${error.message}`);
                showToast("error", error.message || "Error following user");
            }
        });
    };

    const handleUnfollowUser = async () => {
        if (!userLoggedIn || !userInPage || isPending) return;

        startTransition(async () => {
            try {
                await unfollow(Number(userLoggedIn.id), Number(userInPage.id));
                showToast("success", "Unfollowed successfully!");
                router.refresh();
            } catch (error: any) {
                console.error(`Error unfollowing user: ${error.message}`);
                showToast("error", error.message || "Error unfollowing user");
            }
        });
    };

    const handleFollowAction = async () => {
        if (!userInPage.isFollowed) {
            await handleFollowUser();
        } else {
            await handleUnfollowUser();
        }
    };

    const getFollowButtonText = () => {
        if (userInPage.isFollowed) {
            if (userInPage.isFollowedStatus === "pending") {
                return "Requested";
            }

            return "Following";
        }

        return "Follow";
    };

    const getFollowButtonIcon = () => {
        if (userInPage.isFollowed) {
            return <PersonRemoveIcon />;
        }

        return <PersonAddIcon />;
    };

    const handleMessageUser = () => {
        if (!userLoggedInId || !userInPage.isFollowed || userInPage.isFollowedStatus !== "accepted") return;
        router.push(`/messages?section=compose&selectedUser=${userInPage.id}`);
    };

    return (
        <Box>
            {userLoggedIn && userLoggedIn.id !== userInPage.id && (
                <Stack direction="row" spacing={1} alignItems="center">
                    <Button
                        variant={userInPage.isFollowed ? "outlined" : "contained"}
                        startIcon={isPending ? <CircularProgress size={20} color="inherit" /> : getFollowButtonIcon()}
                        size="small"
                        onClick={handleFollowAction}
                        disabled={isPending}
                        sx={{
                            textTransform: "none",
                            borderRadius: 2,
                            fontSize: "0.9rem",
                            fontWeight: 500,
                            boxShadow: 1,
                            bgcolor: "background.paper",
                            color: theme.vars.palette.greyAccent.main,
                            borderWidth: 2,
                            height: 35,
                            minWidth: 100,
                            "&.Mui-disabled": {
                                bgcolor: "background.paper",
                                opacity: 0.7,
                            },
                        }}
                    >
                        {isPending ? "Processing..." : getFollowButtonText()}
                    </Button>
                    {userInPage.isFollowed && userInPage.isFollowedStatus === "accepted" && (
                        <Tooltip title="Send Message" placement="top">
                            <IconButton
                                onClick={handleMessageUser}
                                disabled={isPending}
                                size="small"
                                sx={{
                                    color: theme.vars.palette.greyAccent.main,
                                    "&:hover": {
                                        color: theme.vars.palette.primary.main,
                                        transform: "scale(1.1)",
                                    },
                                }}
                            >
                                <MessageIcon fontSize="small" />
                            </IconButton>
                        </Tooltip>
                    )}
                </Stack>
            )}
            {userLoggedIn && userLoggedIn.id === userInPage.id && userPendingFollowers.items.length > 0 && (
                <Box sx={{ mt: 2, maxWidth: "100%" }}>
                    <Link href={`/users/${userInPage.id}/${userInPage.userName}/followersRequests`}>
                        <Button
                            variant="outlined"
                            sx={{
                                textTransform: "none",
                                borderRadius: 2,
                                fontSize: "0.9rem",
                                fontWeight: 500,
                                boxShadow: 1,
                                bgcolor: "background.paper",
                                color: theme.vars.palette.greyAccent.main,
                                borderWidth: 2,
                                height: 35,
                                minWidth: 100,
                                "&:hover": {
                                    bgcolor: "background.default",
                                },
                            }}
                        >
                            Follow Requests ({userPendingFollowers.items.length})
                        </Button>
                    </Link>
                </Box>
            )}
        </Box>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/TabContent.tsx
================================================
"use client";

import { Box, Typography, Pagination, Stack } from "@mui/material";
import CardItemProfile, { FavoriteType } from "./CardItemProfile";
import ReviewItemProfile from "./ReviewItemProfile";
import { motion } from "framer-motion";
import ProfileSearchBar from "./ProfileSearchBar";
import { useQueryState } from "nuqs";

interface ITabContentProps {
    type: string;
    userLoggedIn: any;
    userInPage: any;
    additionalData: any;
    mainTab: string;
}

export default function TabContent({ type, userLoggedIn, userInPage, additionalData, mainTab }: ITabContentProps) {
    const [search, setSearch] = useQueryState("search", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalItems = additionalData.total || 0;
    const totalPages = Math.ceil(totalItems / perPage);

    const startIndex = (Number(page) - 1) * perPage + 1;
    const endIndex = Math.min(Number(page) * perPage, totalItems);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(String(value));
    };

    const getReviewType = (item: any): "movie" | "serie" | "season" | "episode" | "actor" | "crew" => {
        if (item.movie || item.movieId) return "movie";
        if (item.serie || item.serieId) return "serie";
        if (item.season || item.seasonId) return "season";
        if (item.episode || item.episodeId) return "episode";
        if (item.actor || item.actorId) return "actor";
        if (item.crew || item.crewId) return "crew";

        return "movie";
    };

    const getReviewVotesType = (
        item: any,
    ): "movieReview" | "serieReview" | "seasonReview" | "episodeReview" | "actorReview" | "crewReview" => {
        if (item.movieReview || item.movieReviewId) return "movieReview";
        if (item.serieReview || item.serieReviewId) return "serieReview";
        if (item.seasonReview || item.seasonReviewId) return "seasonReview";
        if (item.episodeReview || item.episodeReviewId) return "episodeReview";
        if (item.actorReview || item.actorReviewId) return "actorReview";
        if (item.crewReview || item.crewReviewId) return "crewReview";

        return "movieReview";
    };

    const formatTitle = (text: string) =>
        text
            .split("")
            .map((char: string) => (char === " " ? "-" : char))
            .join("");

    const getItemUrl = (favItem: any) => {
        switch (type.toLowerCase()) {
            case "movies":
                return `/movies/${favItem.movie.id}/${formatTitle(favItem.movie.title)}`;
            case "series":
                return `/series/${favItem.serie.id}/${formatTitle(favItem.serie.title)}`;
            case "actors":
                return `/actors/${favItem.actor.id}/${formatTitle(favItem.actor.fullname)}`;
            case "crew":
                return `/crew/${favItem.crew.id}/${formatTitle(favItem.crew.fullname)}`;
            case "seasons": {
                const season = favItem.season;

                if (!season?.serie) {
                    return `/seasons/${season.id}/${formatTitle(season.title)}`;
                }

                return `/series/${season.serie.id}/${formatTitle(season.serie.title)}/seasons/${season.id}/${formatTitle(season.title)}`;
            }
            case "episodes": {
                const episode = favItem.episode;
                const season = episode.season;

                if (!season?.serie) {
                    return `/episodes/${episode.id}/${formatTitle(episode.title)}`;
                }

                return `/series/${season.serie.id}/${formatTitle(season.serie.title)}/seasons/${season.id}/${formatTitle(season.title)}/episodes/${episode.id}/${formatTitle(episode.title)}`;
            }
            default:
                return undefined;
        }
    };

    const getEmptyStateMessage = () => {
        if (search) {
            switch (mainTab) {
                case "reviews":
                    return `No ${type.toLowerCase()} reviews found matching "${search}"`;
                case "upvotes":
                    return `No upvoted ${type.toLowerCase()} reviews found matching "${search}"`;
                case "downvotes":
                    return `No downvoted ${type.toLowerCase()} reviews found matching "${search}"`;
                default:
                    return `No ${type.toLowerCase()} bookmarks found matching "${search}"`;
            }
        }

        switch (mainTab) {
            case "reviews":
                return `No ${type.toLowerCase()} have been reviewed yet`;
            case "upvotes":
                return `No ${type.toLowerCase()} reviews have been upvoted yet`;
            case "downvotes":
                return `No ${type.toLowerCase()} reviews have been downvoted yet`;
            default:
                return `No ${type.toLowerCase()} have been bookmarked yet`;
        }
    };

    return (
        <Box
            component={motion.div}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
            sx={{ width: "100%" }}
        >
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    gap: 2,
                    alignItems: "center",
                    width: "100%",
                }}
            >
                <ProfileSearchBar
                    search={search}
                    page={Number(page)}
                    mainTab={mainTab}
                    setPage={setPage}
                    setSearch={setSearch}
                />
                {totalItems > 0 && (
                    <Box
                        sx={{
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                            width: "100%",
                            px: { xs: 1, sm: 2 },
                            mb: 1,
                        }}
                    >
                        <Typography variant="body2" color="text.secondary">
                            Showing {startIndex}-{endIndex} of {totalItems} items
                            {search && ` for "${search}"`}
                        </Typography>
                    </Box>
                )}

                <Box
                    sx={{
                        display: "grid",
                        gridTemplateColumns: {
                            xs:
                                mainTab === "reviews" || mainTab === "upvotes" || mainTab === "downvotes"
                                    ? "repeat(auto-fill, minmax(300px, 1fr))"
                                    : "repeat(auto-fill, minmax(100px, 1fr))",
                            sm:
                                mainTab === "reviews" || mainTab === "upvotes" || mainTab === "downvotes"
                                    ? "repeat(2, minmax(350px, 1fr))"
                                    : "repeat(3, minmax(120px, 1fr))",
                            md:
                                mainTab === "reviews" || mainTab === "upvotes" || mainTab === "downvotes"
                                    ? "repeat(3, minmax(300px, 1fr))"
                                    : "repeat(5, minmax(140px, 1fr))",
                        },
                        gap: { xs: 1, sm: 1.5 },
                        justifyContent: "center",
                        width: "100%",
                        maxWidth: "1200px",
                        margin: "0 auto",
                        minHeight: additionalData.items.length === 0 ? "auto" : "200px",
                        px: { xs: 1, sm: 2 },
                    }}
                >
                    {additionalData.items.length > 0 ? (
                        additionalData.items.map((item: any, index: number) => {
                            if (mainTab === "reviews") {
                                const reviewType = getReviewType(item);

                                const reviewItem = {
                                    ...item,
                                    ...item[reviewType],
                                    user: userInPage,
                                    _count: {
                                        upvotes: item._count?.upvotes || 0,
                                        downvotes: item._count?.downvotes || 0,
                                    },
                                };

                                return (
                                    <ReviewItemProfile
                                        key={index}
                                        review={reviewItem}
                                        type={reviewType}
                                        variant="upvote"
                                        userLoggedIn={userLoggedIn}
                                    />
                                );
                            } else if (mainTab === "upvotes" || mainTab === "downvotes") {
                                const reviewType = getReviewVotesType(item);

                                const reviewItem = {
                                    ...item[reviewType],
                                    user: item[reviewType].user,
                                    _count: {
                                        upvotes: item[reviewType]._count?.upvotes || 0,
                                        downvotes: item[reviewType]._count?.downvotes || 0,
                                    },
                                };

                                return (
                                    <ReviewItemProfile
                                        key={index}
                                        review={reviewItem}
                                        type={getReviewType(item)}
                                        variant={mainTab === "upvotes" ? "upvote" : "downvote"}
                                        userLoggedIn={userLoggedIn}
                                    />
                                );
                            }
                            return (
                                <CardItemProfile
                                    key={index}
                                    favItem={item}
                                    type={type as FavoriteType}
                                    getItemUrl={getItemUrl}
                                    userLoggedIn={userLoggedIn}
                                    userInPage={userInPage}
                                />
                            );
                        })
                    ) : (
                        <Box
                            sx={{
                                gridColumn: "1/-1",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                flexDirection: "column",
                                gap: 1,
                                py: { xs: 4, sm: 6 },
                                minHeight: "200px",
                            }}
                        >
                            <Typography variant="h6" color="text.secondary" textAlign="center">
                                {getEmptyStateMessage()}
                            </Typography>
                            {search && (
                                <Typography variant="body2" color="text.secondary" textAlign="center">
                                    Try adjusting your search to find what you&apos;re looking for
                                </Typography>
                            )}
                        </Box>
                    )}
                </Box>
                {totalItems > 0 && (
                    <Stack spacing={2} alignItems="center" sx={{ mt: { xs: 1, sm: 2 } }}>
                        <Pagination
                            count={Math.max(1, totalPages)}
                            page={Number(page)}
                            onChange={handlePageChange}
                            size="large"
                            shape="rounded"
                            showFirstButton
                            showLastButton
                            disabled={totalItems === 0}
                        />
                    </Stack>
                )}
            </Box>
        </Box>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/UserListItem.tsx
================================================
"use client";

import { Avatar, Box, Button, Paper, Stack, Typography } from "@mui/material";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { follow, unfollow } from "@/actions/user/userFollow.actions";
import { showToast } from "@/utils/helpers/toast";
import PersonAddIcon from "@mui/icons-material/PersonAdd";
import PersonRemoveIcon from "@mui/icons-material/PersonRemove";
import { useTransition } from "react";
import CircularProgress from "@mui/material/CircularProgress";

interface UserListItemProps {
    user: {
        id: number;
        userName: string;
        bio: string;
        avatar?: { photoSrc: string } | null;
        followStatus?: {
            isFollowing: boolean;
            state: string | null;
        } | null;
    };
    userLoggedIn: {
        id: number;
        userName: string;
    } | null;
}

interface ButtonColors {
    main: string;
    hover: string;
}

const getButtonColors = (type: "follow" | "unfollow" | "pending"): ButtonColors => {
    switch (type) {
        case "follow":
            return {
                main: "#4cceac",
                hover: "#3da58a",
            };
        case "unfollow":
            return {
                main: "#db4f4a",
                hover: "#af3f3b",
            };
        case "pending":
            return {
                main: "#6870fa",
                hover: "#535ac8",
            };
    }
};

export default function UserListItem({ user, userLoggedIn }: UserListItemProps) {
    const router = useRouter();
    const [isPending, startTransition] = useTransition();

    const getButtonConfig = () => {
        if (!user.followStatus) {
            return {
                text: "Follow",
                icon: <PersonAddIcon />,
                variant: "contained",
                action: "follow",
                colorType: "follow" as const,
            };
        }

        if (user.followStatus.state === "pending") {
            return {
                text: "Cancel Request",
                icon: <PersonRemoveIcon />,
                variant: "outlined",
                action: "unfollow",
                colorType: "pending" as const,
            };
        }

        if (user.followStatus.isFollowing) {
            return {
                text: "Unfollow",
                icon: <PersonRemoveIcon />,
                variant: "outlined",
                action: "unfollow",
                colorType: "unfollow" as const,
            };
        }

        return {
            text: "Follow",
            icon: <PersonAddIcon />,
            variant: "contained",
            action: "follow",
            colorType: "follow" as const,
        };
    };

    const handleFollowAction = async () => {
        if (!userLoggedIn) return;

        const config = getButtonConfig();

        startTransition(async () => {
            try {
                if (config.action === "unfollow") {
                    await unfollow(userLoggedIn.id, user.id);
                    showToast("success", "Unfollowed successfully!");
                } else {
                    await follow(userLoggedIn.id, user.id);
                    showToast("success", "Follow request sent successfully!");
                }

                router.refresh();
            } catch (error: any) {
                showToast("error", error.message || "Error performing follow action");
            }
        });
    };

    const buttonConfig = getButtonConfig();
    const buttonColors = getButtonColors(buttonConfig.colorType);

    return (
        <Paper
            elevation={1}
            sx={{
                p: 2,
                borderRadius: 2,
                transition: "all 0.2s",
                "&:hover": {
                    transform: "translateY(-2px)",
                    boxShadow: 2,
                },
            }}
        >
            <Stack direction="row" spacing={2} alignItems="center">
                <Link href={`/users/${user.id}/${user.userName}`} style={{ textDecoration: "none" }}>
                    <Avatar
                        src={user.avatar?.photoSrc || "/images/default-avatar.png"}
                        alt={user.userName}
                        sx={{
                            width: 50,
                            height: 50,
                            cursor: "pointer",
                            border: "2px solid",
                            borderColor: "background.paper",
                            transition: "transform 0.2s",
                            "&:hover": {
                                transform: "scale(1.05)",
                            },
                        }}
                    />
                </Link>
                <Box sx={{ flex: 1, minWidth: 0 }}>
                    <Link
                        href={`/users/${user.id}/${user.userName}`}
                        style={{
                            textDecoration: "none",
                            color: "inherit",
                        }}
                    >
                        <Typography
                            variant="subtitle1"
                            sx={{
                                fontWeight: 500,
                                cursor: "pointer",
                                display: "inline-block",
                                "&:hover": {
                                    color: "primary.main",
                                    textDecoration: "underline",
                                },
                            }}
                        >
                            {user.userName}
                        </Typography>
                    </Link>
                    <Typography
                        variant="body2"
                        color="text.secondary"
                        sx={{
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            display: "-webkit-box",
                            WebkitLineClamp: 2,
                            WebkitBoxOrient: "vertical",
                        }}
                    >
                        {user.bio || "No bio yet"}
                    </Typography>
                </Box>
                {userLoggedIn && userLoggedIn.id !== user.id && (
                    <Button
                        variant={buttonConfig.variant as "contained" | "outlined"}
                        startIcon={!isPending && buttonConfig.icon}
                        onClick={handleFollowAction}
                        disabled={isPending}
                        sx={{
                            minWidth: 100,
                            height: 32,
                            textTransform: "none",
                            borderRadius: 1,
                            fontSize: "0.875rem",
                            fontWeight: 500,
                            ...(buttonConfig.variant === "contained"
                                ? {
                                      bgcolor: buttonColors.main,
                                      color: "#ffffff",
                                      border: "1px solid",
                                      borderColor: buttonColors.main,
                                      "&:hover": {
                                          bgcolor: buttonColors.hover,
                                          borderColor: buttonColors.hover,
                                      },
                                  }
                                : {
                                      bgcolor: "transparent",
                                      color: buttonColors.main,
                                      border: "1px solid",
                                      borderColor: buttonColors.main,
                                      "&:hover": {
                                          bgcolor: buttonColors.main,
                                          color: "#ffffff",
                                      },
                                  }),
                            transition: "all 0.2s ease-in-out",
                            "&:active": {
                                transform: "translateY(1px)",
                            },
                            "&:disabled": {
                                bgcolor:
                                    buttonConfig.variant === "contained" ? `${buttonColors.main}80` : "transparent",
                                borderColor: `${buttonColors.main}80`,
                                color: buttonConfig.variant === "contained" ? "#ffffff" : `${buttonColors.main}80`,
                            },
                        }}
                    >
                        {isPending ? (
                            <CircularProgress
                                size={20}
                                sx={{
                                    color: buttonConfig.variant === "contained" ? "#ffffff" : buttonColors.main,
                                }}
                            />
                        ) : (
                            buttonConfig.text
                        )}
                    </Button>
                )}
            </Stack>
        </Paper>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/_components/UserPageContent.tsx
================================================
"use client";

import { Stack, Paper, Box, Typography, Divider } from "@mui/material";
import { motion } from "framer-motion";
import { JSX, useMemo } from "react";
import BookmarkIcon from "@mui/icons-material/Bookmark";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";
import RateReviewIcon from "@mui/icons-material/RateReview";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import LiveTvIcon from "@mui/icons-material/LiveTv";
import PlaylistPlayIcon from "@mui/icons-material/PlaylistPlay";
import PlayCircleOutlineIcon from "@mui/icons-material/PlayCircleOutline";
import PersonIcon from "@mui/icons-material/Person";
import GroupWorkIcon from "@mui/icons-material/GroupWork";
import { useRouter } from "next/navigation";
import ProfileHeader from "./ProfileHeader";
import ProfileInfo from "./ProfileInfo";
import ProfileStats from "./ProfileStats";
import ProfileTabs from "./ProfileTabs";
import PrivateProfileMessage from "./PrivateProfileMessage";
import TabContent from "./TabContent";
import SocialSection from "./SocialSection";
import { useQueryState } from "nuqs";

// #region "Iterfaces and types"
interface UserPageProps {
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    userInPage: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
        avatar?: { photoSrc: string } | null;
        isFollowed?: boolean;
        isFollowedStatus?: string | null;
    };
    additionalData: any;
    userFollowers: any;
    userFollowing: any;
    userPendingFollowers: any;
}

type TabConfig = {
    label: string;
    icon: JSX.Element;
    param: string;
};
// #endregion

export default function UserPageContent({
    userLoggedIn,
    userInPage,
    additionalData,
    userFollowers,
    userFollowing,
    userPendingFollowers,
}: UserPageProps) {
    const router = useRouter();

    // #region "Profile follow view logic"
    const canViewProfile = useMemo(() => {
        if (!userLoggedIn) return false;
        if (userLoggedIn.id === userInPage.id) return true;
        return userInPage.isFollowed && userInPage.isFollowedStatus === "accepted";
    }, [userLoggedIn, userInPage]);
    // #endregion

    // #region "Tabs and Subtabs logic"
    const mainTabs = useMemo<TabConfig[]>(
        () => [
            { label: "Bookmarks", icon: <BookmarkIcon />, param: "bookmarks" },
            { label: "Upvotes", icon: <ThumbUpIcon />, param: "upvotes" },
            { label: "Downvotes", icon: <ThumbDownIcon />, param: "downvotes" },
            { label: "Reviews", icon: <RateReviewIcon />, param: "reviews" },
        ],
        [],
    );

    const subTabs: Record<string, string[]> = {
        bookmarks: ["Movies", "Series", "Seasons", "Episodes", "Actors", "Crew"],
        reviews: ["Movies", "Series", "Seasons", "Episodes", "Actors", "Crew"],
        upvotes: ["Movies", "Series", "Seasons", "Episodes", "Actors", "Crew"],
        downvotes: ["Movies", "Series", "Seasons", "Episodes", "Actors", "Crew"],
    };

    const getSubTabIcon = (label: string) => {
        switch (label.toLowerCase()) {
            case "movies":
                return <LocalMoviesIcon />;
            case "series":
                return <LiveTvIcon />;
            case "seasons":
                return <PlaylistPlayIcon />;
            case "episodes":
                return <PlayCircleOutlineIcon />;
            case "actors":
                return <PersonIcon />;
            case "crew":
                return <GroupWorkIcon />;
            default:
                return <BookmarkIcon />;
        }
    };

    const [mainTab, setMainTab] = useQueryState("maintab", {
        defaultValue: "",
        parse: (value) => value || "",
        history: "push",
        shallow: false,
    });

    const [subTab, setSubTab] = useQueryState("subtab", {
        defaultValue: "",
        parse: (value) => value || "",
        history: "push",
        shallow: false,
    });

    const currentMainTab = useMemo(() => {
        const mainTabParam = mainTab;
        return mainTabParam ? mainTabs.findIndex((tab) => tab.param === mainTabParam) : 0;
    }, [mainTab, mainTabs]);

    const currentSubTab = useMemo(() => {
        const mainTabParam = mainTab;
        const currentSubTabs = subTabs[mainTabParam as keyof typeof subTabs];

        if (!subTab) return 0;

        const subTabIndex = currentSubTabs!.findIndex(
            (tab) => tab.toLowerCase().replace(/\s+/g, "") === subTab.toLowerCase().replace(/\s+/g, ""),
        );

        return subTabIndex === -1 ? 0 : subTabIndex;
    }, [subTab, subTabs, mainTabs]);
    // #endregion

    const getMainTabDescription = (mainTab: string) => {
        switch (mainTab) {
            case "bookmarks":
                return "Items saved for later viewing";
            case "upvotes":
                return "Reviews this user found helpful";
            case "downvotes":
                return "Reviews this user disagreed with";
            case "reviews":
                return "User's reviews and ratings";
            default:
                return "";
        }
    };

    return (
        <Stack spacing={4} width="100%" alignItems="center" sx={{ mt: 8, py: 4 }}>
            <Paper elevation={3} sx={{ width: "100%", p: { xs: 3, sm: 4 }, maxWidth: 800 }}>
                <Stack direction="column" spacing={{ xs: 3, sm: 4 }} alignItems="center">
                    <ProfileHeader avatar={userInPage.avatar} userName={userInPage.userName} />
                    <ProfileInfo userInPage={userInPage} userLoggedIn={userLoggedIn} />
                    <Stack
                        direction="row"
                        spacing={2}
                        alignItems="flex-start"
                        justifyContent="space-between"
                        width="100%"
                        sx={{ mt: 2 }}
                    >
                        <SocialSection
                            userLoggedIn={userLoggedIn}
                            userInPage={{
                                ...userInPage,
                                followers: userFollowers.items || [],
                                following: userFollowing.items || [],
                            }}
                            userPendingFollowers={userPendingFollowers}
                            userLoggedInId={userLoggedIn?.id}
                        />
                        <Box sx={{ flex: 1, display: "flex", justifyContent: "flex-end" }}>
                            <ProfileStats
                                userInPage={userInPage}
                                followersCount={userFollowers.items.length}
                                followingCount={userFollowing.items.length}
                                canClickFollow={canViewProfile!}
                            />
                        </Box>
                    </Stack>
                </Stack>
            </Paper>
            {!canViewProfile && userLoggedIn && userLoggedIn.id !== userInPage.id && <PrivateProfileMessage />}
            {canViewProfile && (
                <>
                    <Box
                        sx={{
                            width: "100%",
                            textAlign: "center",
                            mb: 2,
                            pt: 4,
                        }}
                    >
                        <Typography
                            variant="h5"
                            sx={{
                                fontWeight: 500,
                                mb: 1,
                            }}
                        >
                            {userInPage.userName}&apos;s {mainTabs[currentMainTab].label}
                        </Typography>
                        <Typography
                            variant="body2"
                            color="text.secondary"
                            sx={{
                                fontSize: { xs: "0.875rem", sm: "1rem" },
                            }}
                        >
                            {getMainTabDescription(mainTabs[currentMainTab].param)}
                        </Typography>
                        <Divider sx={{ mt: 2 }} />
                    </Box>
                    <ProfileTabs
                        mainTabs={mainTabs}
                        subTabs={subTabs}
                        getSubTabIcon={getSubTabIcon}
                        currentMainTab={currentMainTab}
                        currentSubTab={currentSubTab}
                        setMainTab={setMainTab}
                        setSubTab={setSubTab}
                    />
                    <motion.div
                        key={`${currentMainTab}-${currentSubTab}`}
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10 }}
                        transition={{ duration: 0.2 }}
                    >
                        <TabContent
                            type={subTabs[mainTabs[currentMainTab].param as keyof typeof subTabs][currentSubTab]}
                            userLoggedIn={userLoggedIn}
                            userInPage={userInPage}
                            additionalData={additionalData}
                            mainTab={mainTab}
                        />
                    </motion.div>
                </>
            )}
        </Stack>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/followers/page.tsx
================================================
import { getFollowers } from "@/actions/user/userFollow.actions";
import { getUserById } from "@/actions/user/user.actions";
import FollowersPageContent from "./_components/FollowersPageContent";
import { notFound, redirect } from "next/navigation";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IFollowersPageProps {
    params: {
        userId: string;
        userName: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function FollowersPage(props: IFollowersPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const userInPage: any = await getUserById(Number(params.userId), userSession?.id);

    if (!userInPage) {
        return notFound();
    }

    const canViewProfile =
        userSession?.id === userInPage.id || (userInPage.isFollowed && userInPage.isFollowedStatus === "accepted");

    if (!canViewProfile) {
        return redirect(`/users/${params.userId}/${params.userName}`);
    }

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const followers = await getFollowers(Number(params.userId), userSession?.id!, page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <FollowersPageContent userInPage={userInPage} userLoggedIn={userSession} followers={followers} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/followers/_components/FollowersPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import { useRouter } from "next/navigation";
import UserListItem from "../../_components/UserListItem";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useQueryState } from "nuqs";

interface FollowersContentProps {
    userInPage: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
        avatar?: { photoSrc: string } | null;
        isFollowed?: boolean;
        isFollowedStatus?: string | null;
    };
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
    followers: {
        items: Array<{
            follower: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
                followStatus?: {
                    isFollowing: boolean;
                    state: string | null;
                } | null;
            };
        }>;
        total: number;
    };
}

export default function FollowersContent({ userInPage, followers, userLoggedIn }: FollowersContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(followers.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.push(`/users/${userInPage.id}/${userInPage.userName}`);
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                {userInPage.userName}&apos;s Followers
            </Typography>
            <Stack spacing={2}>
                {followers.items.length > 0 ? (
                    followers.items.map((follow) => (
                        <UserListItem key={follow.follower.id} user={follow.follower} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        No followers yet
                    </Typography>
                )}
            </Stack>
            {followers.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/followersRequests/page.tsx
================================================
import { getPendingFollowRequests } from "@/actions/user/userFollow.actions";
import { Suspense } from "react";
import { Box, CircularProgress } from "@mui/material";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import FollowersRequestsPageContent from "./_components/FollowersRequestsPageContent";

interface FollowRequestPageProps {
    params: {
        userId: string;
        userName: string;
    };
}

export default async function FollowersRequestsPage({ params }: FollowRequestPageProps) {
    const session = await getServerSession(authOptions);
    const userId = Number(params.userId);
    const userLoggedInId = Number(session?.user?.id);
    const userLoggedInUsername = session?.user?.userName;
    const pendingFollowers = await getPendingFollowRequests(userId);

    return (
        <Suspense
            fallback={
                <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", height: "100vh" }}>
                    <CircularProgress />
                </Box>
            }
        >
            <FollowersRequestsPageContent
                pendingFollowers={pendingFollowers}
                userLoggedInUsername={userLoggedInUsername!}
                userLoggedInId={userLoggedInId}
            />
        </Suspense>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/followersRequests/_components/FollowersRequestsPageContent.tsx
================================================
"use client";

import { useState, useTransition } from "react";
import { Box, CircularProgress, IconButton, Stack, Typography, Container, Paper, Avatar } from "@mui/material";
import CheckIcon from "@mui/icons-material/Check";
import CloseIcon from "@mui/icons-material/Close";
import { acceptFollowRequest, refuseFollowRequest } from "@/actions/user/userFollow.actions";
import { showToast } from "@/utils/helpers/toast";
import { useRouter } from "next/navigation";
import { motion } from "framer-motion";
import PersonAddIcon from "@mui/icons-material/PersonAdd";
import Link from "next/link";

interface FollowersRequestsPageContentProps {
    pendingFollowers: any;
    userLoggedInId: number;
    userLoggedInUsername: string;
}

export default function FollowersRequestsPageContent({
    pendingFollowers,
    userLoggedInId,
    userLoggedInUsername,
}: FollowersRequestsPageContentProps) {
    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Typography variant="h4" gutterBottom sx={{ mb: 4 }}>
                Follow Requests
            </Typography>
            {pendingFollowers.items.length === 0 ? (
                <Box
                    sx={{
                        py: 8,
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        gap: 2,
                    }}
                >
                    <PersonAddIcon
                        sx={{
                            fontSize: 64,
                            color: "text.disabled",
                        }}
                    />
                    <Typography variant="h6" color="text.secondary" align="center">
                        No pending follow requests.
                    </Typography>
                </Box>
            ) : (
                <Stack spacing={2}>
                    {pendingFollowers.items.map((follow: any, index: number) => (
                        <motion.div
                            key={follow.follower.id}
                            initial={{ opacity: 0, y: 20 }}
                            animate={{
                                opacity: 1,
                                y: 0,
                                transition: { delay: index * 0.1 },
                            }}
                        >
                            <Paper
                                sx={{
                                    p: 2,
                                    bgcolor: "background.paper",
                                    transition: "all 0.2s",
                                    "&:hover": {
                                        transform: "translateY(-2px)",
                                        boxShadow: (theme) => theme.shadows[4],
                                    },
                                }}
                                elevation={1}
                            >
                                <FollowRequestItem
                                    follow={follow}
                                    userLoggedInId={userLoggedInId}
                                    userId={Number(follow.follower.id)}
                                    userName={follow.follower.userName}
                                />
                            </Paper>
                        </motion.div>
                    ))}
                </Stack>
            )}
        </Container>
    );
}

interface FollowRequestItemProps {
    follow: any;
    userLoggedInId: number | undefined;
    userId: number;
    userName: string;
}

function FollowRequestItem({ follow, userLoggedInId, userId, userName }: FollowRequestItemProps) {
    const [isPending, startTransition] = useTransition();
    const [pendingActionId, setPendingActionId] = useState<number | null>(null);
    const router = useRouter();

    const handleAcceptFollow = async (followerId: number) => {
        if (!userLoggedInId || isPending) return;

        setPendingActionId(followerId);

        startTransition(async () => {
            try {
                await acceptFollowRequest(followerId, Number(userLoggedInId));
                showToast("success", "Follow request accepted!");
                router.refresh();
            } catch (error: any) {
                console.error(`Error accepting follow request: ${error.message}`);
                showToast("error", error.message || "Error accepting follow request");
            } finally {
                setPendingActionId(null);
            }
        });
    };

    const handleRefuseFollow = async (followerId: number) => {
        if (!userLoggedInId || isPending) return;

        setPendingActionId(followerId);

        startTransition(async () => {
            try {
                await refuseFollowRequest(followerId, Number(userLoggedInId));
                showToast("success", "Follow request succesfully refused!");
                router.refresh();
            } catch (error: any) {
                console.error(`Error refusing follow request: ${error.message}`);
                showToast("error", error.message || "Error refusing follow request");
            } finally {
                setPendingActionId(null);
            }
        });
    };

    return (
        <Stack direction="row" spacing={2} alignItems="center">
            <Avatar
                src={follow.follower.avatar?.photoSrc}
                alt={follow.follower.userName}
                sx={{ width: 50, height: 50 }}
            />
            <Box sx={{ flex: 1 }}>
                <Link href={`/users/${userId}/${userName}`} passHref style={{ textDecoration: "none" }}>
                    <Typography
                        variant="body1"
                        sx={{ fontWeight: 500, color: "inherit", "&:hover": { textDecoration: "underline" } }}
                    >
                        {follow.follower.userName}
                    </Typography>
                </Link>
                <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                    wants to follow you
                </Typography>
            </Box>
            <Box>
                <IconButton
                    onClick={() => handleAcceptFollow(follow.follower.id)}
                    disabled={isPending}
                    size="small"
                    sx={{
                        color: "success.main",
                        "&:hover": {
                            color: "success.dark",
                            transform: "scale(1.1)",
                        },
                    }}
                >
                    {isPending && pendingActionId === follow.follower.id ? (
                        <CircularProgress size={16} color="inherit" />
                    ) : (
                        <CheckIcon fontSize="small" />
                    )}
                </IconButton>
                <IconButton
                    onClick={() => handleRefuseFollow(follow.follower.id)}
                    disabled={isPending}
                    size="small"
                    sx={{
                        color: "error.main",
                        "&:hover": {
                            color: "error.dark",
                            transform: "scale(1.1)",
                        },
                    }}
                >
                    {isPending && pendingActionId === follow.follower.id ? (
                        <CircularProgress size={16} color="inherit" />
                    ) : (
                        <CloseIcon fontSize="small" />
                    )}
                </IconButton>
            </Box>
        </Stack>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/following/page.tsx
================================================
import { getFollowing } from "@/actions/user/userFollow.actions";
import { getUserById } from "@/actions/user/user.actions";
import FollowingPageContent from "./_components/FollowingPageContent";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { notFound, redirect } from "next/navigation";
import LoadingSpinner from "@/components/root/loadingSpinner/LoadingSpinner";
import { Suspense } from "react";

interface IFollowingPageProps {
    params: {
        userId: string;
        userName: string;
    };
    searchParams?: Promise<{ page?: string }>;
}

export default async function FollowingPage(props: IFollowingPageProps) {
    const session = await getServerSession(authOptions);
    const userSession = session?.user
        ? {
              id: Number(session.user.id),
              userName: session.user.userName,
              email: session.user.email,
              password: null,
              role: session.user.role,
              bio: "",
              active: true,
              canResetPassword: false,
          }
        : null;

    const params = await props.params;
    const userInPage: any = await getUserById(Number(params.userId), userSession?.id);

    if (!userInPage) {
        return notFound();
    }

    const canViewProfile =
        userSession?.id === userInPage.id || (userInPage.isFollowed && userInPage.isFollowedStatus === "accepted");

    if (!canViewProfile) {
        return redirect(`/users/${params.userId}/${params.userName}`);
    }

    const searchParams = await props.searchParams;
    const searchParamsKey = JSON.stringify(searchParams);
    const page = Number(searchParams?.page) || 1;

    const following = await getFollowing(Number(params.userId), userSession?.id!, page);

    return (
        <Suspense key={searchParamsKey} fallback={<LoadingSpinner />}>
            <FollowingPageContent userInPage={userInPage} userLoggedIn={userSession} following={following} />
        </Suspense>
    );
}


================================================
File: src/app/(root)/users/[userId]/[userName]/following/_components/FollowingPageContent.tsx
================================================
"use client";

import { Box, Container, Pagination, Stack, Typography, Button } from "@mui/material";
import UserListItem from "../../_components/UserListItem";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import { useRouter } from "next/navigation";
import { useQueryState } from "nuqs";

interface FollowingContentProps {
    userInPage: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
        avatar?: { photoSrc: string } | null;
        isFollowed?: boolean;
        isFollowedStatus?: string | null;
    };
    following: {
        items: Array<{
            following: {
                id: number;
                userName: string;
                bio: string;
                avatar?: { photoSrc: string } | null;
                followStatus?: {
                    isFollowing: boolean;
                    state: string | null;
                } | null;
            };
        }>;
        total: number;
    };
    userLoggedIn: {
        id: number;
        userName: string;
        email: string;
        password: string | null;
        role: string;
        bio: string;
        active: boolean;
        canResetPassword: boolean;
    } | null;
}

export default function FollowingContent({ userInPage, following, userLoggedIn }: FollowingContentProps) {
    const router = useRouter();

    const [page, setPage] = useQueryState("page", {
        defaultValue: "1",
        parse: (value) => value || "1",
        history: "push",
        shallow: false,
    });

    const perPage = 10;
    const totalPages = Math.ceil(following.total / perPage);

    const handlePageChange = (_: React.ChangeEvent<unknown>, value: number) => {
        setPage(value.toString());
    };

    return (
        <Container maxWidth="md" sx={{ py: 4, mt: 8, mb: 8 }}>
            <Button
                variant="outlined"
                startIcon={<ArrowBackIcon />}
                onClick={() => {
                    router.push(`/users/${userInPage.id}/${userInPage.userName}`);
                    router.refresh();
                }}
                sx={{ mb: 2 }}
            >
                Go Back
            </Button>
            <Typography variant="h4" gutterBottom sx={{ mt: 3, mb: 3 }}>
                {userInPage.userName} is Following
            </Typography>
            <Stack spacing={2}>
                {following.items.length > 0 ? (
                    following.items.map((follow) => (
                        <UserListItem key={follow.following.id} user={follow.following} userLoggedIn={userLoggedIn} />
                    ))
                ) : (
                    <Typography color="text.secondary" textAlign="center">
                        Not following anyone yet
                    </Typography>
                )}
            </Stack>
            {following.total > perPage && (
                <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
                    <Pagination
                        count={totalPages}
                        page={Number(page)}
                        onChange={handlePageChange}
                        color="primary"
                        size="large"
                    />
                </Box>
            )}
        </Container>
    );
}


================================================
File: src/app/(root)/verify-register/page.tsx
================================================
import { Box, Container, Typography } from "@mui/material";
import Link from "next/link";

export default async function VerifyRegisterPage(props: { searchParams: Promise<{ token: string; email: string }> }) {
    const searchParams = await props.searchParams;
    const { token, email } = searchParams;

    let message = "";
    let isError = false;

    try {
        const res = await fetch(
            `${process.env.NEXT_PUBLIC_PROJECT_URL}/api/verifyRegister?token=${encodeURIComponent(token)}&email=${encodeURIComponent(email)}`,
        );

        if (!res.ok) {
            const data = await res.json();
            throw new Error(data.message || "Verification failed.");
        }

        message = "Your email has been successfully verified. Now you can freely login.";
    } catch (error: any) {
        isError = true;
        message = error.message || "Verification failed. Go back and try registering again";
    }

    return (
        <Container
            sx={{
                height: "100vh",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
            }}
        >
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    p: 8,
                    boxShadow: 6,
                    borderRadius: 4,
                    backgroundColor: "background.paper",
                }}
            >
                <Typography variant="h4" component="h1" gutterBottom>
                    {isError ? "Verification Failed" : "Verification Successful"}
                </Typography>
                <Typography variant="body1" sx={{ mb: 3 }}>
                    {message}
                </Typography>
                {isError ? (
                    <Box>
                        <Link
                            href={"/register"}
                            prefetch={false}
                            style={{
                                fontSize: "18px",
                                fontWeight: 700,
                                textTransform: "capitalize",
                                textDecoration: "none",
                            }}
                        >
                            Sign Up
                        </Link>
                    </Box>
                ) : (
                    <Box>
                        <Link
                            href={"/login"}
                            prefetch={false}
                            style={{
                                fontSize: "18px",
                                fontWeight: 700,
                                textTransform: "capitalize",
                                textDecoration: "none",
                            }}
                        >
                            Sign In
                        </Link>
                    </Box>
                )}
            </Box>
        </Container>
    );
}


================================================
File: src/app/(root)/verify-reset-password/page.tsx
================================================
import { Box, Container, Typography } from "@mui/material";
import Link from "next/link";

export default async function VerifyResetPasswordPage(props: {
    searchParams: Promise<{ token: string; email: string }>;
}) {
    const searchParams = await props.searchParams;
    const { token, email } = searchParams;

    let message = "";
    let isError = false;

    try {
        const res = await fetch(
            `${process.env.NEXT_PUBLIC_PROJECT_URL}/api/verifyResetPassword?token=${encodeURIComponent(token)}&email=${encodeURIComponent(email)}`,
        );

        if (!res.ok) {
            const data = await res.json();
            throw new Error(data.message || "Verification failed.");
        }

        message = "Your email has been successfully verified. Now you can change the passowrd.";
    } catch (error: any) {
        isError = true;
        message = error.message || "Verification failed. Go back and check the email";
    }

    return (
        <Container
            sx={{
                height: "100vh",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
            }}
        >
            <Box
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    p: 8,
                    boxShadow: 6,
                    borderRadius: 4,
                    backgroundColor: "background.paper",
                }}
            >
                <Typography variant="h4" component="h1" gutterBottom>
                    {isError ? "Verification Failed" : "Verification Successful"}
                </Typography>
                <Typography variant="body1" sx={{ mb: 3 }}>
                    {message}
                </Typography>
                {isError ? (
                    <Box>
                        <Link
                            href={"/register"}
                            prefetch={false}
                            style={{
                                fontSize: "18px",
                                fontWeight: 700,
                                textTransform: "capitalize",
                                textDecoration: "none",
                            }}
                        >
                            Sign Up
                        </Link>
                    </Box>
                ) : (
                    <Box>
                        <Link
                            href={`/change-password?email=${encodeURIComponent(email)}`}
                            prefetch={false}
                            style={{
                                fontSize: "18px",
                                fontWeight: 700,
                                textTransform: "capitalize",
                                textDecoration: "none",
                            }}
                        >
                            Change Password
                        </Link>
                    </Box>
                )}
            </Box>
        </Container>
    );
}


================================================
File: src/app/_components/NotFoundGlobalPage.tsx
================================================
"use client";

import { Box, Container, Link, Typography, useTheme } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

export default function NotFoundGlobalPage() {
    const theme = useTheme();

    return (
        <Container maxWidth="sm">
            <Box
                sx={{
                    my: 20,
                    display: "flex",
                    flexDirection: "column",
                    placeItems: "center",
                    placeContent: "center",
                    borderRadius: 2,
                    border: 1,
                    borderColor: "neutral.200",
                    bgcolor: "background.paper",
                    p: 6,
                    boxShadow: 3,
                    transition: "background-color 0.5s ease",
                }}
            >
                <Box>
                    <Typography
                        component="h1"
                        fontSize={60}
                        sx={{ color: theme.vars.palette.primary.main }}
                        textAlign={"center"}
                    >
                        404
                    </Typography>
                    <Typography
                        variant="h2"
                        component="h2"
                        gutterBottom
                        sx={{ color: theme.vars.palette.primary.main }}
                    >
                        Page not found.
                    </Typography>
                    <Typography variant="h5" component="p" sx={{ color: theme.vars.palette.primary.main }}>
                        The page you are looking for might have been removed, or is temporarily unavailable.
                    </Typography>
                    <Box
                        sx={{
                            mt: 4,
                        }}
                    >
                        <Link
                            href={"/"}
                            style={{
                                textDecoration: "none",
                                color: theme.vars.palette.primary.main,
                                padding: 12,
                                borderRadius: 20,
                                border: "1px solid",
                            }}
                        >
                            Go back home
                        </Link>
                    </Box>
                </Box>
            </Box>
        </Container>
    );
}


================================================
File: src/app/api/route.ts
================================================
import { getServerSession } from "next-auth/next";
import { NextResponse } from "next/server";
import { authOptions } from "./auth/[...nextauth]/route";

export async function GET() {
    const session = await getServerSession(authOptions);

    if (!session) {
        return new NextResponse(JSON.stringify({ error: "unauthorized" }), {
            status: 401,
        });
    }

    return NextResponse.json({ authenticated: !!session });
}


================================================
File: src/app/api/auth/[...nextauth]/route.ts
================================================
import NextAuth, { type NextAuthOptions } from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import CredentialsProvider from "next-auth/providers/credentials";
import { compare } from "bcrypt";
import { prisma } from "../../../../../prisma/config/prisma";
import { PrismaAdapter } from "@next-auth/prisma-adapter";

export const authOptions: NextAuthOptions = {
    adapter: PrismaAdapter(prisma),
    providers: [
        GoogleProvider({
            clientId: process.env.GOOGLE_CLIENT_ID ?? "",
            clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? "",
        }),
        CredentialsProvider({
            name: "Credentials",
            credentials: {
                email: { label: "Email", type: "email" },
                password: { label: "Password", type: "password" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) {
                    throw new Error("Invalid credentials");
                }

                const user = await prisma.user.findUnique({
                    where: {
                        email: credentials.email,
                    },
                });

                if (!user || !user?.password) {
                    throw new Error("Invalid credentials");
                }

                if (!user.active) {
                    throw new Error("Please activate your account first");
                }

                const dbPassword = user.password!;
                let isPasswordValid = false;

                // Checking if the password in the database is hashed
                const isHashedPassword = dbPassword.length === 60 && dbPassword.startsWith("$2b$");

                if (isHashedPassword) {
                    // Comparing using bcrypt for hashed passwords
                    isPasswordValid = await compare(credentials.password, dbPassword);
                } else {
                    // Plain text comparison for unencrypted passwords
                    isPasswordValid = credentials.password === dbPassword;
                }

                if (!isPasswordValid) {
                    throw new Error("Invalid credentials");
                }

                return {
                    id: user.id.toString(),
                    email: user.email,
                    userName: user.userName,
                    role: user.role,
                };
            },
        }),
    ],
    session: {
        strategy: "jwt",
    },
    callbacks: {
        async signIn({ account, profile }) {
            if (account?.provider === "google") {
                const existingUser = await prisma.user.findUnique({
                    where: { email: profile?.email },
                    include: { accounts: true },
                });

                if (!existingUser) {
                    // Creating a new user if doesn't exist for google auth0
                    const newUser = await prisma.user.create({
                        data: {
                            email: profile?.email,
                            userName: profile?.name ?? "Google User",
                            active: true,
                            role: "User",
                        },
                    });

                    // Create the account link, this is the most important which fixed it
                    await prisma.account.create({
                        data: {
                            userId: newUser.id,
                            type: account.type,
                            provider: account.provider,
                            providerAccountId: account.providerAccountId,
                            access_token: account.access_token,
                            token_type: account.token_type,
                            scope: account.scope,
                            id_token: account.id_token,
                        },
                    });

                    return true;
                }

                // If user exists but no account is linked, link the account
                if (existingUser && !existingUser.accounts.length) {
                    await prisma.account.create({
                        data: {
                            userId: existingUser.id,
                            type: account.type,
                            provider: account.provider,
                            providerAccountId: account.providerAccountId,
                            access_token: account.access_token,
                            token_type: account.token_type,
                            scope: account.scope,
                            id_token: account.id_token,
                        },
                    });
                }

                return true;
            }

            return true;
        },
        async jwt({ token, user, account }) {
            if (account?.provider === "google") {
                const dbUser = await prisma.user.findUnique({
                    where: { email: token.email! },
                });

                if (dbUser) {
                    token.id = dbUser.id.toString();
                    token.userName = dbUser.userName;
                    token.role = dbUser.role;
                }
            }

            if (user) {
                token.id = user.id;
                token.userName = user.userName;
                token.role = user.role;
            }

            return token;
        },
        async session({ session, token }) {
            if (session.user) {
                session.user.id = token.id as string;
                session.user.userName = token.userName as string;
                session.user.role = token.role as string;
            }
            return session;
        },
    },
    pages: {
        signIn: "/login",
        error: "/login",
    },
    debug: process.env.NODE_ENV === "development",
    secret: process.env.NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


================================================
File: src/app/api/changePassword/route.ts
================================================
import { NextResponse } from "next/server";
import { prisma } from "../../../../prisma/config/prisma";
import { hashSync } from "bcrypt";

export async function POST(request: Request) {
    const { newPassword, email } = await request.json();

    if (!email || !newPassword) {
        return NextResponse.json({ message: "Invalid or missing email or password" }, { status: 400 });
    }

    try {
        const user = await prisma.user.findFirst({
            where: {
                email,
            },
        });

        if (!user) {
            return NextResponse.json({ message: "User with that email doesn't exist." }, { status: 400 });
        }

        if (!user.canResetPassword) {
            return NextResponse.json(
                {
                    message:
                        "You are not permitted to change the password without the verification process beforehand.",
                },
                { status: 400 },
            );
        }

        const saltRounds = 7;
        const hashedPassword = hashSync(newPassword, saltRounds);

        await prisma.user.update({
            where: { id: user.id },
            data: { password: hashedPassword, canResetPassword: false },
        });

        return NextResponse.json({ message: "Password is changed successfully." });
    } catch (error) {
        return NextResponse.json({ message: "An error occurred during changing the password." }, { status: 500 });
    }
}


================================================
File: src/app/api/genres/route.ts
================================================
import { NextResponse } from "next/server";
import { prisma } from "../../../../prisma/config/prisma";

export const GET = async () => {
    try {
        const genres = await prisma.genre.findMany();

        if (genres) {
            return NextResponse.json(genres, { status: 200 });
        }
    } catch (err) {
        return new NextResponse("Internal Server Error", { status: 500 });
    }
};


================================================
File: src/app/api/notifications/route.ts
================================================
import { prisma } from "../../../../prisma/config/prisma";
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const userId = searchParams.get("userId");
        const page = parseInt(searchParams.get("page") || "1");
        const limit = parseInt(searchParams.get("limit") || "5");

        if (!userId) {
            return NextResponse.json({ error: "User ID is required" }, { status: 400 });
        }

        const skip = (page - 1) * limit;

        const notifications = await prisma.notification.findMany({
            where: {
                userId: parseInt(userId),
            },
            include: {
                sender: {
                    select: {
                        id: true,
                        userName: true,
                        avatar: true,
                    },
                },
            },
            orderBy: {
                createdAt: "desc",
            },
            skip,
            take: limit,
        });

        return NextResponse.json(notifications);
    } catch (error) {
        console.error("Error fetching notifications:", error);
        return NextResponse.json({ error: "Failed to fetch notifications" }, { status: 500 });
    }
}


================================================
File: src/app/api/search/all/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "../../../../../prisma/config/prisma";

export async function GET(request: NextRequest): Promise<NextResponse> {
    try {
        const searchParams = request.nextUrl.searchParams;
        const searchTerm = searchParams.get("term")?.trim() || "";

        if (!searchTerm) {
            return NextResponse.json({});
        }

        const filters = searchParams.get("filters")?.split(",") || [];
        const take = 5;

        const shouldSearchAll = filters.includes("all") || filters.length === 0;

        const queries = [];
        if (shouldSearchAll || filters.includes("movies")) {
            queries.push(
                prisma.movie.findMany({ where: { title: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.movie.count({ where: { title: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("series")) {
            queries.push(
                prisma.serie.findMany({ where: { title: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.serie.count({ where: { title: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("actors")) {
            queries.push(
                prisma.actor.findMany({ where: { fullname: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.actor.count({ where: { fullname: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("crew")) {
            queries.push(
                prisma.crew.findMany({ where: { fullname: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.crew.count({ where: { fullname: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("seasons")) {
            queries.push(
                prisma.season.findMany({ where: { title: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.season.count({ where: { title: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("episodes")) {
            queries.push(
                prisma.episode.findMany({ where: { title: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.episode.count({ where: { title: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        if (shouldSearchAll || filters.includes("users")) {
            queries.push(
                prisma.user.findMany({ where: { userName: { contains: searchTerm, mode: "insensitive" } }, take }),
                prisma.user.count({ where: { userName: { contains: searchTerm, mode: "insensitive" } } }),
            );
        }

        const results = await Promise.all(queries);
        const response: any = {};
        let resultIndex = 0;

        // Processing results based on the same order as queries
        if (shouldSearchAll || filters.includes("movies")) {
            response.movies = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("series")) {
            response.series = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("actors")) {
            response.actors = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("crew")) {
            response.crews = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("seasons")) {
            response.seasons = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("episodes")) {
            response.episodes = { items: results[resultIndex], total: results[resultIndex + 1] };
            resultIndex += 2;
        }

        if (shouldSearchAll || filters.includes("users")) {
            response.users = { items: results[resultIndex], total: results[resultIndex + 1] };
        }

        return NextResponse.json(response);
    } catch (error) {
        console.error("Error searching:", error);
        return NextResponse.json({ error: "Failed to search" }, { status: 500 });
    }
}


================================================
File: src/app/api/verifyRegister/route.ts
================================================
import { NextResponse } from "next/server";
import { prisma } from "../../../../prisma/config/prisma";

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);

    const token = searchParams.get("token");
    const email = searchParams.get("email");

    if (!token || !email) {
        return NextResponse.json({ message: "Invalid or missing token/email" }, { status: 400 });
    }

    try {
        const activateToken = await prisma.activateToken.findFirst({
            where: {
                token,
                activatedAt: null,
            },
            include: {
                user: true,
            },
        });

        if (!activateToken || activateToken.user.email !== email) {
            return NextResponse.json({ message: "Invalid token or email" }, { status: 400 });
        }

        await prisma.user.update({
            where: { id: activateToken.userId },
            data: { active: true },
        });

        await prisma.activateToken.update({
            where: { id: activateToken.id },
            data: { activatedAt: new Date() },
        });

        return NextResponse.json({ message: "Email verified successfully." });
    } catch (error) {
        return NextResponse.json({ message: "An error occurred during verification." }, { status: 500 });
    }
}


================================================
File: src/app/api/verifyResetPassword/route.ts
================================================
import { NextResponse } from "next/server";
import { prisma } from "../../../../prisma/config/prisma";

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);

    const token = searchParams.get("token");
    const email = searchParams.get("email");

    if (!token || !email) {
        return NextResponse.json({ message: "Invalid or missing token/email" }, { status: 400 });
    }

    try {
        const resetPasswordToken = await prisma.resetPasswordToken.findFirst({
            where: {
                token,
                resetPasswordAt: null,
            },
            include: {
                user: true,
            },
        });

        if (!resetPasswordToken || resetPasswordToken.user.email !== email) {
            return NextResponse.json({ message: "Invalid token or email" }, { status: 400 });
        }

        await prisma.user.update({
            where: { id: resetPasswordToken.userId },
            data: { canResetPassword: true },
        });

        await prisma.resetPasswordToken.update({
            where: { id: resetPasswordToken.id },
            data: { resetPasswordAt: new Date() },
        });

        return NextResponse.json({ message: "Reset password with email verified successfully." });
    } catch (error) {
        return NextResponse.json({ message: "An error occurred during verification." }, { status: 500 });
    }
}


================================================
File: src/components/admin/breadcrumb/Breadcrumb.tsx
================================================
"use client";

import { Box, Button, Breadcrumbs, useTheme } from "@mui/material";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import NavigateNextIcon from "@mui/icons-material/NavigateNext";
import { useRouter } from "next/navigation";
import { JSX } from "react";

interface IBreadcrumbProps {
    breadcrumbs: JSX.Element[];
    navigateTo: string;
}

const Breadcrumb = ({ breadcrumbs, navigateTo }: IBreadcrumbProps) => {
    const router = useRouter();
    const theme = useTheme();

    return (
        <Box
            display={"flex"}
            component={"nav"}
            flexDirection={"row"}
            alignItems={"center"}
            gap={"20px"}
            sx={{
                mb: "30px",
            }}
        >
            <Button
                variant="outlined"
                onClick={() => {
                    router.push(navigateTo);
                }}
                sx={{
                    backgroundColor: theme.vars.palette.background.default,
                    borderColor: theme.vars.palette.primary.main,
                    color: theme.vars.palette.primary.main,
                    "&:hover": {
                        backgroundColor: theme.vars.palette.primary.main,
                        color: theme.vars.palette.background.default,
                        borderColor: theme.vars.palette.primary.main,
                    },
                }}
            >
                <ArrowBackIcon />
            </Button>
            <Breadcrumbs
                separator={<NavigateNextIcon fontSize="small" sx={{ color: theme.vars.palette.primary.main }} />}
                aria-label="breadcrumb"
                sx={{
                    "& .MuiBreadcrumbs-li a": {
                        color: theme.vars.palette.primary.main,
                        transition: "all 0.2s ease-in-out",
                        padding: "4px 8px",
                        borderRadius: "4px",
                        "&:hover": {
                            color: theme.vars.palette.background.default,
                            backgroundColor: theme.vars.palette.primary.main,
                            textDecoration: "none",
                        },
                    },
                    "& .MuiBreadcrumbs-li:last-child a": {
                        color: theme.vars.palette.text.primary,
                        pointerEvents: "none",
                        backgroundColor: "transparent",
                    },
                }}
            >
                {breadcrumbs}
            </Breadcrumbs>
        </Box>
    );
};

export default Breadcrumb;


================================================
File: src/components/admin/form/Form.tsx
================================================
"use client";

import React, { useEffect, useState, useImperativeHandle } from "react";
import {
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Button,
    SxProps,
    InputAdornment,
    IconButton,
    Stack,
    Grid2 as Grid,
    Box,
    FormLabel,
    Typography,
} from "@mui/material";
import { useForm, Controller } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { Visibility, VisibilityOff } from "@mui/icons-material";
import * as CONSTANTS from "@/constants/Constants";

interface IFormProps {
    defaultValues: any;
    schema: z.ZodSchema<any>;
    fields: FieldConfig[];
    actions?: ActionConfig[];
    formRef: any;
    onSubmit: (values: any) => void;
    onDataChange?: (values: any) => void;
}

type FieldOption = {
    label: string;
    value: string;
};

type FieldConfig = {
    name: string;
    label: string;
    type: "text" | "select" | "multiselect" | "date" | "password";
    options?: FieldOption[];
    disabled?: boolean;
    span?: number;
    helperText?: React.ReactNode;
    error?: boolean | undefined;
    variant?: any;
    sx?: SxProps;
};

type ActionConfig = {
    label: string;
    type?: string;
    color?: "inherit" | "primary" | "secondary" | "success" | "error" | "info" | "warning" | "default";
    variant?: "text" | "outlined" | "contained";
    icon?: React.ReactNode;
    sx?: SxProps;
    onClick?: () => void;
};

const FormAdvanced: React.FC<IFormProps> = ({
    defaultValues,
    schema,
    onSubmit,
    fields,
    actions,
    onDataChange,
    formRef,
}) => {
    const [showPassword, setShowPassword] = useState(false);

    const {
        control,
        handleSubmit,
        watch,
        reset,
        formState: { errors, isDirty },
    } = useForm({
        values: defaultValues,
        resolver: zodResolver(schema),
        mode: "onChange",
    });

    useImperativeHandle(formRef, () => ({
        reset: () => reset(),
    }));

    useEffect(() => {
        const { unsubscribe } = watch(() => {
            if (onDataChange) {
                onDataChange(watch());
            }
        });

        return () => unsubscribe();
    }, [watch]);

    const handleClickShowPassword = () => setShowPassword(!showPassword);
    const handleMouseDownPassword = () => setShowPassword(!showPassword);

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <Grid container direction="column" rowSpacing={{ xs: 4, md: 6, lg: 8 }}>
                <Grid container alignItems={"center"}>
                    <Stack rowGap={4} columnGap={2} flexDirection={"row"} flexWrap={"wrap"}>
                        {fields.map((field: FieldConfig, index: number) => {
                            const error = !!errors[field.name];
                            const helperText = errors[field.name]?.message as string | undefined;

                            switch (field.type) {
                                case "select":
                                    return (
                                        <FormControl key={index} fullWidth>
                                            <InputLabel id={`${field.name}-label`}>{field.label}</InputLabel>
                                            <Controller
                                                name={field.name}
                                                control={control}
                                                defaultValue={""}
                                                render={({ field: controllerField }) => (
                                                    <Select
                                                        labelId={`${field.name}-label`}
                                                        variant={field.variant}
                                                        size="small"
                                                        {...controllerField}
                                                        sx={field.sx}
                                                    >
                                                        {field.options?.map((option, idx) => (
                                                            <MenuItem key={idx} value={option.value}>
                                                                {option.label}
                                                            </MenuItem>
                                                        ))}
                                                    </Select>
                                                )}
                                            />
                                        </FormControl>
                                    );
                                case "multiselect":
                                    return (
                                        <FormControl key={index} fullWidth>
                                            <InputLabel id={`${field.name}-label`}>{field.label}</InputLabel>
                                            <Controller
                                                name={field.name}
                                                control={control}
                                                defaultValue={""}
                                                render={({ field: controllerField }) => (
                                                    <Select
                                                        labelId={`${field.name}-label`}
                                                        variant={field.variant}
                                                        size="small"
                                                        multiple
                                                        {...controllerField}
                                                        sx={field.sx}
                                                    >
                                                        {field.options?.map((option, idx) => (
                                                            <MenuItem key={idx} value={option.value}>
                                                                {option.label}
                                                            </MenuItem>
                                                        ))}
                                                    </Select>
                                                )}
                                            />
                                        </FormControl>
                                    );
                                case "date":
                                    return (
                                        <Controller
                                            key={index}
                                            name={field.name}
                                            control={control}
                                            defaultValue={""}
                                            render={({ field: controllerField }) => (
                                                <TextField
                                                    label={field.label}
                                                    variant={field.variant}
                                                    {...controllerField}
                                                    sx={field.sx}
                                                    size="small"
                                                    type="date"
                                                    slotProps={{ inputLabel: { shrink: true } }}
                                                    helperText={helperText}
                                                    error={error}
                                                />
                                            )}
                                        />
                                    );
                                case "password":
                                    return (
                                        <Box display={"flex"} flexDirection={"column"} rowGap={1} key={index}>
                                            <FormLabel>{field.label}</FormLabel>
                                            <Controller
                                                name={field.name}
                                                control={control}
                                                defaultValue={""}
                                                render={({ field: controllerField }) => (
                                                    <TextField
                                                        {...controllerField}
                                                        variant={field.variant}
                                                        size="small"
                                                        sx={field.sx}
                                                        type={showPassword ? "text" : "password"}
                                                        autoComplete={"on"}
                                                        helperText={helperText}
                                                        error={error}
                                                        slotProps={{
                                                            input: {
                                                                endAdornment: (
                                                                    <InputAdornment position="end">
                                                                        <IconButton
                                                                            aria-label="toggle password visibility"
                                                                            onClick={handleClickShowPassword}
                                                                            onMouseDown={handleMouseDownPassword}
                                                                        >
                                                                            {showPassword ? (
                                                                                <Visibility color="primary" />
                                                                            ) : (
                                                                                <VisibilityOff color="primary" />
                                                                            )}
                                                                        </IconButton>
                                                                    </InputAdornment>
                                                                ),
                                                            },
                                                        }}
                                                    />
                                                )}
                                            />
                                        </Box>
                                    );
                                default:
                                    return (
                                        <Box display={"flex"} flexDirection={"column"} rowGap={1} key={index}>
                                            <FormLabel>{field.label}</FormLabel>
                                            <Controller
                                                name={field.name}
                                                control={control}
                                                defaultValue={""}
                                                render={({ field: controllerField }) => (
                                                    <TextField
                                                        {...controllerField}
                                                        type={field.type}
                                                        variant={field.variant}
                                                        disabled={field.disabled}
                                                        sx={{ ...field.sx }}
                                                        size="small"
                                                        helperText={helperText}
                                                        error={error}
                                                    />
                                                )}
                                            />
                                        </Box>
                                    );
                            }
                        })}
                    </Stack>
                </Grid>
                <Grid
                    container
                    justifyContent={"end"}
                    sx={{
                        mt: 2,
                    }}
                >
                    <Stack
                        columnGap={2}
                        flexDirection={"row"}
                        flexWrap={"wrap"}
                        sx={{
                            mt: "20px",
                        }}
                    >
                        {actions?.map((action, index) => (
                            <Button
                                key={index}
                                onClick={action.onClick}
                                // @ts-expect-error color
                                color={action.color || "primary"}
                                variant={action.variant || "text"}
                                sx={action.sx}
                                type={action.type}
                                endIcon={action.icon}
                                disabled={!isDirty && action.label !== CONSTANTS.FORM__DELETE__BUTTON}
                            >
                                <Typography fontSize={16} fontWeight={500} sx={{ textTransform: "capitalize" }}>
                                    {action.label}
                                </Typography>
                            </Button>
                        ))}
                    </Stack>
                </Grid>
            </Grid>
        </form>
    );
};

export default FormAdvanced;


================================================
File: src/components/admin/headerDashboard/HeaderDashboard.tsx
================================================
"use client";

import { Typography, Box, useTheme } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IHeaderDashboard {
    title: string;
    subtitle: string;
}

const HeaderDashboard = ({ title, subtitle }: IHeaderDashboard) => {
    const theme = useTheme();

    return (
        <Box
            component={"nav"}
            sx={{
                mb: "30px",
            }}
        >
            <Typography
                variant="h2"
                color={theme.vars.palette.greyAccent.main}
                fontWeight="bold"
                sx={{ m: "0 0 5px 0" }}
            >
                {title}
            </Typography>
            <Typography variant="h5" color={theme.vars.palette.green.light}>
                {subtitle}
            </Typography>
        </Box>
    );
};

export default HeaderDashboard;


================================================
File: src/components/admin/modal/Modal.tsx
================================================
"use client";

import React, { useEffect } from "react";
import {
    Button,
    Dialog,
    DialogActions,
    DialogContent,
    DialogContentText,
    DialogTitle,
    IconButton,
    Grid2 as Grid,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    SxProps,
    Typography,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import { useForm, Controller } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";

interface IModalProps {
    onClose?: () => void;
    onDataChange?: (values: any) => void;
    onSave?: (values: any) => void;
    open: boolean;
    initialValues?: any;
    fields?: FieldConfig[];
    validationSchema?: z.ZodSchema<any>;
    title: string;
    actions?: ActionConfig[];
    subTitle?: string;
}

type FieldConfig = {
    name: string;
    label: string;
    type?: string;
    options?: Array<{ label: string; value: any }>;
};

type ActionConfig = {
    onClick: () => void;
    label: string;
    type?: string;
    color?: "inherit" | "primary" | "secondary" | "success" | "error" | "info" | "warning" | "default";
    variant?: "text" | "outlined" | "contained";
    icon?: React.ReactNode;
    sx?: SxProps;
};

const Modal: React.FC<IModalProps> = ({
    onClose,
    initialValues,
    fields,
    validationSchema,
    onSave,
    title,
    actions,
    onDataChange,
    subTitle,
}) => {
    const router = useRouter();

    const {
        control,
        handleSubmit,
        watch,
        formState: { errors },
    } = useForm({
        defaultValues: initialValues || {},
        resolver: validationSchema ? zodResolver(validationSchema) : undefined,
    });

    const watchedValues = watch();

    useEffect(() => {
        if (onDataChange) {
            onDataChange(watchedValues);
        }
    }, [watchedValues, onDataChange]);

    const onSubmit = (values: any) => {
        if (onSave) {
            onSave(values);
        }
        if (onClose) {
            onClose();
        }
    };

    return (
        <Dialog open={true} onClose={onClose || (() => {})} fullWidth>
            <DialogTitle fontSize={"22px"}>
                {title}
                <IconButton style={{ position: "absolute", right: 2, top: 2 }} onClick={onClose || (() => {})}>
                    <CloseIcon color="action" />
                </IconButton>
            </DialogTitle>
            <DialogContent>
                <DialogContentText fontSize={"16px"}>{subTitle}</DialogContentText>
                {fields ? (
                    <form onSubmit={handleSubmit(onSubmit)}>
                        <Grid container spacing={4} sx={{ mt: 2 }}>
                            {fields.map((field, index: number) => (
                                <Grid size={{ xs: 6 }} key={index}>
                                    {field.type === "select" ? (
                                        <FormControl fullWidth size="medium">
                                            <InputLabel id={`${field.name}-label`}>{field.label}</InputLabel>
                                            <Controller
                                                name={field.name}
                                                control={control}
                                                render={({ field: selectField }) => (
                                                    <Select {...selectField} labelId={`${field.name}-label`}>
                                                        {field.options?.map((option, idx) => (
                                                            <MenuItem key={idx} value={option.value}>
                                                                {option.label}
                                                            </MenuItem>
                                                        ))}
                                                    </Select>
                                                )}
                                            />
                                        </FormControl>
                                    ) : (
                                        <Controller
                                            name={field.name}
                                            control={control}
                                            render={({ field: textField }) => (
                                                <TextField
                                                    {...textField}
                                                    label={field.label}
                                                    fullWidth
                                                    size="medium"
                                                    type={field.type || "text"}
                                                    error={!!errors[field.name]}
                                                    // @ts-expect-error helper
                                                    helperText={errors[field.name]?.message}
                                                />
                                            )}
                                        />
                                    )}
                                </Grid>
                            ))}
                        </Grid>
                        <DialogActions style={{ marginTop: "15px" }}>
                            {actions?.map((action, index) => (
                                <Button
                                    key={index}
                                    onClick={action.onClick}
                                    // @ts-expect-error color

                                    color={action.color || "secondary"}
                                    variant={action.variant || "text"}
                                    sx={action.sx}
                                    type={action.type}
                                    endIcon={action.icon}
                                >
                                    <Typography sx={{ textTransform: "capitalize" }}>{action.label}</Typography>
                                </Button>
                            ))}
                        </DialogActions>
                    </form>
                ) : (
                    <DialogActions style={{ marginTop: "15px" }}>
                        {actions?.map((action, index) => (
                            <Button
                                key={index}
                                onClick={() => {
                                    action.onClick();
                                    onClose && onClose();
                                }}
                                // @ts-expect-error color

                                color={action.color || "secondary"}
                                variant={action.variant || "text"}
                                sx={action.sx}
                                type={action.type === "submit" || action.type === "reset" ? action.type : ""}
                                endIcon={action.icon}
                            >
                                {action.label}
                            </Button>
                        ))}
                    </DialogActions>
                )}
            </DialogContent>
        </Dialog>
    );
};

export default Modal;


================================================
File: src/components/admin/rightPanel/RightPanel.tsx
================================================
"use client";

import React, { useState } from "react";
import {
    Button,
    Grid2 as Grid,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Drawer,
    Box,
    Typography,
    Step,
    StepLabel,
    useTheme,
    Stepper,
    StepButton,
    IconButton,
    SxProps,
    FormLabel,
    InputAdornment,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import { Visibility, VisibilityOff } from "@mui/icons-material";
import * as CONSTANTS from "@/constants/Constants";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

interface IDrawerProps {
    onClose?: () => void;
    onSave?: (values: any) => void;
    onDataChange?: (values: any) => void;
    defaultValues?: any;
    fields?: FieldConfig[];
    schema?: any;
    title?: string;
    actions?: ActionConfig[];
    formRef?: React.Ref<any>;
    subTitle?: string;
    steps?: StepConfig[];
}

type FieldConfig = {
    name: string;
    label: string;
    type?: string;
    options?: Array<{ label: string; value: any }>;
    variant?: any;
    disabled?: boolean;
    hidden?: boolean;
    sx: {
        gridColumn: string;
    };
};

type ActionConfig = {
    onClick: () => void;
    label: string;
    type?: string;
    color?: "inherit" | "primary" | "secondary" | "success" | "error" | "info" | "warning" | "default";
    variant?: "text" | "outlined" | "contained";
    icon?: React.ReactNode;
    sx?: SxProps;
};

type StepConfig = {
    title: string;
    fields: FieldConfig[];
    validationSchema: any;
    actions?: ActionConfig[];
};

const RightPanel: React.FC<IDrawerProps> = ({
    onClose,
    defaultValues,
    fields,
    schema,
    onSave,
    actions,
    formRef,
    subTitle,
    steps,
    title,
}) => {
    const [activeStep, setActiveStep] = useState(0);
    const [showPassword, setShowPassword] = useState(false);

    const theme = useTheme();

    const handleClickShowPassword = () => setShowPassword(!showPassword);
    const handleMouseDownPassword = () => setShowPassword(!showPassword);

    const isLastStep = () => activeStep === (steps ? steps.length - 1 : 0);

    // const handleNext = () => {
    //     setActiveStep((prevActiveStep: any) => prevActiveStep + 1);
    // };

    const handleBack = () => {
        setActiveStep((prevActiveStep: any) => prevActiveStep - 1);
    };

    const handleStep = (step: any) => () => {
        setActiveStep(step);
    };

    const {
        control,
        handleSubmit,
        // watch,
        // reset,
        formState: { errors, isDirty },
    } = useForm({
        defaultValues,
        resolver: zodResolver(schema),
        mode: "onBlur",
    });

    return (
        <Drawer variant={"temporary"} component={"aside"} anchor={"right"} open={true} onClose={onClose}>
            <Box
                sx={{
                    width: "100%",
                    height: "100%",
                    px: 2,
                    py: 4,
                    bgcolor: theme.vars.palette.background.default,
                }}
            >
                <Box
                    display="flex"
                    justifyContent="space-between"
                    alignItems="center"
                    sx={{
                        mb: 2,
                    }}
                >
                    {title && <Typography variant="h3">{title}</Typography>}
                    <IconButton onClick={() => onClose && onClose()}>
                        <CloseIcon color="action" />
                    </IconButton>
                </Box>
                {subTitle && (
                    <Typography
                        variant="subtitle1"
                        color="textSecondary"
                        sx={{
                            mb: 4,
                        }}
                    >
                        {subTitle}
                    </Typography>
                )}
                {steps && (
                    <Stepper activeStep={activeStep} alternativeLabel>
                        {steps.map((stepConfig, index) => (
                            <Step key={index}>
                                <StepButton onClick={handleStep(index)}>
                                    <StepLabel>{stepConfig.title}</StepLabel>
                                </StepButton>
                            </Step>
                        ))}
                    </Stepper>
                )}
                <form onSubmit={handleSubmit(onSave!)} ref={formRef}>
                    <Grid
                        container
                        spacing={3}
                        sx={{
                            mt: 3,
                        }}
                    >
                        {(steps! ? steps[activeStep].fields : fields!).map((field, index: number) => (
                            <Grid size={{ xs: 6 }} key={index}>
                                {field.type === "select" ? (
                                    <FormControl>
                                        <InputLabel id={`${field.name}-label`}>{field.label}</InputLabel>
                                        <Controller
                                            name={field.name}
                                            control={control}
                                            render={({ field: controllerField }) => (
                                                <Select
                                                    labelId={`${field.name}-label`}
                                                    variant={field.variant}
                                                    size="small"
                                                    {...controllerField}
                                                    sx={field.sx}
                                                >
                                                    {field.options?.map((option, index: number) => (
                                                        <MenuItem key={index} value={option.value}>
                                                            {option.label}
                                                        </MenuItem>
                                                    ))}
                                                </Select>
                                            )}
                                        />
                                    </FormControl>
                                ) : field.type === "password" ? (
                                    <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                                        <FormLabel>{field.label}</FormLabel>
                                        <Controller
                                            name={field.name}
                                            control={control}
                                            render={({ field: controllerField }) => (
                                                <TextField
                                                    {...controllerField}
                                                    variant={field.variant}
                                                    size="small"
                                                    sx={field.sx}
                                                    type={showPassword ? "text" : "password"}
                                                    autoComplete={"on"}
                                                    helperText={errors[field.name]?.message as string | undefined}
                                                    error={!!errors[field.name]}
                                                    InputProps={{
                                                        endAdornment: (
                                                            <InputAdornment position="end">
                                                                <IconButton
                                                                    aria-label="toggle password visibility"
                                                                    onClick={handleClickShowPassword}
                                                                    onMouseDown={handleMouseDownPassword}
                                                                >
                                                                    {showPassword ? (
                                                                        <Visibility color="primary" />
                                                                    ) : (
                                                                        <VisibilityOff color="primary" />
                                                                    )}
                                                                </IconButton>
                                                            </InputAdornment>
                                                        ),
                                                    }}
                                                />
                                            )}
                                        />
                                    </Box>
                                ) : (
                                    <Box display={"flex"} flexDirection={"column"} rowGap={1}>
                                        <FormLabel>{field.label}</FormLabel>
                                        <Controller
                                            name={field.name}
                                            control={control}
                                            render={({ field: controllerField }) => (
                                                <TextField
                                                    {...controllerField}
                                                    type={field.type}
                                                    variant={field.variant}
                                                    disabled={field.disabled}
                                                    sx={{ ...field.sx }}
                                                    size="small"
                                                    helperText={errors[field.name]?.message as string | undefined}
                                                    error={!!errors[field.name]}
                                                />
                                            )}
                                        />
                                    </Box>
                                )}
                            </Grid>
                        ))}
                    </Grid>
                    <Box
                        display={"flex"}
                        gap={"10px"}
                        justifyContent={"end"}
                        sx={{
                            mt: 3,
                        }}
                    >
                        {(steps ? steps[activeStep].actions! : actions!).map((action, index) => (
                            <Button
                                key={index}
                                onClick={action.onClick}
                                // @ts-expect-error color
                                color={action.color || "primary"}
                                variant={action.variant || "text"}
                                sx={action.sx}
                                type={action.type}
                                endIcon={action.icon}
                                disabled={isDirty || action.label === CONSTANTS.FORM__DELETE__BUTTON ? false : true}
                            >
                                <Typography fontSize={16} fontWeight={500} sx={{ textTransform: "capitalize" }}>
                                    {action.label}
                                </Typography>
                            </Button>
                        ))}
                    </Box>
                    {steps && (
                        <Box
                            display="flex"
                            justifyContent="space-between"
                            sx={{
                                mt: 12,
                            }}
                        >
                            <Button disabled={activeStep === 0} onClick={handleBack} variant="contained">
                                Mbrapa
                            </Button>
                            {!isLastStep() && (
                                <Button variant="contained" color="primary" type="submit">
                                    Tjetra
                                </Button>
                            )}
                        </Box>
                    )}
                </form>
            </Box>
        </Drawer>
    );
};

export default RightPanel;


================================================
File: src/components/admin/sidebar/Sidebar.tsx
================================================
"use client";

import { useEffect, useState } from "react";
import {
    Box,
    List,
    Typography,
    Avatar,
    Drawer,
    IconButton,
    useTheme,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
} from "@mui/material";
import AccountCircleIcon from "@mui/icons-material/AccountCircle";
import CloseIcon from "@mui/icons-material/Close";
import { useStore } from "@/store/store";
import { SidebarItem } from "./components/SidebarItem";
import LogoutIcon from "@mui/icons-material/Logout";
import { useRouter } from "next/navigation";
import { signOut, useSession } from "next-auth/react";
import { IS_BROWSER } from "@/utils/helpers/utils";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface ISidebarItem {
    label: string;
    to: string;
    icon: JSX.Element;
    index: number;
}

interface ISidebarProps {
    sidebarItems: ISidebarItem[];
}

const Sidebar = ({ sidebarItems }: ISidebarProps) => {
    const [selectedLabel, setSelectedLabel] = useState("");
    const [height, setHeight] = useState(0);

    const { data: session } = useSession();
    const { isOpenSidebarAdmin, setIsOpenSidebarAdmin } = useStore();
    const router = useRouter();
    const theme = useTheme();

    const handleItemClick = (title: string, to: string) => {
        setSelectedLabel(title);
        router.push(to);

        if (height < 768) {
            setIsOpenSidebarAdmin(false);
        }
    };

    const onClose = () => {
        setIsOpenSidebarAdmin(false);
    };

    async function onLogout() {
        await signOut();
        router.push("/login");
    }

    useEffect(() => {
        if (IS_BROWSER) {
            setHeight(window.innerWidth);
        }
    }, []);

    return (
        <Drawer
            variant={"persistent"}
            anchor={"left"}
            open={isOpenSidebarAdmin}
            component={"aside"}
            onClose={onClose}
            PaperProps={{
                sx: { backgroundColor: theme.vars.palette.primary.dark, paddingLeft: 1, paddingRight: 1 },
            }}
        >
            <Box
                sx={{
                    mt: 1,
                }}
            >
                <Box
                    display="flex"
                    justifyContent="end"
                    alignItems="center"
                    sx={{
                        mb: 1,
                    }}
                >
                    <IconButton onClick={onClose}>
                        <CloseIcon color="action" />
                    </IconButton>
                </Box>
                <Box
                    display="flex"
                    alignItems="center"
                    sx={{
                        mb: 1,
                        ml: 1,
                    }}
                >
                    <Avatar>
                        <AccountCircleIcon />
                    </Avatar>
                    <Box
                        sx={{
                            ml: 2,
                        }}
                    >
                        <Typography variant="body2" sx={{ color: theme.vars.palette.primary.main }}>
                            {session?.user && `@${session?.user?.userName}`}
                        </Typography>
                    </Box>
                </Box>
                <List disablePadding>
                    {sidebarItems?.map((item: any, index: number) => (
                        <SidebarItem
                            key={index}
                            item={item}
                            index={index}
                            selectedLabel={selectedLabel}
                            handleItemClick={handleItemClick}
                        />
                    ))}
                    <ListItem
                        value={"logout"}
                        sx={{
                            py: 3,
                            px: 3,
                        }}
                    >
                        <ListItemButton
                            sx={{
                                color: theme.vars.palette.greyAccent.main,
                                "&:hover": {
                                    backgroundColor: theme.vars.palette.secondary.light,
                                    "& .MuiListItemIcon-root": {
                                        color: theme.vars.palette.greyAccent.light,
                                    },
                                    "& .MuiListItemText-primary": {
                                        color: theme.vars.palette.greyAccent.light,
                                    },
                                },
                            }}
                            onClick={onLogout}
                        >
                            <ListItemIcon>
                                <LogoutIcon />
                            </ListItemIcon>
                            <ListItemText primary={"Logout"} />
                        </ListItemButton>
                    </ListItem>
                </List>
            </Box>
        </Drawer>
    );
};

export default Sidebar;


================================================
File: src/components/admin/sidebar/components/SidebarItem.tsx
================================================
"use client";

import { ListItem, ListItemButton, ListItemIcon, ListItemText, useTheme } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface ISidebarItemProps {
    index: number;
    item: any;
    selectedLabel: string;
    handleItemClick: (title: string, to: string, label?: any) => void;
}

export const SidebarItem = ({ index, item, selectedLabel, handleItemClick }: ISidebarItemProps) => {
    const theme = useTheme();

    return (
        <ListItem key={index} value={item.label}>
            <ListItemButton
                sx={{
                    color: theme.vars.palette.greyAccent.main,
                    "&.Mui-selected": {
                        backgroundColor: theme.vars.palette.secondary.light,
                        color: theme.vars.palette.greyAccent.main,
                        "&:hover": {
                            backgroundColor: theme.vars.palette.secondary.light,
                        },
                    },
                    "&:hover": {
                        backgroundColor: theme.vars.palette.secondary.light,
                        "& .MuiListItemIcon-root": {
                            color: theme.vars.palette.greyAccent.main,
                        },
                        "& .MuiListItemText-primary": {
                            color: theme.vars.palette.greyAccent.main,
                        },
                    },
                }}
                selected={selectedLabel === item.label}
                onClick={() => {
                    handleItemClick(item.label, item.to, { label: item.label, index });
                }}
            >
                <ListItemIcon>{item.icon}</ListItemIcon>
                <ListItemText primary={item.label} />
            </ListItemButton>
        </ListItem>
    );
};


================================================
File: src/components/admin/sidebar/components/SidebarItems.tsx
================================================
import HomeOutlinedIcon from "@mui/icons-material/HomeOutlined";
import PeopleOutlinedIcon from "@mui/icons-material/PeopleOutlined";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import LiveTvIcon from "@mui/icons-material/LiveTv";
import MovieIcon from "@mui/icons-material/Movie";
import PersonIcon from "@mui/icons-material/Person";
import PlayCircleOutlineIcon from "@mui/icons-material/PlayCircleOutline";
import PlaylistPlayIcon from "@mui/icons-material/PlaylistPlay";
import GroupWorkIcon from "@mui/icons-material/GroupWork";

export const SidebarItems = [
    {
        label: "Dashboard",
        to: "/admin/dashboard",
        icon: <HomeOutlinedIcon />,
        index: 0,
    },
    {
        label: "Users",
        to: "/admin/users",
        icon: <PeopleOutlinedIcon />,
        index: 1,
    },
    {
        label: "Movies",
        to: "/admin/movies",
        icon: <LocalMoviesIcon />,
        index: 2,
    },
    {
        label: "Series",
        to: "/admin/series",
        icon: <LiveTvIcon />,
        index: 3,
    },
    {
        label: "Seasons",
        to: "/admin/seasons",
        icon: <PlaylistPlayIcon />,
        index: 4,
    },
    {
        label: "Episodes",
        to: "/admin/episodes",
        icon: <PlayCircleOutlineIcon />,
        index: 5,
    },
    {
        label: "Actors",
        to: "/admin/actors",
        icon: <PersonIcon />,
        index: 6,
    },
    {
        label: "Crews",
        to: "/admin/crews",
        icon: <GroupWorkIcon />,
        index: 7,
    },
    {
        label: "Genres",
        to: "/admin/genres",
        icon: <MovieIcon />,
        index: 8,
    },
];


================================================
File: src/components/admin/tableAdmin/TableAdmin.tsx
================================================
"use client";

// #region "Imports"
import { useState, useEffect, useMemo } from "react";
import { MRT_ColumnFiltersState, MRT_SortingState, useMaterialReactTable } from "material-react-table";
import { ListItemIcon, MenuItem, Typography } from "@mui/material";
import { Edit, Delete, CheckOutlined, WarningOutlined } from "@mui/icons-material";
import { useModal } from "@/providers/ModalProvider";
import * as CONSTANTS from "@/constants/Constants";
import { useRouter } from "next/navigation";
import { getGenresWithFilters } from "@/actions/genre.actions";
import { getUsersWithFilters } from "@/actions/user/user.actions";
import { getMoviesWithFilters } from "@/actions/movie.actions";
import { getSeriesWithFilters } from "@/actions/serie.actions";
import { getActorsWithFilters } from "@/actions/actor.actions";
import { getEpisodesWithFilters } from "@/actions/episode.actions";
import { getSeasonsWithFilters } from "@/actions/season.actions";
import { getCrewMembersWithFilters } from "@/actions/crew.actions";
import { getColumns } from "./utils/tableColumns";
import { handleDeleteById, handleMassiveDelete } from "./utils/tableDelete";
import { TableToolbar } from "./components/TableToolbar";
import { FilterOperator } from "@/types/filterOperators";
// #endregion

// #region "Interfaces"
interface ITableAdminProps {
    page: string;
    handleAddItem: () => void;
}

// const mapFilterOperator = (operator: string): FilterOperator => {
//     switch (operator) {
//         case "contains":
//             return "equals";
//         case "greaterThan":
//             return "gt";
//         case "lessThan":
//             return "lt";
//         case "equals":
//             return "equals";
//         default:
//             return "equals";
//     }
// };
// #endregion

const TableAdmin = ({ page, handleAddItem }: ITableAdminProps) => {
    // #region "State Management, Hooks"
    const [rows, setRows] = useState<any[]>([]);
    const [rowsCount, setRowsCount] = useState<number>(0);
    const [rowSelection, setRowSelection] = useState<any>({});
    const [isError, setIsError] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [isRefetching, setIsRefetching] = useState(false);

    const [columnFilters, setColumnFilters] = useState<MRT_ColumnFiltersState>([]);
    const [columnFiltersFns, setColumnFiltersFns] = useState<any>([]);
    const [globalFilter, setGlobalFilter] = useState("");
    const [sorting, setSorting] = useState<MRT_SortingState>([]);
    const [pagination, setPagination] = useState({
        pageIndex: 0,
        pageSize: 10,
    });
    const [open, setOpen] = useState(false);

    const router = useRouter();
    const { openModal } = useModal();
    // #endregion

    // #region "Delete methods"
    function handleDelete(id: number) {
        openModal({
            onClose: () => setOpen(false),
            title: `Delete selected ${page}`,
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        const response = await handleDeleteById({ page, id });

                        if (response) {
                            await fetchData();
                            setRowSelection([]);
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Do you want to delete selected rows ?",
        });
    }

    function handleBulkDelete() {
        const selectedIds = Object.keys(rowSelection);

        openModal({
            onClose: () => setOpen(false),
            title: `Delete selected ${page}`,
            actions: [
                {
                    label: CONSTANTS.MODAL__DELETE__NO,
                    onClick: () => setOpen(false),
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#ff5252",
                    },
                    icon: <WarningOutlined />,
                },
                {
                    label: CONSTANTS.MODAL__DELETE__YES,
                    onClick: async () => {
                        const results = await handleMassiveDelete({ page, selectedIds });

                        if (results.some((result) => result !== null)) {
                            await fetchData();
                            setRowSelection([]);
                        }
                    },
                    type: "submit",
                    color: "secondary",
                    variant: "contained",
                    sx: {
                        bgcolor: "#30969f",
                    },
                    icon: <CheckOutlined />,
                },
            ],
            subTitle: "Do you want to delete selected rows ?",
        });
    }
    // #endregion

    // #region "Data fetching"
    const fetchData = async () => {
        if (!rows?.length) {
            setIsLoading(true);
        } else {
            setIsRefetching(true);
        }

        try {
            let response: any;

            const baseParams = {
                page: Number(pagination?.pageIndex + 1),
                perPage: Number(pagination?.pageSize),
                ...(sorting?.length > 0 && {
                    ascOrDesc: sorting[0].desc ? "desc" : "asc",
                    sortBy: sorting[0].id as string,
                }),
            };

            const getFilterParams = () => {
                if (globalFilter?.length > 0) {
                    return {
                        filterNameString:
                            page === "users"
                                ? "userName"
                                : page === "genres"
                                  ? "name"
                                  : page === "actors"
                                    ? "name"
                                    : page === "crew"
                                      ? "fullname"
                                      : "title",
                        filterValue: globalFilter as string,
                        filterOperatorString: "contains" as FilterOperator,
                    };
                }

                if (columnFilters?.length > 0) {
                    const filterValue = columnFilters[0].value;
                    const processedValue =
                        !isNaN(Number(filterValue)) && typeof filterValue !== "boolean"
                            ? Number(filterValue)
                            : String(filterValue);

                    return {
                        filterNameString: columnFilters[0].id as string,
                        filterValue: processedValue,
                        filterOperatorString: (columnFiltersFns[0] === "contains"
                            ? "contains"
                            : columnFiltersFns[0] === "equals"
                              ? "equals"
                              : columnFiltersFns[0] === "greaterThan"
                                ? ">"
                                : columnFiltersFns[0] === "lessThan"
                                  ? "<"
                                  : "contains") as FilterOperator,
                    };
                }

                return {};
            };

            const queryParams = {
                ...baseParams,
                ...getFilterParams(),
            };

            switch (page) {
                case "series":
                    response = await getSeriesWithFilters(queryParams);
                    setRows(response.rows);
                    setRowsCount(response.count);
                    break;
                case "movies":
                    response = await getMoviesWithFilters(queryParams);
                    setRows(response.movies);
                    setRowsCount(response.count);
                    break;
                case "genres":
                    response = await getGenresWithFilters(queryParams);
                    setRows(response.rows);
                    setRowsCount(response.count);
                    break;
                case "users":
                    response = await getUsersWithFilters(queryParams);
                    setRows(response.rows);
                    setRowsCount(response.count);
                    break;
                case "actors":
                    response = await getActorsWithFilters(queryParams);
                    setRows(response.actors);
                    setRowsCount(response.count);
                    break;
                case "episodes":
                    response = await getEpisodesWithFilters(queryParams);
                    setRows(response.episodes);
                    setRowsCount(response.count);
                    break;
                case "seasons":
                    response = await getSeasonsWithFilters(queryParams);
                    setRows(response.seasons);
                    setRowsCount(response.count);
                    break;
                case "crews":
                    response = await getCrewMembersWithFilters(queryParams);
                    setRows(response.crewMembers);
                    setRowsCount(response.count);
                    break;
                default:
                    response = { rows: [], count: 0 };
            }
        } catch (error) {
            setIsError(true);
            console.error(error);
        }

        setIsError(false);
        setIsLoading(false);
        setIsRefetching(false);
    };

    useEffect(() => {
        fetchData();
    }, [columnFilters, globalFilter, pagination.pageIndex, pagination.pageSize, sorting]);
    // #endregion

    // #region "Table, Columns configuration"
    const columns = useMemo(() => getColumns(page), [page]);

    const table = useMaterialReactTable({
        columns,
        data: rows,
        rowCount: rowsCount,
        getRowId: (row) => String(row.id),
        enableColumnOrdering: true,
        enableRowSelection: true,
        enableFullScreenToggle: true,
        enablePagination: true,
        enableRowActions: true,
        enablePinning: true,
        enableSortingRemoval: true,
        enableColumnFilterModes: true,
        enableGlobalFilter: true,
        enableColumnActions: true,
        enableColumnFilters: true,
        enableClickToCopy: true,
        enableStickyHeader: true,
        enableStickyFooter: true,
        manualFiltering: true,
        manualPagination: true,
        manualSorting: true,
        muiToolbarAlertBannerProps: isError
            ? {
                  color: "error",
                  children: "Error loading data",
              }
            : undefined,
        onColumnFiltersChange: setColumnFilters,
        onColumnFilterFnsChange: setColumnFiltersFns,
        onGlobalFilterChange: setGlobalFilter,
        onPaginationChange: setPagination,
        onSortingChange: setSorting,
        initialState: {
            columnVisibility: { id: false },
            showColumnFilters: false,
            showGlobalFilter: true,
            showLoadingOverlay: false,
            isFullScreen: false,
            density: "compact",
            columnPinning: {
                left: ["mrt-row-expand", "mrt-row-select"],
                right: ["mrt-row-actions"],
            },
            columnFilters,
            globalFilter,
            isLoading,
            pagination,
            showAlertBanner: isError,
            showProgressBars: isRefetching,
            sorting,
        },
        onRowSelectionChange: (updatedSelection) => {
            if (typeof updatedSelection === "function") {
                setRowSelection((prev: any) => {
                    const newSelection = updatedSelection(prev);
                    const allSelected = rows.every((row) => newSelection[row.id]);
                    const someSelected = rows.some((row) => newSelection[row.id]);

                    if (allSelected) {
                        return rows.reduce(
                            (acc, row) => {
                                acc[row.id] = true;
                                return acc;
                            },
                            {} as Record<string, boolean>,
                        );
                    } else if (!someSelected) {
                        return {};
                    }

                    return newSelection;
                });
            } else {
                setRowSelection(updatedSelection);
            }
        },
        state: {
            rowSelection,
            columnFilters,
            globalFilter,
            isLoading,
            pagination,
            showAlertBanner: isError,
            showProgressBars: isRefetching,
            sorting,
        },
        paginationDisplayMode: "pages",
        positionToolbarAlertBanner: "bottom",
        muiSearchTextFieldProps: {
            size: "small",
            variant: "outlined",
        },
        muiTablePaperProps: {
            style: {
                padding: 18,
            },
        },
        muiPaginationProps: {
            color: "secondary",
            rowsPerPageOptions: [5, 10, 15, 20],
            shape: "rounded",
            size: "small",
            variant: "outlined",
            style: {
                paddingTop: 6,
            },
            sx: {
                ".MuiPaginationItem-root": {
                    "&:hover": {
                        backgroundColor: "#30969f33",
                    },
                    "&.Mui-selected": {
                        backgroundColor: "#30969f",
                        color: "white",
                        "&:hover": {
                            backgroundColor: "#30969fcc",
                        },
                    },
                },
            },
        },
        renderRowActionMenuItems: ({ closeMenu, row }) => [
            <MenuItem
                key={0}
                onClick={() => {
                    router.push(`/admin/${page}/${row.original.id}`);
                    closeMenu();
                }}
                sx={{ m: 0 }}
            >
                <ListItemIcon>
                    <Edit />
                </ListItemIcon>
                <Typography>Edit</Typography>
            </MenuItem>,
            <MenuItem
                key={1}
                onClick={async () => {
                    handleDelete(Number(row.id));
                    closeMenu();
                }}
                sx={{ m: 0 }}
            >
                <ListItemIcon>
                    <Delete />
                </ListItemIcon>
                <Typography>Delete</Typography>
            </MenuItem>,
        ],
        renderTopToolbar: ({ table }) => {
            return (
                <TableToolbar
                    table={table}
                    handleFetchData={fetchData}
                    handleAddItem={handleAddItem}
                    handleMassiveDelete={handleBulkDelete}
                    page={page}
                />
            );
        },
    });
    // #endregion

    return {
        table,
    };
};

export default TableAdmin;


================================================
File: src/components/admin/tableAdmin/components/ExportMenu.tsx
================================================
"use client";

import { Button, Menu, MenuItem, ListItemIcon, Theme } from "@mui/material";
import { SaveAlt, PictureAsPdf, TableChart } from "@mui/icons-material";

interface ExportMenuProps {
    anchorEl: HTMLElement | null;
    setAnchorEl: (anchor: HTMLElement | null) => void;
    handleExport: (format: "pdf" | "csv" | "excel") => void;
    theme: Theme;
}

export const ExportMenu = ({ anchorEl, setAnchorEl, handleExport, theme }: ExportMenuProps) => (
    <>
        <Button
            variant="contained"
            color="primary"
            onClick={(e) => setAnchorEl(e.currentTarget)}
            startIcon={<SaveAlt />}
            sx={{
                height: "36px",
                backgroundColor: theme.vars.palette.secondary.main,
                color: theme.vars.palette.common.white,
                "&:hover": {
                    backgroundColor: theme.vars.palette.primary.dark,
                },
            }}
        >
            Export
        </Button>
        <Menu
            anchorEl={anchorEl}
            open={Boolean(anchorEl)}
            onClose={() => setAnchorEl(null)}
            sx={{
                "& .MuiPaper-root": {
                    backgroundColor: theme.vars.palette.background.paper,
                    boxShadow: theme.shadows[3],
                },
            }}
        >
            {[
                { format: "pdf", label: "PDF", Icon: PictureAsPdf },
                { format: "csv", label: "CSV", Icon: TableChart },
                { format: "excel", label: "Excel", Icon: SaveAlt },
            ].map(({ format, label, Icon }) => (
                <MenuItem
                    key={format}
                    onClick={() => handleExport(format as "pdf" | "csv" | "excel")}
                    sx={{
                        "&:hover": {
                            backgroundColor: theme.vars.palette.action.hover,
                        },
                    }}
                >
                    <ListItemIcon>
                        <Icon sx={{ color: theme.vars.palette.primary.main }} />
                    </ListItemIcon>
                    Export to {label}
                </MenuItem>
            ))}
        </Menu>
    </>
);


================================================
File: src/components/admin/tableAdmin/components/TableToolbar.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { MRT_TableInstance, MRT_Row } from "material-react-table";
import { useState } from "react";
import { useTheme } from "@mui/material/styles";
import { utils, writeFile } from "xlsx";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";
import { ExportMenu } from "./ExportMenu";
import { ToolbarActions } from "./ToolbarActions";
import { ToolbarFilters } from "./ToolbarFilters";

interface TableToolbarProps {
    table: MRT_TableInstance<any>;
    handleFetchData: () => Promise<void>;
    handleAddItem: () => void;
    handleMassiveDelete: () => void;
    page: string;
}

export const TableToolbar = ({
    table,
    handleFetchData,
    handleAddItem,
    handleMassiveDelete,
    page,
}: TableToolbarProps) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const theme = useTheme();

    const getVisibleColumns = () => {
        return table
            .getAllColumns()
            .filter(
                (column) =>
                    column.getIsVisible() &&
                    !["mrt-row-actions", "select", "mrt-row-expand", "mrt-row-select", "Actions"].includes(column.id),
            )
            .map((column) => ({
                accessorKey: column.id,
                header: column.columnDef.header?.toString() || column.id,
            }));
    };

    const prepareExportData = () => {
        const visibleColumns = getVisibleColumns().filter(
            (column) => !["mrt-row-actions", "select", "mrt-row-expand", "mrt-row-select"].includes(column.accessorKey),
        );

        return table.getRowModel().rows.map((row: MRT_Row<any>) => {
            const rowData: Record<string, any> = {};
            rowData["ID"] = row.original.id;

            visibleColumns.forEach((column) => {
                const value = row.getValue(column.accessorKey);
                rowData[column.header] = value !== null && value !== undefined ? value : "";
            });

            return rowData;
        });
    };

    const getEntityName = (page: string) => {
        return page.charAt(0).toUpperCase() + page.slice(1).toLowerCase();
    };

    const handleExportPDF = () => {
        const doc = new jsPDF({
            orientation: "landscape",
            unit: "mm",
            format: "a3",
        });

        const entityName = getEntityName(page);
        doc.setFontSize(16);
        doc.text(`${entityName} Export Data`, 14, 15);
        doc.setFontSize(10);
        doc.text(`Generated on: ${new Date().toLocaleString()}`, 14, 25);

        const exportData = prepareExportData();
        const visibleColumns = getVisibleColumns().filter(
            (column) =>
                !["mrt-row-actions", "select", "mrt-row-expand", "mrt-row-select", "Actions"].includes(
                    column.accessorKey,
                ),
        );

        const headers = ["ID", ...visibleColumns.map((col) => col.header)];
        const rows = exportData.map((row) =>
            headers.map((header) => {
                const value = row[header];
                return value !== null && value !== undefined ? String(value) : "";
            }),
        );

        const getColumnWidths = () => {
            const widths: { [key: number]: number } = {};

            headers.forEach((header, index) => {
                const maxLength = Math.max(header.length, ...rows.map((row) => String(row[index]).length));

                widths[index] = Math.min(Math.max(maxLength * 2.5, 20), 50);
            });

            return widths;
        };

        autoTable(doc, {
            head: [headers],
            body: rows,
            startY: 35,
            styles: {
                fontSize: 7,
                cellPadding: 1.5,
                lineWidth: 0.5,
                lineColor: [80, 80, 80],
                overflow: "linebreak",
            },
            headStyles: {
                fillColor: [48, 150, 159],
                textColor: 255,
                fontSize: 8,
                fontStyle: "bold",
                halign: "left",
                cellPadding: 2,
                lineWidth: 0.5,
                lineColor: [80, 80, 80],
                minCellWidth: 15,
            },
            bodyStyles: {
                halign: "left",
                valign: "middle",
                cellPadding: 2,
                fontSize: 7,
                lineWidth: 0.5,
                lineColor: [80, 80, 80],
            },
            columnStyles: headers.reduce(
                (acc, _, index) => {
                    acc[index] = {
                        cellWidth: getColumnWidths()[index],
                        minCellWidth: 15,
                        maxCellWidth: 50,
                        cellPadding: 2,
                        overflow: "linebreak",
                    };

                    return acc;
                },
                {} as Record<number, any>,
            ),
            alternateRowStyles: {
                fillColor: [245, 245, 245],
            },
            margin: { top: 35, left: 10, right: 10 },
            theme: "grid",
            tableWidth: "auto",
            didParseCell: function (data) {
                if (data.section === "head") {
                    data.cell.styles.fillColor = [48, 150, 159];
                    data.cell.styles.textColor = 255;
                    data.cell.styles.fontSize = 8;
                    data.cell.styles.fontStyle = "bold";
                }

                if (Array.isArray(data.cell.text)) {
                    data.cell.text = data.cell.text.map((text) =>
                        text.length > 50 ? text.slice(0, 47) + "..." : text,
                    );
                }
            },
            didDrawCell: function (data) {
                if (data.cell.raw) {
                    const { x, y, width, height } = data.cell;
                    doc.setDrawColor(80, 80, 80);
                    doc.setLineWidth(0.5);
                    doc.rect(x, y, width, height);
                }
            },
        });

        const fileName = `${page.toLowerCase()}_export_${new Date().toISOString().split("T")[0]}.pdf`;
        doc.save(fileName);
    };

    const handleExportCSV = () => {
        const exportData = prepareExportData();
        const headers = Object.keys(exportData[0] || {});
        const csvContent = [
            headers.join(","),
            ...exportData.map((row) =>
                headers
                    .map((header) => {
                        const value = row[header];
                        return value !== null && value !== undefined ? `"${value}"` : '""';
                    })
                    .join(","),
            ),
        ].join("\n");

        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");

        link.href = URL.createObjectURL(blob);
        const fileName = `${page.toLowerCase()}_export_${new Date().toISOString().split("T")[0]}.csv`;
        link.download = fileName;
        link.click();
    };

    const handleExportExcel = () => {
        const exportData = prepareExportData();
        const worksheet = utils.json_to_sheet(exportData);
        const workbook = utils.book_new();

        utils.book_append_sheet(workbook, worksheet, "Data");
        const fileName = `${page.toLowerCase()}_export_${new Date().toISOString().split("T")[0]}.xlsx`;
        writeFile(workbook, fileName);
    };

    const handleExport = (format: "pdf" | "csv" | "excel") => {
        const exportHandlers = {
            pdf: handleExportPDF,
            csv: handleExportCSV,
            excel: handleExportExcel,
        };

        exportHandlers[format]();
        setAnchorEl(null);
    };

    return (
        <Box
            sx={{
                display: "flex",
                gap: "1rem",
                p: "10px",
                justifyContent: "space-between",
            }}
        >
            <ToolbarFilters table={table} handleFetchData={handleFetchData} />
            <Box sx={{ display: "flex", gap: "1rem", alignItems: "center" }}>
                <ExportMenu anchorEl={anchorEl} setAnchorEl={setAnchorEl} handleExport={handleExport} theme={theme} />
                <ToolbarActions table={table} handleAddItem={handleAddItem} handleMassiveDelete={handleMassiveDelete} />
            </Box>
        </Box>
    );
};


================================================
File: src/components/admin/tableAdmin/components/ToolbarActions.tsx
================================================
"use client";

import { Box, Button, Typography } from "@mui/material";
import { Add, Delete } from "@mui/icons-material";
import { MRT_TableInstance } from "material-react-table";

interface ToolbarActionsProps {
    table: MRT_TableInstance<any>;
    handleAddItem: () => void;
    handleMassiveDelete: () => void;
}

export const ToolbarActions = ({ table, handleAddItem, handleMassiveDelete }: ToolbarActionsProps) => (
    <Box sx={{ display: "flex", gap: "1rem" }}>
        <Button color="success" onClick={handleAddItem} variant="contained" startIcon={<Add />}>
            <Typography sx={{ textTransform: "capitalize" }}>Add</Typography>
        </Button>
        <Button
            color="error"
            disabled={Object.keys(table.getState().rowSelection).length === 0}
            onClick={handleMassiveDelete}
            variant="contained"
            startIcon={<Delete />}
        >
            <Typography sx={{ textTransform: "capitalize" }}>Delete</Typography>
        </Button>
    </Box>
);


================================================
File: src/components/admin/tableAdmin/components/ToolbarFilters.tsx
================================================
"use client";

import { Box, IconButton, Tooltip } from "@mui/material";
import RefreshIcon from "@mui/icons-material/Refresh";
import {
    MRT_GlobalFilterTextField,
    MRT_ShowHideColumnsButton,
    MRT_ToggleDensePaddingButton,
    MRT_ToggleFiltersButton,
    MRT_ToggleFullScreenButton,
    MRT_TableInstance,
} from "material-react-table";

interface ToolbarFiltersProps {
    table: MRT_TableInstance<any>;
    handleFetchData: () => Promise<void>;
}

export const ToolbarFilters = ({ table, handleFetchData }: ToolbarFiltersProps) => (
    <Box sx={{ display: "flex", gap: "1rem", alignItems: "center" }}>
        <Tooltip arrow title="Refresh Data">
            <IconButton onClick={handleFetchData}>
                <RefreshIcon />
            </IconButton>
        </Tooltip>
        <MRT_GlobalFilterTextField table={table} />
        <MRT_ToggleFiltersButton table={table} />
        <MRT_ShowHideColumnsButton table={table} />
        <MRT_ToggleDensePaddingButton table={table} />
        <MRT_ToggleFullScreenButton table={table} />
    </Box>
);


================================================
File: src/components/admin/tableAdmin/utils/tableColumns.ts
================================================
import { MRT_ColumnDef } from "material-react-table";

export const getColumns = (page: string): MRT_ColumnDef<any>[] => {
    switch (page) {
        case "crews":
            return [
                {
                    accessorKey: "fullname",
                    header: "Full Name",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "role",
                    header: "Role",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "debut",
                    header: "Debut",
                },
            ];
        case "actors":
            return [
                {
                    accessorKey: "fullname",
                    header: "Full Name",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "debut",
                    header: "Debut",
                },
            ];
        case "seasons":
            return [
                {
                    accessorKey: "title",
                    header: "Title",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "trailerSrc",
                    header: "Trailer URL",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "dateAired",
                    header: "Date Aired",
                },
                {
                    accessorKey: "ratingImdb",
                    header: "IMDB Rating",
                },
                {
                    accessorKey: "serieId",
                    header: "Serie ID",
                },
            ];
        case "episodes":
            return [
                {
                    accessorKey: "title",
                    header: "Title",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "trailerSrc",
                    header: "Trailer URL",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "duration",
                    header: "Duration (minutes)",
                },
                {
                    accessorKey: "dateAired",
                    header: "Date Aired",
                },
                {
                    accessorKey: "ratingImdb",
                    header: "IMDB Rating",
                },
                {
                    accessorKey: "seasonId",
                    header: "Season ID",
                },
            ];
        case "series":
            return [
                {
                    accessorKey: "title",
                    header: "Title",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "trailerSrc",
                    header: "Trailer URL",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "dateAired",
                    header: "Date Aired",
                },
                {
                    accessorKey: "ratingImdb",
                    header: "IMDB Rating",
                },
            ];
        case "movies":
            return [
                {
                    accessorKey: "title",
                    header: "Title",
                },
                {
                    accessorKey: "photoSrc",
                    header: "Photo URL",
                },
                {
                    accessorKey: "trailerSrc",
                    header: "Trailer URL",
                },
                {
                    accessorKey: "description",
                    header: "Description",
                },
                {
                    accessorKey: "dateAired",
                    header: "Date Aired",
                },
                {
                    accessorKey: "ratingImdb",
                    header: "IMDB Rating",
                },
            ];
        case "genres":
            return [
                {
                    accessorKey: "name",
                    header: "Name",
                },
            ];
        case "users":
            return [
                {
                    accessorKey: "userName",
                    header: "User Name",
                },
                {
                    accessorKey: "email",
                    header: "Email",
                },
                {
                    accessorKey: "password",
                    header: "Password",
                },
            ];
        default:
            return [];
    }
};


================================================
File: src/components/admin/tableAdmin/utils/tableDelete.ts
================================================
import { deleteActorById } from "@/actions/actor.actions";
import { deleteCrewMemberById } from "@/actions/crew.actions";
import { deleteEpisodeById } from "@/actions/episode.actions";
import { deleteGenreById } from "@/actions/genre.actions";
import { deleteMovieById } from "@/actions/movie.actions";
import { deleteSeasonById } from "@/actions/season.actions";
import { deleteSerieById } from "@/actions/serie.actions";
import { deleteUserById } from "@/actions/user/user.actions";
import { toast } from "react-toastify";

interface IDeleteHandler {
    page: string;
    id: number;
}

interface IMassiveDeleteHandler {
    page: string;
    selectedIds: string[];
}

export const handleDeleteById = async ({ page, id }: IDeleteHandler) => {
    let response: any;

    try {
        switch (page) {
            case "series":
                response = await deleteSerieById(Number(id));
                break;
            case "movies":
                response = await deleteMovieById(Number(id));
                break;
            case "genres":
                response = await deleteGenreById(Number(id));
                break;
            case "users":
                response = await deleteUserById(Number(id));
                break;
            case "actors":
                response = await deleteActorById(Number(id));
                break;
            case "episodes":
                response = await deleteEpisodeById(Number(id));
                break;
            case "seasons":
                response = await deleteSeasonById(Number(id));
                break;
            case "crews":
                response = await deleteCrewMemberById(Number(id));
                break;
            default:
                console.error(`Unsupported page type: ${page}`);
                return null;
        }

        if (response) {
            toast.success(`Item with id ${id} deleted successfully`);
            return response;
        } else {
            toast.error(`Failed to delete item with id ${id}`);
            return null;
        }
    } catch (error) {
        console.error(`Error deleting item with id ${id}:`, error);
        toast.error(`Error deleting item with id ${id}`);
        return null;
    }
};

export const handleMassiveDelete = async ({ page, selectedIds }: IMassiveDeleteHandler) => {
    const results = [];

    for (const id of selectedIds) {
        const result = await handleDeleteById({ page, id: Number(id) });
        results.push(result);
    }

    return results;
};


================================================
File: src/components/admin/topBar/TopBar.tsx
================================================
"use client";

import { AppBar, Box, IconButton, Menu, MenuItem, Toolbar, Typography, useTheme } from "@mui/material";
import { useState } from "react";
import PersonOutlinedIcon from "@mui/icons-material/PersonOutlined";
import { useStore } from "@/store/store";
import MenuIcon from "@mui/icons-material/Menu";
import { useRouter } from "next/navigation";
import { signOut, useSession } from "next-auth/react";
import type {} from "@mui/material/themeCssVarsAugmentation";
import SwitchThemeButton from "@/components/root/themeToggleButton/ThemeToggleButton";
import Image from "next/image";
import MuiNextLink from "@/components/root/muiNextLink/MuiNextLink";

const TopBar = () => {
    const { data: session } = useSession();
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const { isOpenSidebarAdmin, setIsOpenSidebarAdmin } = useStore();
    const router = useRouter();
    const theme = useTheme();
    const open = Boolean(anchorEl);

    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        setAnchorEl(event.currentTarget);
    };

    const handleClose = () => {
        setAnchorEl(null);
    };

    const handleLogout = async () => {
        await signOut();
        handleClose();
        router.push("/login");
    };

    const handleRedirectToProfile = () => {
        if (session?.user?.role === "Admin") {
            router.push("/admin");
        } else {
            router.push("/users/1/admin");
        }

        handleClose();
    };

    const handleGoToHome = () => {
        router.push("/");
        handleClose();
    };

    return (
        <AppBar position="static" component={"header"}>
            <Toolbar
                sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    backgroundColor: theme.vars.palette.primary.dark,
                }}
                component={"nav"}
            >
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        gap: 2,
                    }}
                >
                    {!isOpenSidebarAdmin && (
                        <IconButton
                            onClick={() => {
                                setIsOpenSidebarAdmin(true);
                            }}
                        >
                            <MenuIcon fontSize="medium" />
                        </IconButton>
                    )}
                    <Box
                        sx={{
                            paddingLeft: 3,
                        }}
                    >
                        <IconButton
                            LinkComponent={MuiNextLink}
                            href={"/admin"}
                            sx={{
                                p: 0,
                                "&:hover": {
                                    backgroundColor: "transparent",
                                },
                            }}
                        >
                            <Image
                                src="/icons/movielandia24-logo.png"
                                alt="MovieLandia24 Admin"
                                height={80}
                                width={200}
                                priority
                                style={{
                                    objectFit: "contain",
                                }}
                            />
                        </IconButton>
                    </Box>
                </Box>
                <Box display={"flex"} flexDirection={"row"}>
                    <SwitchThemeButton />
                    <IconButton
                        id="buttonProfile"
                        aria-controls={open ? "menuProfile" : undefined}
                        aria-haspopup="true"
                        aria-expanded={open ? "true" : undefined}
                        onClick={handleClick}
                        sx={{ display: "flex", flexDirection: "row", gap: "10px" }}
                    >
                        <PersonOutlinedIcon color="action" fontSize="medium" />
                        <Typography
                            component={"span"}
                            style={{
                                fontSize: 16,
                            }}
                        >
                            {session?.user?.userName}
                        </Typography>
                    </IconButton>
                    <Menu
                        id="menuProfile"
                        anchorEl={anchorEl}
                        open={open}
                        onClose={handleClose}
                        MenuListProps={{
                            "aria-labelledby": "buttonProfile",
                        }}
                    >
                        <MenuItem onClick={handleRedirectToProfile} style={{ color: theme.vars.palette.primary.main }}>
                            {session?.user?.role === "Admin" ? "Go to Dashboard" : "My Profile"}
                        </MenuItem>
                        {session?.user?.role === "Admin" && (
                            <MenuItem onClick={handleGoToHome} sx={{ color: theme.vars.palette.primary.main }}>
                                <Typography variant="inherit">Go To Home</Typography>
                            </MenuItem>
                        )}
                        <MenuItem onClick={handleLogout} style={{ color: theme.vars.palette.primary.main }}>
                            Log out
                        </MenuItem>
                    </Menu>
                </Box>
            </Toolbar>
        </AppBar>
    );
};

export default TopBar;


================================================
File: src/components/root/authButtons/AuthButtons.tsx
================================================
"use client";

import React from "react";
import { Button, Typography, Menu, MenuItem, useTheme, Box } from "@mui/material";
import LockOpenIcon from "@mui/icons-material/LockOpen";
import AppRegistrationIcon from "@mui/icons-material/AppRegistration";
import PersonOutlinedIcon from "@mui/icons-material/PersonOutlined";
import { Session } from "next-auth";
import { useStore } from "@/store/store";
import MuiNextLink from "../muiNextLink/MuiNextLink";
import { useRouter } from "next/navigation";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IAuthButtonsProps {
    session: Session | null;
    anchorElProfile: HTMLElement | null;
    userName: string;
    openMenuProfile: (event: any) => void;
    closeMenuProfile: () => void;
    handleSignOut: () => Promise<void>;
}

const AuthButtons = ({
    session,
    anchorElProfile,
    openMenuProfile,
    closeMenuProfile,
    handleSignOut,
    userName,
}: IAuthButtonsProps) => {
    const { isDrawerOpen, setIsDrawerOpen } = useStore();
    const theme = useTheme();
    const router = useRouter();

    const handleProfileClick = () => {
        closeMenuProfile();

        if (session?.user?.role === "Admin") {
            router.push("/admin");
        } else {
            router.push(`/users/${session?.user?.id}/${userName}`);
        }
    };

    return (
        <>
            {session && session.user ? (
                <>
                    <Box display={"flex"} flexDirection={"row"} onClick={openMenuProfile}>
                        <PersonOutlinedIcon color="action" fontSize="medium" />
                        <Typography
                            variant="body1"
                            sx={{
                                cursor: "pointer",
                                paddingLeft: 1,
                                color: theme.vars.palette.primary.main,
                            }}
                        >
                            {userName}
                        </Typography>
                    </Box>
                    <Menu
                        anchorEl={anchorElProfile}
                        open={Boolean(anchorElProfile)}
                        onClose={closeMenuProfile}
                        anchorOrigin={{
                            vertical: "bottom",
                            horizontal: "left",
                        }}
                        transformOrigin={{
                            vertical: "top",
                            horizontal: "left",
                        }}
                    >
                        <MenuItem onClick={handleProfileClick} sx={{ color: theme.vars.palette.primary.main }}>
                            <Typography variant="inherit">
                                {session?.user?.role === "Admin" ? "Go to Dashboard" : "My Profile"}
                            </Typography>
                        </MenuItem>
                        <MenuItem onClick={() => handleSignOut()} sx={{ color: theme.vars.palette.primary.main }}>
                            <Typography variant="inherit">Sign Out</Typography>
                        </MenuItem>
                    </Menu>
                </>
            ) : (
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        flexShrink: 0,
                        gap: 1,
                    }}
                >
                    <Button
                        LinkComponent={MuiNextLink}
                        href="/login"
                        variant="text"
                        sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.75,
                            px: 2,
                            color: theme.vars.palette.primary.main,
                            textTransform: "none",
                            flexShrink: 0,
                            "&:hover": {
                                backgroundColor: theme.vars.palette.green.main,
                                color: theme.vars.palette.greyAccent.main,
                            },
                        }}
                        onClick={() => {
                            if (isDrawerOpen) {
                                setIsDrawerOpen(false);
                            }
                        }}
                    >
                        <LockOpenIcon sx={{ fontSize: "1.2rem" }} />
                        <Typography
                            sx={{
                                fontSize: "1rem",
                                fontWeight: 500,
                                whiteSpace: "nowrap",
                            }}
                        >
                            Sign In
                        </Typography>
                    </Button>
                    <Button
                        LinkComponent={MuiNextLink}
                        href="/register"
                        variant="text"
                        sx={{
                            display: "flex",
                            alignItems: "center",
                            gap: 0.75,
                            px: 2,
                            color: theme.vars.palette.primary.main,
                            textTransform: "none",
                            flexShrink: 0,
                            "&:hover": {
                                backgroundColor: theme.vars.palette.green.main,
                                color: theme.vars.palette.greyAccent.main,
                            },
                        }}
                        onClick={() => {
                            if (isDrawerOpen) {
                                setIsDrawerOpen(false);
                            }
                        }}
                    >
                        <AppRegistrationIcon sx={{ fontSize: "1.2rem" }} />
                        <Typography
                            sx={{
                                fontSize: "1rem",
                                fontWeight: 500,
                                whiteSpace: "nowrap",
                            }}
                        >
                            Sign Up
                        </Typography>
                    </Button>
                </Box>
            )}
        </>
    );
};

export default AuthButtons;


================================================
File: src/components/root/cardItem/CardItem.tsx
================================================
"use client";

// #region "Imports"
import React, { useState, useTransition } from "react";
import { Box, Card, Typography, Button, useTheme, CircularProgress } from "@mui/material";
import { motion } from "framer-motion";
import { useParams } from "next/navigation";
import Image from "next/image";
import StarRateIcon from "@mui/icons-material/StarRate";
import BookmarkIcon from "@mui/icons-material/Bookmark";
import BookmarkBorderIcon from "@mui/icons-material/BookmarkBorder";
import Link from "next/link";
import { useSession } from "next-auth/react";
import { onBookmarkEpisode, onRemoveBookmarkEpisode } from "@/utils/features/episodeFeaturesUtils";
import { onBookmarkSeason, onRemoveBookmarkSeason } from "@/utils/features/seasonFeaturesUtils";
import { onBookmarkMovie, onRemoveBookmarkMovie } from "@/utils/features/movieFeaturesUtils";
import { onBookmarkSerie, onRemoveBookmarkSerie } from "@/utils/features/serieFeaturesUtils";
import { onBookmarkActor, onRemoveBookmarkActor } from "@/utils/features/actorFeaturesUtils";
import { onBookmarkCrew, onRemoveBookmarkCrew } from "@/utils/features/crewFeaturesUtils";
// #endregion

// #region "Types and Interfaces"
export type CardItemType = "movie" | "serie" | "season" | "episode" | "actor" | "crew" | "user";

export type PathType = "movies" | "actors" | "crew" | null;

interface BaseCardData {
    id: number;
    photoSrcProd?: string;
    description?: string;
    dateAired?: string;
    isBookmarked?: boolean;
}

interface RatedCardData extends BaseCardData {
    ratingImdb?: number;
    averageRating?: number;
}

interface MovieCardData extends RatedCardData {
    title: string;
}

interface SerieCardData extends RatedCardData {
    title: string;
}

interface SeasonCardData extends RatedCardData {
    title: string;
}

interface EpisodeCardData extends RatedCardData {
    title: string;
}

interface ActorCardData extends RatedCardData {
    fullname: string;
    debut: string;
}

interface CrewCardData extends RatedCardData {
    fullname: string;
    debut: string;
}

interface UserCardData extends BaseCardData {
    userName: string;
}

type CardData =
    | MovieCardData
    | SerieCardData
    | SeasonCardData
    | EpisodeCardData
    | ActorCardData
    | CrewCardData
    | UserCardData;

interface ICardItemProps {
    data: CardData;
    type: CardItemType;
    path?: string;
    isAutocomplete?: boolean;
}
// #endregion

const CardItem: React.FC<ICardItemProps> = ({ data, type, path, isAutocomplete = false }): React.JSX.Element => {
    const { data: session } = useSession();

    const [isHovered, setIsHovered] = useState(false);
    const [isPending, startTransition] = useTransition();

    const params = useParams();
    const theme = useTheme();

    const isTouchDevice = typeof window !== "undefined" && "ontouchstart" in window;

    const bookmarkFunctions = {
        movie: onBookmarkMovie,
        serie: onBookmarkSerie,
        season: onBookmarkSeason,
        episode: onBookmarkEpisode,
        actor: onBookmarkActor,
        crew: onBookmarkCrew,
    } as const;

    const removeBookmarkFunctions = {
        movie: onRemoveBookmarkMovie,
        serie: onRemoveBookmarkSerie,
        season: onRemoveBookmarkSeason,
        episode: onRemoveBookmarkEpisode,
        actor: onRemoveBookmarkActor,
        crew: onRemoveBookmarkCrew,
    } as const;

    const handleBookmarkClick = async (e: React.MouseEvent<HTMLDivElement>) => {
        e.preventDefault();

        if (!session?.user || isPending) return;

        const bookmarkFunc = bookmarkFunctions[type as keyof typeof bookmarkFunctions];
        const removeBookmarkFunc = removeBookmarkFunctions[type as keyof typeof removeBookmarkFunctions];

        startTransition(async () => {
            try {
                if (data.isBookmarked) {
                    if (removeBookmarkFunc) {
                        await removeBookmarkFunc(session, data);
                    }
                } else {
                    if (bookmarkFunc) {
                        await bookmarkFunc(session, data);
                    }
                }
            } catch (error) {
                console.error("Error toggling bookmark:", error);
            }
        });
    };

    const getPath = (): string => {
        const formatTitle = (title: string) => encodeURIComponent(title.split(" ").join("-"));

        switch (type) {
            case "serie":
                return `/series/${data.id}/${formatTitle((data as SerieCardData).title)}`;
            case "movie":
                return `/movies/${data.id}/${formatTitle((data as MovieCardData).title)}`;
            case "actor":
                if (path === "movies") {
                    return `/movies/${data.id}/${formatTitle((data as MovieCardData).title)}`;
                } else if (path === "actors") {
                    return `/actors/${data.id}/${formatTitle((data as ActorCardData).fullname)}`;
                }

                return `/series/${data.id}/${formatTitle((data as SerieCardData).title)}`;
            case "crew":
                if (path === "movies") {
                    return `/movies/${data.id}/${formatTitle((data as MovieCardData).title)}`;
                } else if (path === "crew") {
                    return `/crew/${data.id}/${formatTitle((data as CrewCardData).fullname)}`;
                }

                return `/series/${data.id}/${formatTitle((data as SerieCardData).title)}`;
            case "season": {
                const serieId = typeof params.serieId === "string" ? params.serieId : "";
                const serieTitle = typeof params.serieTitle === "string" ? formatTitle(params.serieTitle) : "";
                return `/series/${serieId}/${serieTitle}/seasons/${data.id}/${formatTitle((data as SeasonCardData).title)}`;
            }
            case "episode": {
                const serieId = typeof params.serieId === "string" ? params.serieId : "";
                const serieTitle = typeof params.serieTitle === "string" ? formatTitle(params.serieTitle) : "";
                const seasonId = typeof params.seasonId === "string" ? params.seasonId : "";
                const seasonTitle = typeof params.seasonTitle === "string" ? formatTitle(params.seasonTitle) : "";
                return `/series/${serieId}/${serieTitle}/seasons/${seasonId}/${seasonTitle}/episodes/${data.id}/${formatTitle((data as EpisodeCardData).title)}`;
            }
            case "user":
                return `/users/${data.id}/${formatTitle((data as UserCardData).userName)}`;
            default:
                return "/";
        }
    };

    const handleCardClick = (e: React.MouseEvent) => {
        if (isTouchDevice && !isHovered) {
            e.preventDefault();
            setIsHovered(true);
        }
    };

    const handleMouseLeave = () => {
        if (isTouchDevice) {
            setIsHovered(false);
        }
    };

    const getDisplayTitle = () => {
        if (path === "actors" || path === "crew") {
            const personData = data as ActorCardData | CrewCardData;
            return `${personData.fullname} Debut Year: (${personData.debut})`;
        }

        if (type === "user") {
            return (data as UserCardData).userName;
        }

        const mediaData = data as MovieCardData | SerieCardData | SeasonCardData | EpisodeCardData;

        return `${mediaData.title} (${mediaData.dateAired?.split("/")[2]})`;
    };

    return (
        <motion.div
            whileHover={{ scale: 1.03 }}
            transition={{ duration: 0.2, ease: "easeInOut" }}
            onClick={handleCardClick}
            onMouseLeave={handleMouseLeave}
        >
            <Link href={getPath()} tabIndex={0} aria-label={getDisplayTitle()}>
                <Card
                    sx={{
                        display: "flex",
                        flexDirection: "column",
                        width: isAutocomplete ? { xs: "120px", sm: "140px" } : { xs: "140px", sm: "160px" },
                        height: "100%",
                        position: "relative",
                        borderRadius: 2,
                        overflow: "hidden",
                        boxShadow: theme.shadows[4],
                        transition: "box-shadow 0.3s ease-in-out",
                        "&:hover": {
                            boxShadow: theme.shadows[8],
                        },
                    }}
                >
                    <Box
                        sx={{
                            position: "relative",
                            height: isAutocomplete ? { xs: "180px", sm: "210px" } : { xs: "210px", sm: "240px" },
                            width: "100%",
                            overflow: "hidden",
                            "&:hover .hoverOverlay": {
                                opacity: 1,
                            },
                        }}
                    >
                        <Image
                            src={data.photoSrcProd || "/images/placeholder.jpg"}
                            alt={data.description || "No description available"}
                            fill
                            sizes="(max-width: 600px) 140px, 160px"
                            style={{ objectFit: "cover" }}
                            priority={false}
                        />
                        <Box
                            className="hoverOverlay"
                            sx={{
                                position: "absolute",
                                inset: 0,
                                bgcolor: "rgba(0, 0, 0, 0.7)",
                                opacity: isHovered ? 1 : 0,
                                transition: "opacity 0.3s ease-in-out",
                                display: "flex",
                                flexDirection: "column",
                                justifyContent: "space-between",
                                p: { xs: 1.5, sm: 2 },
                            }}
                        >
                            <Box>
                                <Typography
                                    color="white"
                                    sx={{
                                        fontSize: { xs: "0.75rem", sm: "0.85rem" },
                                        fontWeight: 500,
                                        lineHeight: 1.4,
                                        mb: 1,
                                    }}
                                >
                                    {getDisplayTitle()}
                                </Typography>

                                {type !== "user" && "ratingImdb" in data && (
                                    <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 1 }}>
                                        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                                            <Box sx={{ display: "flex", alignItems: "center", height: "1rem" }}>
                                                <Image src="/icons/imdb.svg" alt="IMDb" width={32} height={16} />
                                            </Box>
                                            <Typography
                                                variant="caption"
                                                sx={{
                                                    color: "white",
                                                }}
                                            >
                                                {data.ratingImdb?.toFixed(1) || "N/A"}
                                            </Typography>
                                        </Box>
                                        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                                            <StarRateIcon sx={{ color: "#FFD700", fontSize: "1rem" }} />
                                            <Typography
                                                variant="caption"
                                                sx={{
                                                    color: "white",
                                                }}
                                            >
                                                {data.averageRating && data.averageRating !== 0.0
                                                    ? data.averageRating.toFixed(1)
                                                    : "N/A"}
                                            </Typography>
                                        </Box>
                                    </Box>
                                )}
                                {data.description && (
                                    <Typography
                                        variant="caption"
                                        sx={{
                                            color: "white",
                                            display: "-webkit-box",
                                            WebkitLineClamp: 3,
                                            WebkitBoxOrient: "vertical",
                                            overflow: "hidden",
                                        }}
                                    >
                                        {data.description}
                                    </Typography>
                                )}
                            </Box>
                            {session?.user?.userName && type !== "user" && (
                                <Box
                                    onClick={handleBookmarkClick}
                                    sx={{
                                        mt: "auto",
                                        display: "flex",
                                        alignItems: "center",
                                        gap: 1,
                                    }}
                                >
                                    <Button
                                        variant="outlined"
                                        size="small"
                                        disabled={isPending}
                                        sx={{
                                            minWidth: "auto",
                                            p: 1,
                                            borderColor: "white",
                                            cursor: isPending ? "not-allowed" : "pointer",
                                            opacity: isPending ? 0.7 : 1,
                                            "&:hover": {
                                                borderColor: "white",
                                                bgcolor: "rgba(255, 255, 255, 0.1)",
                                            },
                                        }}
                                    >
                                        {isPending ? (
                                            <CircularProgress size={20} sx={{ color: "white" }} />
                                        ) : data.isBookmarked ? (
                                            <BookmarkIcon sx={{ color: theme.vars.palette.error.main }} />
                                        ) : (
                                            <BookmarkBorderIcon sx={{ color: "white" }} />
                                        )}
                                    </Button>
                                    <Typography
                                        variant="body2"
                                        sx={{
                                            color: "white",
                                            textTransform: "capitalize",
                                            fontSize: { xs: "0.75rem", sm: "0.85rem" },
                                        }}
                                    >
                                        {isPending ? "Processing..." : data.isBookmarked ? "Bookmarked" : "Bookmark"}
                                    </Typography>
                                </Box>
                            )}
                        </Box>
                    </Box>
                </Card>
            </Link>
        </motion.div>
    );
};

export default CardItem;


================================================
File: src/components/root/carousel/Carousel.tsx
================================================
"use client";

import React, { useState } from "react";
import Slider from "react-slick";
import { Box, Button, Typography, IconButton, useTheme } from "@mui/material";
import NavigateBeforeIcon from "@mui/icons-material/NavigateBefore";
import NavigateNextIcon from "@mui/icons-material/NavigateNext";
import Link from "next/link";
import Image from "next/image";
import { motion } from "framer-motion";
import "slick-carousel/slick/slick.css";
import "slick-carousel/slick/slick-theme.css";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface ICarouselProps {
    data: any[];
    type: string;
}

const CustomNextArrow = (props: any) => {
    const { onClick } = props;
    const theme = useTheme();

    return (
        <IconButton
            onClick={onClick}
            sx={{
                position: "absolute",
                top: "50%",
                right: { xs: "20px", sm: "40px" },
                transform: "translateY(-50%)",
                zIndex: 2,
                color: theme.vars.palette.greyAccent.main,
                backgroundColor: "rgba(0, 0, 0, 0.5)",
                width: { xs: 40, sm: 48 },
                height: { xs: 40, sm: 48 },
                "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.7)",
                },
            }}
        >
            <NavigateNextIcon sx={{ fontSize: { xs: 24, sm: 32 } }} />
        </IconButton>
    );
};

const CustomPrevArrow = (props: any) => {
    const { onClick } = props;
    const theme = useTheme();

    return (
        <IconButton
            onClick={onClick}
            sx={{
                position: "absolute",
                top: "50%",
                left: { xs: "20px", sm: "40px" },
                transform: "translateY(-50%)",
                zIndex: 2,
                color: theme.vars.palette.greyAccent.main,
                backgroundColor: "rgba(0, 0, 0, 0.5)",
                width: { xs: 40, sm: 48 },
                height: { xs: 40, sm: 48 },
                "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.7)",
                },
            }}
        >
            <NavigateBeforeIcon sx={{ fontSize: { xs: 24, sm: 32 } }} />
        </IconButton>
    );
};

const Carousel = ({ data, type }: ICarouselProps) => {
    const theme = useTheme();
    const [currentSlide, setCurrentSlide] = useState(0);

    const settings = {
        dots: true,
        infinite: true,
        speed: 800,
        slidesToShow: 1,
        slidesToScroll: 1,
        autoplay: true,
        autoplaySpeed: 3000,
        pauseOnHover: true,
        nextArrow: <CustomNextArrow />,
        prevArrow: <CustomPrevArrow />,
        beforeChange: (_: any, next: any) => setCurrentSlide(next),
        fade: true,
        cssEase: "cubic-bezier(0.87, 0, 0.13, 1)",
        dotsClass: "slick-dots custom-dots",
        appendDots: (dots: any) => (
            <Box
                component={motion.div}
                sx={{
                    position: "absolute",
                    bottom: "20px",
                    width: "100%",
                    "& .slick-dots": {
                        position: "static",
                    },
                    "& .slick-dots li": {
                        margin: "0 6px",
                    },
                    "& .slick-dots li button": {
                        width: "12px",
                        height: "12px",
                        borderRadius: "50%",
                        backgroundColor: "rgba(255, 255, 255, 0.5)",
                        transition: "all 0.3s ease",
                        "&:before": {
                            display: "none",
                        },
                    },
                    "& .slick-dots li.slick-active button": {
                        backgroundColor: theme.vars.palette.green.main,
                        transform: "scale(1.2)",
                    },
                }}
            >
                <ul>{dots}</ul>
            </Box>
        ),
    };

    const getTitleOrName = (type: string, element: any) => {
        return type === "actors" || type === "crew" ? element.fullname : element.title;
    };

    const generateSlug = (text: string) => {
        return encodeURIComponent(text.split(" ").join("-"));
    };

    return (
        <Box
            sx={{
                position: "relative",
                height: {
                    xs: "140vh",
                    sm: "140vh",
                    md: "90vh",
                },
                overflow: "hidden",
                mt: 6,
            }}
        >
            <Slider {...settings}>
                {data.map((element, index) => (
                    <Box
                        key={index}
                        sx={{
                            position: "relative",
                            height: {
                                xs: "130vh",
                                sm: "130vh",
                                md: "90vh",
                            },
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            p: 2,
                        }}
                    >
                        <Box
                            sx={{
                                display: "flex",
                                flexDirection: "column",
                                alignItems: "center",
                                justifyContent: "center",
                                width: "auto",
                                maxWidth: "100%",
                            }}
                        >
                            <Image
                                src={element.photoSrcProd}
                                alt={`Slide ${index}`}
                                height={320}
                                width={220}
                                priority
                                style={{
                                    objectFit: "contain",
                                    objectPosition: "center",
                                    borderRadius: "12px",
                                    boxShadow: "0 8px 24px rgba(0,0,0,0.3)",
                                }}
                            />
                            <Box
                                sx={{
                                    position: "absolute",
                                    bottom: 0,
                                    left: 0,
                                    width: "100%",
                                    backgroundImage: "linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0))",
                                    padding: "48px",
                                    display: "flex",
                                    flexDirection: "column",
                                    justifyContent: "flex-end",
                                }}
                            >
                                <motion.div
                                    initial={false}
                                    animate={{ opacity: currentSlide === index ? 1 : 0 }}
                                    transition={{ duration: 0.4 }}
                                >
                                    <Typography
                                        variant="h1"
                                        gutterBottom
                                        sx={{
                                            fontSize: { xs: "2rem", sm: "2.5rem", md: "3rem" },
                                            fontWeight: 700,
                                            textShadow: "2px 2px 4px rgba(0,0,0,0.3)",
                                        }}
                                    >
                                        {getTitleOrName(type, element)}
                                    </Typography>
                                    <Typography
                                        variant="body1"
                                        sx={{
                                            mb: 3,
                                            maxWidth: "800px",
                                            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
                                            lineHeight: 1.6,
                                            textShadow: "1px 1px 2px rgba(0,0,0,0.3)",
                                        }}
                                    >
                                        {element.description}
                                    </Typography>
                                    <Link
                                        href={`/${type}/${element.id}/${generateSlug(getTitleOrName(type, element))}`}
                                        passHref
                                    >
                                        <Button
                                            variant="contained"
                                            sx={{
                                                bgcolor: theme.vars.palette.red.main,
                                                "&:hover": {
                                                    bgcolor: theme.vars.palette.green.main,
                                                    color: theme.vars.palette.primary.main,
                                                },
                                                textTransform: "capitalize",
                                                color: theme.vars.palette.greyAccent.main,
                                                fontSize: { xs: 14, sm: 16 },
                                                fontWeight: 700,
                                                px: { xs: 3, sm: 4 },
                                                py: 1.5,
                                                borderRadius: "8px",
                                                boxShadow: "0 4px 12px rgba(0,0,0,0.2)",
                                            }}
                                        >
                                            See Details
                                        </Button>
                                    </Link>
                                </motion.div>
                            </Box>
                        </Box>
                    </Box>
                ))}
            </Slider>
        </Box>
    );
};

export default Carousel;


================================================
File: src/components/root/detailsPageCard/DetailsPageCard.tsx
================================================
"use client";

import React, { useTransition } from "react";
import { Box, Typography, Chip, Button, useTheme, CircularProgress } from "@mui/material";
import { AccessTime, CalendarToday, Star, YouTube } from "@mui/icons-material";
import Image from "next/image";
import Link from "next/link";
import { useSession } from "next-auth/react";
import StarRateIcon from "@mui/icons-material/StarRate";
import { formatDate } from "@/utils/helpers/utils";
import BookmarkIcon from "@mui/icons-material/Bookmark";
import BookmarkBorderIcon from "@mui/icons-material/BookmarkBorder";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import type {} from "@mui/material/themeCssVarsAugmentation";
import PersonRoleCard from "./PersonRoleCard";
import PaginationPersonControl from "./PaginationPersonControl";

interface IDetailsPageCardProps {
    data: any;
    type: string;
    isBookmarked: boolean;
    cast?: any[];
    crew?: any[];
    currentCastPage?: number;
    currentCrewPage?: number;
    castPageCount?: number;
    crewPageCount?: number;
    onBookmark: () => Promise<void>;
    onRemoveBookmark: () => Promise<void>;
    onGoBack?: () => void;
}

export function DetailsPageCard({
    data,
    type,
    isBookmarked,
    onBookmark,
    onRemoveBookmark,
    onGoBack,
    cast,
    crew,
    currentCastPage,
    currentCrewPage,
    castPageCount,
    crewPageCount,
}: IDetailsPageCardProps) {
    const { data: session } = useSession();

    const theme = useTheme();
    const [isPending, startTransition] = useTransition();

    const handleBookmarkAction = () => {
        if (!session?.user || !data) return;

        startTransition(async () => {
            if (isBookmarked) {
                await onRemoveBookmark();
            } else {
                await onBookmark();
            }
        });
    };

    return (
        <Box
            sx={{
                display: "flex",
                flexDirection: "column",
                bgcolor: theme.vars.palette.secondary.light,
                color: theme.vars.palette.primary.main,
                width: "100%",
                maxWidth: "1200px",
                margin: "auto",
                p: { xs: 2, sm: 3, md: 4 },
                borderRadius: 6,
                mt: 10,
            }}
        >
            {(type === "season" || type === "episode") && (
                <Button
                    variant="outlined"
                    onClick={onGoBack}
                    sx={{ mb: 2, display: "flex", alignItems: "center", width: "fit-content" }}
                >
                    <ArrowBackIcon sx={{ mr: 1 }} />
                    Go Back
                </Button>
            )}
            <Box
                sx={{
                    display: "flex",
                    flexDirection: { xs: "column", md: "row" },
                    gap: 3,
                    alignItems: { xs: "center", md: "flex-start" },
                }}
            >
                <Box
                    sx={{
                        flexShrink: 0,
                        width: { xs: "100%", md: "214px" },
                        maxWidth: "214px",
                        height: { xs: "300px", md: "317px" },
                        position: "relative",
                    }}
                >
                    <Image
                        src={data.photoSrcProd}
                        alt={type !== "actor" && type !== "crew" ? data.title : data.fullname}
                        height={317}
                        width={214}
                        priority
                        style={{ objectFit: "cover", borderRadius: "8px" }}
                    />
                </Box>
                <Box
                    sx={{
                        flex: 1,
                        display: "flex",
                        flexDirection: "column",
                        width: "100%",
                        pt: { xs: 0, md: 0 },
                    }}
                >
                    <Typography
                        component="h1"
                        gutterBottom
                        fontWeight="bold"
                        sx={{
                            fontSize: "3rem",
                            letterSpacing: "0.3rem",
                        }}
                        color={theme.vars.palette.primary.main}
                    >
                        {type !== "actor" && type !== "crew" ? data.title : data.fullname}
                    </Typography>
                    <Box sx={{ mb: 2, display: "flex", flexDirection: "row", alignItems: "center" }}>
                        <Typography
                            component="h2"
                            sx={{
                                fontWeight: 600,
                                fontSize: "1.1rem",
                                color: theme.vars.palette.primary.main,
                            }}
                        >
                            Genres:
                        </Typography>
                        <Box
                            sx={{
                                display: "flex",
                                flexWrap: "wrap",
                                gap: 1,
                                p: 1,
                                borderRadius: 2,
                            }}
                        >
                            {data.genres?.map((genre: any, index: number) => (
                                <Link key={index} href={`/genres/${genre.genre.id}/${genre.genre.name}`} passHref>
                                    <Chip
                                        label={genre.genre.name}
                                        clickable
                                        sx={{
                                            bgcolor: theme.vars.palette.secondary.main,
                                            color: theme.vars.palette.red.main,
                                            textDecoration: "none",
                                            fontSize: "0.9rem",
                                            fontWeight: "600",
                                            padding: "12px 6px",
                                        }}
                                    />
                                </Link>
                            ))}
                        </Box>
                    </Box>
                    <Box
                        sx={{
                            display: "flex",
                            flexWrap: "wrap",
                            gap: 4,
                            mb: 3,
                            borderRadius: 2,
                        }}
                    >
                        {type !== "season" && type !== "serie" && type !== "actor" && type !== "crew" && (
                            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                                <AccessTime fontSize="small" color="primary" />
                                <Typography variant="body1" sx={{ fontWeight: 700 }}>
                                    Duration:
                                </Typography>
                                <Typography variant="body1">{data.duration} mins</Typography>
                            </Box>
                        )}
                        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                            <CalendarToday fontSize="small" color="primary" />
                            <Typography variant="body1" sx={{ fontWeight: 700 }}>
                                {type !== "actor" && type !== "crew" ? "Aired on:" : "Debut year:"}
                            </Typography>
                            <Typography variant="body2">
                                {type !== "actor" && type !== "crew" ? formatDate(data.dateAired) : data.debut}
                            </Typography>
                        </Box>
                        {type !== "actor" && type !== "crew" && (
                            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                                <Star fontSize="small" color="primary" />
                                <Typography variant="body1" sx={{ fontWeight: 700 }}>
                                    IMDB Rating:
                                </Typography>
                                <Typography variant="body2">{data.ratingImdb}</Typography>
                            </Box>
                        )}
                        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                            <StarRateIcon color="primary" />
                            <Typography variant="body1" sx={{ fontWeight: 700 }}>
                                Average Rating:
                            </Typography>
                            <Typography variant="body2">
                                {data.averageRating === 0 ? "N/A" : data.averageRating.toFixed(2)}
                            </Typography>
                        </Box>
                    </Box>
                    <Typography variant="body1" color={theme.vars.palette.primary.light}>
                        {data.description}
                    </Typography>
                    {(type === "movie" || type === "serie") && (cast || crew) && (
                        <Box
                            sx={{
                                mt: 3,
                                mb: 3,
                                display: "grid",
                                gridTemplateColumns: { xs: "1fr", md: "1fr 1fr" },
                                gap: 3,
                            }}
                        >
                            {cast && cast.length > 0 && (
                                <Box>
                                    <Typography
                                        variant="h6"
                                        sx={{
                                            mb: 2,
                                            fontWeight: 600,
                                            color: theme.vars.palette.primary.main,
                                        }}
                                    >
                                        Featured Cast
                                    </Typography>
                                    <Box
                                        sx={{
                                            display: "flex",
                                            flexDirection: "column",
                                            gap: 2,
                                        }}
                                    >
                                        <Box
                                            sx={{
                                                display: "flex",
                                                flexWrap: "wrap",
                                                gap: 2,
                                                justifyContent: { xs: "center", sm: "flex-start" },
                                            }}
                                        >
                                            {cast.map((person, index) => (
                                                <PersonRoleCard key={index} data={person.actor} type="actor" />
                                            ))}
                                        </Box>
                                        <PaginationPersonControl
                                            currentPage={currentCastPage!}
                                            pageCount={castPageCount!}
                                            urlParamName="castPage"
                                        />
                                    </Box>
                                </Box>
                            )}
                            {crew && crew.length > 0 && (
                                <Box>
                                    <Typography
                                        variant="h6"
                                        sx={{
                                            mb: 2,
                                            fontWeight: 600,
                                            color: theme.vars.palette.primary.main,
                                        }}
                                    >
                                        Featured Crew
                                    </Typography>
                                    <Box
                                        sx={{
                                            display: "flex",
                                            flexDirection: "column",
                                            gap: 2,
                                        }}
                                    >
                                        <Box
                                            sx={{
                                                display: "flex",
                                                flexWrap: "wrap",
                                                gap: 2,
                                                justifyContent: { xs: "center", sm: "flex-start" },
                                            }}
                                        >
                                            {crew.map((person, index) => (
                                                <PersonRoleCard key={index} data={person.crew} type="crew" />
                                            ))}
                                        </Box>
                                        <PaginationPersonControl
                                            currentPage={currentCrewPage!}
                                            pageCount={crewPageCount!}
                                            urlParamName="crewPage"
                                        />
                                    </Box>
                                </Box>
                            )}
                        </Box>
                    )}
                    <Box sx={{ mt: 2, display: "flex", gap: 2, flexWrap: "wrap" }}>
                        {type !== "actor" && (
                            <Button
                                variant="contained"
                                startIcon={<YouTube />}
                                href={data.trailerSrc}
                                target="_blank"
                                rel="noopener noreferrer"
                                sx={{
                                    bgcolor: theme.vars.palette.red.main,
                                    color: theme.vars.palette.primary.main,
                                    textTransform: "capitalize",
                                    fontSize: 16,
                                }}
                            >
                                Watch trailer
                            </Button>
                        )}
                        {session?.user?.userName && (
                            <Button
                                variant="contained"
                                onClick={handleBookmarkAction}
                                disabled={isPending}
                                startIcon={
                                    isPending ? (
                                        <CircularProgress size={20} color="inherit" />
                                    ) : isBookmarked ? (
                                        <BookmarkIcon color="error" />
                                    ) : (
                                        <BookmarkBorderIcon color="success" />
                                    )
                                }
                                sx={{
                                    color: theme.vars.palette.primary.main,
                                    bgcolor: isBookmarked ? theme.vars.palette.red.main : theme.vars.palette.green.main,
                                    "&:hover": {
                                        bgcolor: theme.vars.palette.secondary.light,
                                    },
                                    "&:disabled": {
                                        bgcolor: isBookmarked
                                            ? theme.vars.palette.red.main
                                            : theme.vars.palette.green.main,
                                        opacity: 0.7,
                                    },
                                    textTransform: "capitalize",
                                    fontSize: 16,
                                    minWidth: 130,
                                }}
                            >
                                {isBookmarked ? "Bookmarked" : "Bookmark"}
                            </Button>
                        )}
                    </Box>
                </Box>
            </Box>
        </Box>
    );
}

export default DetailsPageCard;


================================================
File: src/components/root/detailsPageCard/PaginationPersonControl.tsx
================================================
"use client";

import { Box, Pagination, PaginationItem } from "@mui/material";
import { useQueryState } from "nuqs";

interface PaginationDetailsPersonControlProps {
    currentPage: number;
    pageCount: number;
    urlParamName: string;
}

const PaginationDetailsPersonControl = ({
    currentPage,
    pageCount,
    urlParamName,
}: PaginationDetailsPersonControlProps) => {
    const [page, setPage] = useQueryState(urlParamName, {
        defaultValue: "",
        parse: (value) => value || "",
        history: "push",
        shallow: false,
    });

    const handleChange = (_event: React.ChangeEvent<unknown>, value: number) => {
        if (value === currentPage) return;
        setPage(value.toString());
    };

    return (
        <Box sx={{ display: "flex", justifyContent: "flex-start", mt: 2 }}>
            <Pagination
                page={currentPage}
                onChange={handleChange}
                count={pageCount}
                variant="outlined"
                shape="rounded"
                showLastButton={true}
                showFirstButton={true}
                size="small"
                renderItem={(item) => (
                    <PaginationItem {...item} disabled={item.page === currentPage || item.disabled} />
                )}
            />
        </Box>
    );
};

export default PaginationDetailsPersonControl;


================================================
File: src/components/root/detailsPageCard/PersonRoleCard.tsx
================================================
"use client";

import { Box, Typography, useTheme } from "@mui/material";
import Image from "next/image";
import Link from "next/link";
import { motion } from "framer-motion";

interface PersonRoleCardProps {
    data: any;
    type: "actor" | "crew";
}

const PersonRoleCard = ({ data, type }: PersonRoleCardProps) => {
    const theme = useTheme();

    return (
        <motion.div whileHover={{ scale: 1.05 }} transition={{ duration: 0.2 }}>
            <Link
                href={`/${type === "actor" ? "actors" : "crew"}/${data.id}/${encodeURIComponent(
                    data.fullname.split(" ").join("-"),
                )}`}
                style={{ textDecoration: "none" }}
            >
                <Box
                    sx={{
                        position: "relative",
                        width: { xs: "60px", sm: "70px" },
                        height: { xs: "60px", sm: "70px" },
                        borderRadius: "50%",
                        overflow: "hidden",
                        cursor: "pointer",
                        boxShadow: theme.shadows[4],
                        "&:hover": {
                            boxShadow: theme.shadows[8],
                            "& .overlay": {
                                opacity: 1,
                            },
                        },
                    }}
                >
                    <Image
                        src={data.photoSrcProd || "/images/placeholder.jpg"}
                        alt={data.fullname}
                        fill
                        sizes="(max-width: 600px) 60px, 70px"
                        style={{
                            objectFit: "cover",
                        }}
                    />
                    <Box
                        className="overlay"
                        sx={{
                            position: "absolute",
                            inset: 0,
                            bgcolor: "rgba(0, 0, 0, 0.7)",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            padding: 1,
                            opacity: 0,
                            transition: "opacity 0.3s ease-in-out",
                        }}
                    >
                        <Typography
                            variant="caption"
                            sx={{
                                color: "white",
                                textAlign: "center",
                                fontSize: { xs: "0.6rem", sm: "0.7rem" },
                                fontWeight: 500,
                                display: "-webkit-box",
                                WebkitLineClamp: 2,
                                WebkitBoxOrient: "vertical",
                                overflow: "hidden",
                            }}
                        >
                            {data.fullname}
                            {data.debut && ` (${data.debut})`}
                        </Typography>
                    </Box>
                </Box>
            </Link>
        </motion.div>
    );
};

export default PersonRoleCard;


================================================
File: src/components/root/footer/Footer.tsx
================================================
"use client";

import React, { useState } from "react";
import { Box, Typography, IconButton, Stack, TextField, Button, useTheme, Container, Divider } from "@mui/material";
import MovieIcon from "@mui/icons-material/Movie";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import LockOpenIcon from "@mui/icons-material/LockOpen";
import AppRegistrationIcon from "@mui/icons-material/AppRegistration";
import SubtitlesIcon from "@mui/icons-material/Subtitles";
import FacebookIcon from "@mui/icons-material/Facebook";
import TwitterIcon from "@mui/icons-material/Twitter";
import InstagramIcon from "@mui/icons-material/Instagram";
import MuiNextLink from "../muiNextLink/MuiNextLink";
import RecentActorsIcon from "@mui/icons-material/RecentActors";
import InfoIcon from "@mui/icons-material/Info";
import ContactSupportIcon from "@mui/icons-material/ContactSupport";
import GroupsIcon from "@mui/icons-material/Groups";
import { motion } from "framer-motion";
import { subscribeNewsletter } from "@/actions/auth.actions";
import { showToast } from "@/utils/helpers/toast";
import type {} from "@mui/material/themeCssVarsAugmentation";

const FooterLink = ({ href, icon: Icon, text }: { href: string; icon: any; text: string }) => {
    const theme = useTheme();

    return (
        <Button
            component={MuiNextLink}
            href={href}
            prefetch={false}
            sx={{
                textDecoration: "none",
                textTransform: "capitalize",
                color: theme.vars.palette.primary.main,
                transition: "all 0.2s ease-in-out",
                minWidth: "160px",
                justifyContent: "flex-start",
                "&:hover": {
                    transform: "translateX(8px)",
                    color: theme.vars.palette.red.main,
                },
            }}
        >
            <Stack direction="row" alignItems="center" spacing={1.5} sx={{ width: "100%" }}>
                <Icon sx={{ fontSize: 20, minWidth: "24px" }} />
                <Typography variant="body1">{text}</Typography>
            </Stack>
        </Button>
    );
};

const SocialButton = ({ href, icon: Icon }: { href: string; icon: any }) => {
    const theme = useTheme();

    return (
        <IconButton
            component={motion.button}
            whileHover={{ scale: 1.1 }}
            href={href}
            target="_blank"
            rel="noopener"
            sx={{
                color: theme.vars.palette.primary.main,
                transition: "all 0.2s ease-in-out",
                padding: "8px",
                "&:hover": {
                    color: theme.vars.palette.red.main,
                    backgroundColor: "rgba(255, 255, 255, 0.1)",
                },
            }}
        >
            <Icon />
        </IconButton>
    );
};

const Footer = (): React.JSX.Element => {
    const theme = useTheme();

    const [email, setEmail] = useState("");

    const handleSubscribe = async () => {
        try {
            const message = await subscribeNewsletter({ email });
            const messageType = message.includes("successful") ? "success" : "error";
            showToast(messageType, message);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "An unexpected error occurred.";
            showToast("error", errorMessage);
        }
    };

    return (
        <Box
            sx={{
                backgroundColor: theme.vars.palette.primary.dark,
                color: theme.vars.palette.primary.main,
                py: 6,
                borderTop: `1px solid ${theme.vars.palette.divider}`,
            }}
            component="footer"
        >
            <Container maxWidth="lg">
                <Stack spacing={6}>
                    <Stack
                        direction={{ xs: "column", md: "row" }}
                        spacing={{ xs: 4, md: 4 }}
                        sx={{
                            width: "100%",
                            alignItems: { xs: "stretch", md: "flex-start" },
                        }}
                    >
                        <Stack
                            direction={{ xs: "column", sm: "row" }}
                            spacing={{ xs: 4, sm: 8 }}
                            sx={{
                                width: { xs: "100%", md: "auto" },
                                flexGrow: 0,
                            }}
                        >
                            <Box sx={{ width: { xs: "100%", sm: "auto" } }}>
                                <Typography
                                    variant="h6"
                                    sx={{
                                        mb: 2,
                                        fontWeight: 700,
                                        pl: "12px",
                                        color: theme.vars.palette.red.main,
                                        position: "relative",
                                        display: "inline-block",
                                        "&::after": {
                                            content: '""',
                                            position: "absolute",
                                            bottom: -4,
                                            left: 12,
                                            width: "80%",
                                            height: 2,
                                            bgcolor: "primary.main",
                                            borderRadius: 1,
                                        },
                                    }}
                                >
                                    Movies & TV
                                </Typography>
                                <Stack spacing={1}>
                                    <FooterLink href="/movies" icon={MovieIcon} text="Movies" />
                                    <FooterLink href="/series" icon={LocalMoviesIcon} text="Series" />
                                    <FooterLink href="/genres" icon={SubtitlesIcon} text="Genres" />
                                </Stack>
                            </Box>
                            <Box sx={{ width: { xs: "100%", sm: "auto" } }}>
                                <Typography
                                    variant="h6"
                                    sx={{
                                        mb: 2,
                                        fontWeight: 700,
                                        pl: "12px",
                                        color: theme.vars.palette.red.main,
                                        position: "relative",
                                        display: "inline-block",
                                        "&::after": {
                                            content: '""',
                                            position: "absolute",
                                            bottom: -4,
                                            left: 12,
                                            width: "80%",
                                            height: 2,
                                            bgcolor: "primary.main",
                                            borderRadius: 1,
                                        },
                                    }}
                                >
                                    People
                                </Typography>
                                <Stack spacing={1}>
                                    <FooterLink href="/actors" icon={RecentActorsIcon} text="Actors" />
                                    <FooterLink href="/crew" icon={GroupsIcon} text="Crew" />
                                </Stack>
                            </Box>
                            <Box sx={{ width: { xs: "100%", sm: "auto" } }}>
                                <Typography
                                    variant="h6"
                                    sx={{
                                        mb: 2,
                                        fontWeight: 700,
                                        pl: "12px",
                                        color: theme.vars.palette.red.main,
                                        position: "relative",
                                        display: "inline-block",
                                        "&::after": {
                                            content: '""',
                                            position: "absolute",
                                            bottom: -4,
                                            left: 12,
                                            width: "80%",
                                            height: 2,
                                            bgcolor: "primary.main",
                                            borderRadius: 1,
                                        },
                                    }}
                                >
                                    Company
                                </Typography>
                                <Stack spacing={1}>
                                    <FooterLink href="/about-us" icon={InfoIcon} text="About Us" />
                                    <FooterLink href="/contact-us" icon={ContactSupportIcon} text="Contact Us" />
                                    <FooterLink href="/login" icon={LockOpenIcon} text="Sign In" />
                                    <FooterLink href="/register" icon={AppRegistrationIcon} text="Sign Up" />
                                </Stack>
                            </Box>
                        </Stack>
                        <Stack
                            direction={{ xs: "column", sm: "row" }}
                            spacing={{ xs: 4, sm: 8 }}
                            sx={{
                                width: { xs: "100%", md: "auto" },
                                flexGrow: 0,
                                ml: { md: "auto" },
                            }}
                        >
                            <Box sx={{ width: { xs: "100%", sm: "auto" } }}>
                                <Typography
                                    variant="h6"
                                    sx={{
                                        mb: 2,
                                        fontWeight: 700,
                                        pl: "12px",
                                        color: theme.vars.palette.red.main,
                                        position: "relative",
                                        display: "inline-block",
                                        "&::after": {
                                            content: '""',
                                            position: "absolute",
                                            bottom: -4,
                                            left: 12,
                                            width: "80%",
                                            height: 2,
                                            bgcolor: "primary.main",
                                            borderRadius: 1,
                                        },
                                    }}
                                >
                                    Follow Us
                                </Typography>
                                <Stack
                                    direction="row"
                                    spacing={0.5}
                                    sx={{
                                        pl: "4px",
                                        "& .MuiIconButton-root": {
                                            ml: "4px",
                                        },
                                    }}
                                >
                                    <SocialButton href="https://facebook.com" icon={FacebookIcon} />
                                    <SocialButton href="https://twitter.com" icon={TwitterIcon} />
                                    <SocialButton href="https://instagram.com" icon={InstagramIcon} />
                                </Stack>
                            </Box>
                            <Box sx={{ width: { xs: "100%", sm: 300 } }}>
                                <Typography
                                    variant="h6"
                                    sx={{
                                        mb: 2,
                                        fontWeight: 700,
                                        color: theme.vars.palette.red.main,
                                        position: "relative",
                                        display: "inline-block",
                                        "&::after": {
                                            content: '""',
                                            position: "absolute",
                                            bottom: -4,
                                            left: 0,
                                            width: "80%",
                                            height: 2,
                                            bgcolor: "primary.main",
                                            borderRadius: 1,
                                        },
                                    }}
                                >
                                    Newsletter
                                </Typography>
                                <Stack spacing={2}>
                                    <TextField
                                        variant="outlined"
                                        size="small"
                                        onChange={(e) => setEmail(e.target.value)}
                                        placeholder="Enter your email"
                                        sx={{
                                            "& .MuiOutlinedInput-root": {
                                                backgroundColor: "rgba(255, 255, 255, 0.05)",
                                                "&:hover .MuiOutlinedInput-notchedOutline": {
                                                    borderColor: theme.vars.palette.red.main,
                                                },
                                                "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                                                    borderColor: theme.vars.palette.red.main,
                                                },
                                            },
                                            "& .MuiOutlinedInput-input": {
                                                color: theme.vars.palette.primary.main,
                                            },
                                        }}
                                    />
                                    <Button
                                        variant="contained"
                                        onClick={handleSubscribe}
                                        sx={{
                                            py: 1,
                                            color: theme.vars.palette.secondary.light,
                                            bgcolor: theme.vars.palette.red.main,
                                            "&:hover": {
                                                bgcolor: theme.vars.palette.red.dark,
                                            },
                                        }}
                                    >
                                        Subscribe
                                    </Button>
                                </Stack>
                            </Box>
                        </Stack>
                    </Stack>
                    <Divider sx={{ borderColor: "rgba(255, 255, 255, 0.1)" }} />
                    <Stack
                        direction={{ xs: "column", sm: "row" }}
                        spacing={2}
                        sx={{
                            justifyContent: "space-between",
                            alignItems: "center",
                        }}
                    >
                        <Typography variant="body2" sx={{ opacity: 0.8 }}>
                            2024 MovieLandia24. All rights reserved.
                        </Typography>
                        <Stack direction="row" spacing={3}>
                            <Typography
                                variant="body2"
                                component={MuiNextLink}
                                href="/privacy"
                                sx={{
                                    opacity: 0.8,
                                    textDecoration: "none",
                                    "&:hover": { color: theme.vars.palette.red.main },
                                }}
                            >
                                Privacy Policy
                            </Typography>
                            <Typography
                                variant="body2"
                                component={MuiNextLink}
                                href="/terms"
                                sx={{
                                    opacity: 0.8,
                                    textDecoration: "none",
                                    "&:hover": { color: theme.vars.palette.red.main },
                                }}
                            >
                                Terms of Service
                            </Typography>
                        </Stack>
                    </Stack>
                </Stack>
            </Container>
        </Box>
    );
};

export default Footer;


================================================
File: src/components/root/genreItem/GenreItem.tsx
================================================
"use client";

import { Card, Typography, useTheme } from "@mui/material";
import { Genre } from "@prisma/client";
import { motion } from "framer-motion";
import type {} from "@mui/material/themeCssVarsAugmentation";
import Link from "next/link";

interface IGenreItemProps {
    genre: Genre;
}

export default function GenreItem({ genre }: IGenreItemProps) {
    const theme = useTheme();

    return (
        <motion.div whileHover={{ scale: 1.03 }} transition={{ duration: 0.2, ease: "easeInOut" }}>
            <Link href={`/genres/${genre.id}/${genre.name}`} style={{ textDecoration: "none" }}>
                <Card
                    key={genre.id}
                    sx={{
                        display: "flex",
                        placeItems: "center",
                        placeContent: "center",
                        cursor: "pointer",
                        height: "240px",
                        width: "160px",
                        backgroundColor: `colors.secondary`,
                    }}
                    elevation={4}
                >
                    <Typography sx={{ textDecoration: "none", color: theme.vars.palette.primary.main }}>
                        {genre.name}
                    </Typography>
                </Card>
            </Link>
        </motion.div>
    );
}


================================================
File: src/components/root/header/Header.tsx
================================================
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getServerSession } from "next-auth/next";
import { HeaderContent } from "./HeaderContent";
import { getGenres } from "@/actions/genre.actions";
import { getUsernameByUserId } from "@/actions/user/user.actions";

const Header = async () => {
    const session = await getServerSession(authOptions);

    let userName: string = "";

    if (session && session.user && session.user.id) {
        userName = await getUsernameByUserId(Number(session.user.id));
    }

    const genres = await getGenres();

    return <HeaderContent session={session} genres={genres || []} userName={userName} />;
};

export default Header;


================================================
File: src/components/root/header/HeaderContent.tsx
================================================
"use client";

import { useStore } from "@/store/store";
import { AppBar, Box, IconButton, Toolbar, useTheme } from "@mui/material";
import AuthButtons from "../authButtons/AuthButtons";
import ThemeToggleButton from "../themeToggleButton/ThemeToggleButton";
import MenuIcon from "@mui/icons-material/Menu";
import { HeaderLinks } from "./HeaderLinks";
import { Genre } from "@prisma/client";
import { Session } from "next-auth";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { signOut } from "next-auth/react";
import HeaderMobile from "../headerMobile/HeaderMobile";
import { showToast } from "@/utils/helpers/toast";
import SearchField from "../searchField/SearchField";
import type {} from "@mui/material/themeCssVarsAugmentation";
import NotificationMenu from "../notificationMenu/NotificationMenu";
import MessageCounter from "./MessageCounter";

interface IHeaderContentProps {
    session: Session | null;
    genres: Genre[];
    userName: string;
}

export function HeaderContent({ session, genres, userName }: IHeaderContentProps) {
    const [anchorElProfile, setAnchorElProfile] = useState<null | HTMLElement>(null);
    const { isDrawerOpen, setIsDrawerOpen } = useStore();

    const router = useRouter();
    const theme = useTheme();

    const openMenuProfile = (event: any) => {
        setAnchorElProfile(event.currentTarget);
    };

    const closeMenuProfile = () => {
        setAnchorElProfile(null);
    };

    const handleSignOut = async () => {
        closeMenuProfile();
        await signOut({ redirect: false });

        if (isDrawerOpen) {
            setIsDrawerOpen(false);
        }

        router.push("/login");
        router.refresh();
        showToast("success", "You are succesfully logged out!");
    };

    return (
        <>
            <AppBar position="fixed" component={"header"}>
                <Toolbar
                    sx={{
                        display: "flex",
                        flexDirection: "row",
                        justifyContent: {
                            xs: "flex-start",
                            sm: "flex-start",
                            md: "space-between",
                            lg: "space-between",
                        },
                        flexWrap: "nowrap",
                        py: 1.5,
                        backgroundColor: theme.vars.palette.primary.dark,
                        minHeight: 72,
                    }}
                    component={"nav"}
                >
                    {/* Hamburger Button */}
                    <Box
                        sx={{
                            display: {
                                xs: "block",
                                sm: "block",
                                md: "none",
                                lg: "none",
                            },
                        }}
                    >
                        <IconButton
                            aria-label="open drawer"
                            edge="start"
                            onClick={() => {
                                setIsDrawerOpen(true);
                            }}
                            sx={{
                                color: theme.vars.palette.primary.main,
                                "&:hover": {
                                    color: theme.vars.palette.green.main,
                                },
                            }}
                        >
                            <MenuIcon />
                        </IconButton>
                    </Box>
                    {/* Desktop Navigation */}
                    <Box
                        sx={{
                            display: {
                                xs: "none",
                                sm: "none",
                                md: "flex",
                                lg: "flex",
                            },
                            flexDirection: "row",
                            alignItems: "center",
                            justifyContent: "space-between",
                            width: "100%",
                            px: 2,
                        }}
                    >
                        <HeaderLinks genres={genres} />
                        <Box
                            sx={{
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                                ml: "auto",
                                height: "100%",
                                flexShrink: 0,
                            }}
                        >
                            <SearchField />
                            {session?.user && <MessageCounter session={session} />}
                            {session?.user && <NotificationMenu session={session} />}
                            <ThemeToggleButton />
                            <AuthButtons
                                session={session}
                                userName={userName}
                                anchorElProfile={anchorElProfile}
                                closeMenuProfile={closeMenuProfile}
                                openMenuProfile={openMenuProfile}
                                handleSignOut={handleSignOut}
                            />
                        </Box>
                    </Box>
                </Toolbar>
            </AppBar>
            {/* Mobile Header Toggled sidebar */}
            <HeaderMobile
                genres={genres}
                anchorElProfile={anchorElProfile}
                openMenuProfile={openMenuProfile}
                closeMenuProfile={closeMenuProfile}
                handleSignOut={handleSignOut}
                session={session}
                userName={userName}
            />
        </>
    );
}


================================================
File: src/components/root/header/HeaderLinks.tsx
================================================
"use client";

import { Box, Button, List, ListItem, Popper, Paper, Typography, useTheme } from "@mui/material";
import Link from "next/link";
import { Genre } from "@prisma/client";
import MovieIcon from "@mui/icons-material/Movie";
import LocalMoviesIcon from "@mui/icons-material/LocalMovies";
import SubtitlesIcon from "@mui/icons-material/Subtitles";
import { useStore } from "@/store/store";
import MuiNextLink from "../muiNextLink/MuiNextLink";
import Image from "next/image";
import { usePathname } from "next/navigation";
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IHeaderLinksProps {
    genres: Genre[];
}

export function HeaderLinks({ genres }: IHeaderLinksProps) {
    const [open, setOpen] = useState(false);
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const { isDrawerOpen, setIsDrawerOpen } = useStore();

    const pathname = usePathname();
    const theme = useTheme();

    useEffect(() => {
        handleGenresLeave();
    }, [pathname]);

    const handleGenresHover = (event: React.MouseEvent<HTMLElement>) => {
        setAnchorEl(event.currentTarget);
        setOpen(true);
    };

    const handleGenresLeave = () => {
        setOpen(false);
        setAnchorEl(null);
    };

    const isActive = (path: string) => {
        if (path === "/") return pathname === "/";
        return pathname.startsWith(path);
    };

    const getButtonStyle = (path: string) => ({
        display: "flex",
        alignItems: "center",
        gap: 0.75,
        fontSize: "1rem",
        textTransform: "none",
        color: isActive(path) ? theme.vars.palette.green.main : theme.vars.palette.primary.main,
        borderBottom: isActive(path) ? `2px solid ${theme.vars.palette.green.main}` : "none",
        borderRadius: 0,
        fontWeight: 500,
        letterSpacing: "0.02em",
        height: 48,
        "&:hover": {
            backgroundColor: "transparent",
            color: theme.vars.palette.green.main,
        },
    });

    return (
        <>
            <Box
                sx={{
                    display: "flex",
                    alignItems: "center",
                }}
            >
                <Button
                    LinkComponent={MuiNextLink}
                    href={"/"}
                    type="button"
                    sx={{
                        padding: 0,
                        "&:hover": {
                            backgroundColor: "transparent",
                        },
                        "&:active": {
                            backgroundColor: "transparent",
                        },
                    }}
                    onClick={() => {
                        if (isDrawerOpen) {
                            setIsDrawerOpen(false);
                        }
                    }}
                >
                    <Image
                        src={"/icons/movielandia24-logo.png"}
                        alt="MovieLandia24"
                        height={70}
                        width={200}
                        priority={true}
                        style={{ pointerEvents: "none" }}
                    />
                </Button>
            </Box>
            <Box
                sx={{
                    display: "flex",
                    alignItems: "center",
                    flexShrink: 0,
                }}
            >
                <List
                    sx={{
                        display: "flex",
                        flexDirection: {
                            xs: "column",
                            sm: "column",
                            md: "row",
                        },
                    }}
                >
                    <ListItem>
                        <Button
                            LinkComponent={MuiNextLink}
                            href="/movies"
                            variant="text"
                            sx={getButtonStyle("/movies")}
                            onClick={() => {
                                if (isDrawerOpen) {
                                    setIsDrawerOpen(false);
                                }
                            }}
                        >
                            <MovieIcon fontSize={"large"} />
                            Movies
                        </Button>
                    </ListItem>
                    <ListItem>
                        <Button
                            LinkComponent={MuiNextLink}
                            href="/series"
                            variant="text"
                            sx={getButtonStyle("/series")}
                            onClick={() => {
                                if (isDrawerOpen) {
                                    setIsDrawerOpen(false);
                                }
                            }}
                        >
                            <LocalMoviesIcon fontSize={"large"} />
                            Series
                        </Button>
                    </ListItem>
                    <ListItem>
                        <Box onMouseEnter={handleGenresHover} onMouseLeave={handleGenresLeave}>
                            <Button
                                LinkComponent={MuiNextLink}
                                href="/genres"
                                variant="text"
                                sx={getButtonStyle("/genres")}
                                onClick={() => {
                                    if (isDrawerOpen) {
                                        setIsDrawerOpen(false);
                                    }

                                    handleGenresLeave();
                                }}
                            >
                                <SubtitlesIcon fontSize={"large"} />
                                Genres
                            </Button>
                            <Popper
                                open={open}
                                anchorEl={anchorEl}
                                placement={isDrawerOpen ? "right-start" : "bottom-start"}
                                sx={{
                                    zIndex: 1300,
                                    ...(isDrawerOpen && {
                                        position: "fixed",
                                        left: "240px",
                                    }),
                                }}
                            >
                                <AnimatePresence>
                                    {open && (
                                        <motion.div
                                            initial={{ opacity: 0, scale: 0.6, y: -40 }}
                                            animate={{
                                                opacity: 1,
                                                scale: 1,
                                                y: 0,
                                                transition: {
                                                    type: "spring",
                                                    stiffness: 200,
                                                    damping: 20,
                                                },
                                            }}
                                            exit={{
                                                opacity: 0,
                                                scale: 0.6,
                                                y: -20,
                                                transition: {
                                                    duration: 0.2,
                                                },
                                            }}
                                            style={{ transformOrigin: "top" }}
                                        >
                                            <Paper
                                                sx={{
                                                    mt: 1,
                                                    display: "grid",
                                                    gridTemplateColumns: isDrawerOpen
                                                        ? "repeat(2, 1fr)"
                                                        : "repeat(4, 1fr)",
                                                    gap: isDrawerOpen ? 0.5 : 1,
                                                    p: isDrawerOpen ? 1 : 2,
                                                }}
                                            >
                                                {genres.map((genre, index) => (
                                                    <motion.div
                                                        key={genre.id}
                                                        initial={{ opacity: 0, y: 20 }}
                                                        animate={{
                                                            opacity: 1,
                                                            y: 0,
                                                            transition: {
                                                                delay: index * 0.05,
                                                                duration: 0.3,
                                                            },
                                                        }}
                                                        whileHover={{
                                                            scale: 1.1,
                                                            rotate: [0, -2, 2, 0],
                                                            transition: {
                                                                rotate: {
                                                                    duration: 0.3,
                                                                    repeat: 0,
                                                                },
                                                            },
                                                        }}
                                                    >
                                                        <Link
                                                            href={`/genres/${genre.id}/${genre.name}`}
                                                            style={{
                                                                textDecoration: "none",
                                                                color: theme.vars.palette.primary.main,
                                                            }}
                                                            onClick={() => {
                                                                if (isDrawerOpen) {
                                                                    setIsDrawerOpen(false);
                                                                }

                                                                handleGenresLeave();
                                                            }}
                                                        >
                                                            <Box
                                                                sx={{
                                                                    cursor: "pointer",
                                                                    padding: isDrawerOpen ? 0.75 : 1.5,
                                                                    textAlign: "center",
                                                                    transition: "background-color 0.2s",
                                                                    "&:hover": {
                                                                        backgroundColor: theme.vars.palette.green.main,
                                                                    },
                                                                }}
                                                            >
                                                                <Typography
                                                                    component={"span"}
                                                                    sx={{
                                                                        fontSize: "0.875rem",
                                                                        fontWeight: 500,
                                                                        letterSpacing: "0.02em",
                                                                        color: "inherit",
                                                                    }}
                                                                >
                                                                    {genre.name}
                                                                </Typography>
                                                            </Box>
                                                        </Link>
                                                    </motion.div>
                                                ))}
                                            </Paper>
                                        </motion.div>
                                    )}
                                </AnimatePresence>
                            </Popper>
                        </Box>
                    </ListItem>
                </List>
            </Box>
        </>
    );
}


================================================
File: src/components/root/header/MessageCounter.tsx
================================================
"use client";

import { getUnreadMessagesCount } from "@/actions/user/userMessages.actions";
import { theme } from "@/utils/theme/theme";
import { Badge, IconButton } from "@mui/material";
import EmailIcon from "@mui/icons-material/Email";
import { Session } from "next-auth";
import { useEffect, useState } from "react";
import MuiNextLink from "../muiNextLink/MuiNextLink";

interface IMessageCounterProps {
    session: Session | null;
}

export default function MessageCounter({ session }: IMessageCounterProps) {
    const [unreadCount, setUnreadCount] = useState(0);

    useEffect(() => {
        if (session?.user?.id) {
            const fetchUnreadCount = async () => {
                const count = await getUnreadMessagesCount(Number(session.user.id));
                setUnreadCount(count);
            };

            fetchUnreadCount();
        }
    }, [session]);

    return (
        <IconButton
            LinkComponent={MuiNextLink}
            href="/messages?section=inbox"
            sx={{
                color: theme.vars.palette.primary.main,
                position: "relative",
            }}
        >
            <Badge badgeContent={unreadCount} color="error">
                <EmailIcon />
            </Badge>
        </IconButton>
    );
}


================================================
File: src/components/root/headerMobile/HeaderMobile.tsx
================================================
"use client";

import { CloseOutlined } from "@mui/icons-material";
import { Box, Drawer, IconButton, useMediaQuery, useTheme, Button } from "@mui/material";
import { useStore } from "@/store/store";
import { useEffect } from "react";
import { Session } from "next-auth";
import AuthButtons from "../authButtons/AuthButtons";
import { HeaderLinks } from "../header/HeaderLinks";
import ThemeToggleButton from "../themeToggleButton/ThemeToggleButton";
import SearchField from "../searchField/SearchField";
import { Genre } from "@prisma/client";
import EmailIcon from "@mui/icons-material/Email";
import MuiNextLink from "../muiNextLink/MuiNextLink";
import NotificationMenu from "../notificationMenu/NotificationMenu";

interface IHeaderMobileProps {
    genres: Genre[];
    anchorElProfile: null | HTMLElement;
    session: Session | null;
    userName: string;
    openMenuProfile: (event: any) => void;
    closeMenuProfile: () => void;
    handleSignOut: () => Promise<void>;
}

export default function HeaderMobile({
    genres,
    anchorElProfile,
    openMenuProfile,
    closeMenuProfile,
    handleSignOut,
    userName,
    session,
}: IHeaderMobileProps) {
    const { isDrawerOpen, setIsDrawerOpen } = useStore();
    const theme = useTheme();
    const isFullScreen = useMediaQuery(theme.breakpoints.up("md"));

    useEffect(() => {
        if (isFullScreen && isDrawerOpen) {
            setIsDrawerOpen(false);
        }
    }, [isFullScreen, isDrawerOpen, setIsDrawerOpen]);

    return (
        <Drawer variant="persistent" open={isDrawerOpen} onClose={() => setIsDrawerOpen(false)} component={"aside"}>
            <Box>
                <Box
                    sx={{
                        display: "flex",
                        placeContent: "end",
                        marginRight: 2,
                        marginTop: 1,
                    }}
                >
                    <IconButton
                        onClick={() => {
                            setIsDrawerOpen(false);
                        }}
                    >
                        <CloseOutlined />
                    </IconButton>
                </Box>
                <HeaderLinks genres={genres} />
                <Box
                    sx={{
                        marginTop: 2,
                        ml: 2,
                        mr: 2,
                    }}
                >
                    <SearchField />
                </Box>
                <Box
                    sx={{
                        marginTop: 4,
                        ml: 2,
                        mr: 2,
                    }}
                >
                    {session?.user && (
                        <Button
                            LinkComponent={MuiNextLink}
                            href="/messages"
                            variant="text"
                            sx={{
                                color: theme.vars.palette.primary.main,
                            }}
                        >
                            <EmailIcon />
                        </Button>
                    )}
                    {session?.user && <NotificationMenu session={session} />}
                    <ThemeToggleButton />
                </Box>
                <Box
                    sx={{
                        marginTop: 3,
                        display: "flex",
                        flexDirection: "row",
                        columnGap: 3,
                        ml: 2,
                        mr: 2,
                        mb: 2,
                    }}
                >
                    <AuthButtons
                        session={session}
                        anchorElProfile={anchorElProfile}
                        closeMenuProfile={closeMenuProfile}
                        handleSignOut={handleSignOut}
                        openMenuProfile={openMenuProfile}
                        userName={userName}
                    />
                </Box>
            </Box>
        </Drawer>
    );
}


================================================
File: src/components/root/latestList/LatestList.tsx
================================================
"use client";

import { Box, Stack, Typography, useTheme } from "@mui/material";
import CardItem from "../cardItem/CardItem";
import { Movie, Serie } from "@prisma/client";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface ILatestListProps {
    data: Array<Movie | Serie> | null;
    type: string;
}

export function LatestList({ data, type }: ILatestListProps) {
    const theme = useTheme();

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                maxWidth: "1200px",
                margin: "0 auto",
                width: "100%",
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 3, md: 4 },
            }}
        >
            <Box
                sx={{
                    mb: { xs: 1, md: 2 },
                    display: "flex",
                    justifyContent: { xs: "center", md: "flex-start" },
                }}
            >
                <Typography
                    variant="h2"
                    sx={{
                        fontSize: { xs: 24, sm: 28, md: 32 },
                        fontWeight: 800,
                        color: theme.vars.palette.text.primary,
                        position: "relative",
                        display: "inline-block",
                        "&::after": {
                            content: '""',
                            position: "absolute",
                            bottom: -8,
                            left: 0,
                            width: "100%",
                            height: 3,
                            bgcolor: theme.vars.palette.primary.main,
                            borderRadius: 1,
                        },
                    }}
                >
                    Latest {type}
                </Typography>
            </Box>

            <Box
                sx={{
                    width: "100%",
                    overflow: "hidden",
                    mt: { xs: 4, md: 5 },
                }}
            >
                <Stack
                    direction="row"
                    flexWrap="wrap"
                    sx={{
                        columnGap: { xs: 1, sm: 2, md: 3 },
                        rowGap: { xs: 3, sm: 4, md: 5 },
                        justifyContent: {
                            xs: "center",
                            md: "flex-start",
                        },
                        mx: { xs: 1, sm: 2 },
                    }}
                >
                    {data?.map((item) => (
                        <CardItem
                            key={item.id}
                            data={item}
                            type={type.toLowerCase() === "movies" ? "movie" : "serie"}
                        />
                    ))}
                </Stack>
            </Box>
        </Box>
    );
}

export default LatestList;


================================================
File: src/components/root/listDetail/ListDetail.tsx
================================================
import { Box, Typography, useTheme } from "@mui/material";
import CardItem, { CardItemType, PathType } from "../cardItem/CardItem";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IListDetailProps {
    data: any;
    type: CardItemType;
    roleData: string;
}

export function ListDetail({ data, type, roleData }: IListDetailProps) {
    const theme = useTheme();

    if (!data || data.length === 0) return null;

    const getTitle = () => {
        if (type === "actor") {
            return roleData === "cast" ? "Cast" : `Starred ${roleData}`;
        }

        if (type === "crew") {
            return roleData === "production" ? "Crew" : `Worked on ${roleData}`;
        }

        return `${roleData === "related" ? "Related" : ""} ${
            type === "movie"
                ? "Movies"
                : type === "serie"
                  ? "Series"
                  : type === "season"
                    ? "Seasons"
                    : type === "episode"
                      ? "Episodes"
                      : ""
        }`;
    };

    const getItemData = (item: any) => {
        if (type === "actor") {
            if (roleData === "Movies") return item.movie;
            if (roleData === "Series") return item.serie;
            if (roleData === "cast") return item.actor;
        }

        if (type === "crew") {
            if (roleData === "production") return item.crew;
            if (roleData === "Movies") return item.movie;
            if (roleData === "Series") return item.serie;
        }

        return item;
    };

    const getItemPath = () => {
        if (type === "actor") {
            if (roleData === "Movies") return "movies";
            if (roleData === "Series") return "series";
            if (roleData === "cast") return "actors";
        }

        if (type === "crew") {
            if (roleData === "Movies") return "movies";
            if (roleData === "Series") return "series";
            if (roleData === "production") return "crew";
        }

        return null;
    };

    return (
        <Box
            component="section"
            sx={{
                display: "flex",
                flexDirection: "column",
                gap: 4,
                width: "100%",
                maxWidth: "1200px",
                margin: "0 auto",
                px: { xs: 2, sm: 3, md: 4 },
            }}
        >
            <Box
                sx={{
                    mb: { xs: 1, md: 2 },
                    display: "flex",
                    justifyContent: { xs: "center", md: "flex-start" },
                }}
            >
                <Typography
                    variant="h2"
                    sx={{
                        fontSize: { xs: 24, sm: 28, md: 32 },
                        fontWeight: 800,
                        color: theme.vars.palette.text.primary,
                        position: "relative",
                        display: "inline-block",
                        "&::after": {
                            content: '""',
                            position: "absolute",
                            bottom: -8,
                            left: 0,
                            width: "100%",
                            height: 3,
                            bgcolor: theme.vars.palette.primary.main,
                            borderRadius: 1,
                        },
                    }}
                >
                    {getTitle()}
                </Typography>
            </Box>
            <Box
                sx={{
                    display: "grid",
                    gridTemplateColumns: {
                        xs: "repeat(auto-fill, minmax(120px, 1fr))",
                        sm: "repeat(auto-fill, minmax(140px, 1fr))",
                        md: "repeat(auto-fill, minmax(150px, 1fr))",
                        lg: "repeat(auto-fill, minmax(160px, 1fr))",
                    },
                    gap: { xs: 1, sm: 2, md: 3 },
                    width: "100%",
                    justifyItems: { xs: "center", md: "start" },
                }}
            >
                {data.map((item: any, index: number) => (
                    <CardItem key={index} data={getItemData(item)} type={type} path={getItemPath()!} />
                ))}
            </Box>
        </Box>
    );
}

export default ListDetail;


================================================
File: src/components/root/loadingSpinner/LoadingSpinner.tsx
================================================
"use client";

import { Box, CircularProgress } from "@mui/material";
import Image from "next/image";

const LoadingSpinner = () => {
    return (
        <Box
            sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
                minHeight: "100vh",
                width: "100%",
                bgcolor: "background.default",
                gap: 5,
            }}
        >
            <Box
                sx={{
                    width: { xs: 240, sm: 320 },
                    height: 120,
                    position: "relative",
                }}
            >
                <Image
                    src="/icons/movielandia24-logo.png"
                    alt="MovieLandia24 Loading"
                    width={320}
                    height={120}
                    priority
                    style={{
                        width: "100%",
                        height: "100%",
                        objectFit: "contain",
                    }}
                />
            </Box>
            <CircularProgress />
        </Box>
    );
};

export default LoadingSpinner;


================================================
File: src/components/root/muiNextLink/MuiNextLink.tsx
================================================
import { Link as MuiLink } from "@mui/material";
import NextLink from "next/link";

type MuiLinkProps = Parameters<typeof MuiLink>[0] & {
    href: string;
    prefetch?: boolean;
    ref: any;
    type?: string;
};

const MuiNextLink = (props: MuiLinkProps) => {
    return (
        <MuiLink
            component={NextLink}
            {...props}
            sx={{
                ":hover":
                    props.type && props.type === "mainLogo"
                        ? {
                              backgroundColor: "transparent",
                              color: "inherit",
                          }
                        : {},
            }}
        ></MuiLink>
    );
};

export default MuiNextLink;


================================================
File: src/components/root/notificationMenu/NotificationMenu.tsx
================================================
"use client";

import {
    getPaginatedNotifications,
    getUnreadNotificationsCount,
    markNotificationsAsRead,
} from "@/actions/user/userFollow.actions";
import { theme } from "@/utils/theme/theme";
import {
    Box,
    IconButton,
    Badge,
    Popper,
    Paper,
    Typography,
    Divider,
    Stack,
    Avatar,
    CircularProgress,
} from "@mui/material";
import { AnimatePresence, motion } from "framer-motion";
import Link from "next/link";
import { useEffect, useState, useRef } from "react";
import NotificationsIcon from "@mui/icons-material/Notifications";
import { Session } from "next-auth";
import ClickAwayListener from "@mui/material/ClickAwayListener";
import NotificationsActiveIcon from "@mui/icons-material/NotificationsActive";
import { formatDistanceToNow } from "date-fns";

interface INotificationMenu {
    session: Session | null;
}

export default function NotificationMenu({ session }: INotificationMenu) {
    const [notificationAnchorEl, setNotificationAnchorEl] = useState<null | HTMLElement>(null);
    const [unreadCount, setUnreadCount] = useState(0);
    const [notifications, setNotifications] = useState<any[]>([]);
    const [currentPage, setCurrentPage] = useState(1);
    const [isLoading, setIsLoading] = useState(true);
    const [hasMore, setHasMore] = useState(true);

    const loaderRef = useRef<HTMLDivElement>(null);
    const isOpen = Boolean(notificationAnchorEl);

    const fetchNotifications = async (page: number) => {
        if (!session?.user?.id) return;

        if (page === 1) {
            setIsLoading(true);
        }

        try {
            const response = await fetch(`/api/notifications?userId=${session.user.id}&page=${page}&limit=5`);

            if (!response.ok) {
                throw new Error("Failed to fetch notifications");
            }

            const newNotifications = await response.json();

            if (newNotifications.length < 5) {
                setHasMore(false);
            }

            setNotifications((prev) => (page === 1 ? newNotifications : [...prev, ...newNotifications]));
            setCurrentPage(page);
        } catch (error) {
            console.error("Error fetching notifications:", error);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        const observer = new IntersectionObserver(
            (entries) => {
                const first = entries[0];
                if (first.isIntersecting && hasMore && isOpen && !isLoading) {
                    fetchNotifications(currentPage + 1);
                }
            },
            { threshold: 0.1 },
        );

        const currentLoaderRef = loaderRef.current;
        if (currentLoaderRef) {
            observer.observe(currentLoaderRef);
        }

        return () => {
            if (currentLoaderRef) {
                observer.unobserve(currentLoaderRef);
            }
        };
    }, [currentPage, hasMore, isOpen, isLoading]);

    const handleNotificationClick = async (event: React.MouseEvent<HTMLElement>) => {
        if (isOpen) {
            setNotificationAnchorEl(null);
            return;
        }

        setIsLoading(true);
        setNotificationAnchorEl(event.currentTarget);
        setCurrentPage(1);
        setHasMore(true);
        setNotifications([]);

        if (session?.user?.id) {
            await markNotificationsAsRead(Number(session.user.id));
            setUnreadCount(0);
            await fetchNotifications(1);
        }
    };

    const handleClickAway = () => {
        setNotificationAnchorEl(null);
    };

    useEffect(() => {
        if (session?.user?.id) {
            const fetchNotifications = async () => {
                const count = await getUnreadNotificationsCount(Number(session.user.id));
                setUnreadCount(count);
            };

            fetchNotifications();
        }
    }, [session]);

    return (
        <Box>
            <ClickAwayListener onClickAway={handleClickAway}>
                <Box>
                    <IconButton
                        onClick={handleNotificationClick}
                        sx={{
                            color: theme.vars.palette.primary.main,
                        }}
                    >
                        <Badge badgeContent={unreadCount} color="error">
                            <NotificationsIcon />
                        </Badge>
                    </IconButton>
                    <Popper
                        open={isOpen}
                        anchorEl={notificationAnchorEl}
                        placement="bottom-end"
                        sx={{
                            zIndex: 1300,
                        }}
                    >
                        <AnimatePresence>
                            {isOpen && (
                                <motion.div
                                    initial={{ opacity: 0, scale: 0.6, y: -40 }}
                                    animate={{
                                        opacity: 1,
                                        scale: 1,
                                        y: 0,
                                        transition: {
                                            type: "spring",
                                            stiffness: 200,
                                            damping: 20,
                                        },
                                    }}
                                    exit={{
                                        opacity: 0,
                                        scale: 0.6,
                                        y: -20,
                                        transition: {
                                            duration: 0.2,
                                        },
                                    }}
                                    style={{ transformOrigin: "top right" }}
                                >
                                    <Paper
                                        sx={{
                                            mt: 1,
                                            width: 360,
                                            maxHeight: 400,
                                            overflow: "auto",
                                        }}
                                    >
                                        <Box sx={{ p: 2 }}>
                                            <Stack
                                                direction="row"
                                                alignItems="center"
                                                justifyContent="space-between"
                                                sx={{ mb: 2 }}
                                            >
                                                <Typography variant="h6">Notifications</Typography>
                                                <Link
                                                    href="/notifications"
                                                    onClick={handleClickAway}
                                                    style={{
                                                        textDecoration: "none",
                                                    }}
                                                >
                                                    <Typography
                                                        variant="body2"
                                                        sx={{
                                                            color: "primary.main",
                                                            "&:hover": {
                                                                textDecoration: "underline",
                                                            },
                                                        }}
                                                    >
                                                        View All
                                                    </Typography>
                                                </Link>
                                            </Stack>
                                            <Divider />
                                            <Stack spacing={2} sx={{ mt: 2 }}>
                                                {isLoading ? (
                                                    <Box
                                                        sx={{
                                                            display: "flex",
                                                            justifyContent: "center",
                                                            p: 4,
                                                        }}
                                                    >
                                                        <CircularProgress size={24} />
                                                    </Box>
                                                ) : notifications.length > 0 ? (
                                                    <>
                                                        {notifications.map((notification) => (
                                                            <Box
                                                                key={notification.id}
                                                                sx={{
                                                                    p: 1.5,
                                                                    borderRadius: 1,
                                                                    cursor: "default",
                                                                    transition: "all 0.2s",
                                                                    bgcolor:
                                                                        notification.status === "unread"
                                                                            ? "action.hover"
                                                                            : "transparent",
                                                                    "&:hover": {
                                                                        bgcolor: "background.default",
                                                                    },
                                                                }}
                                                                onClick={handleClickAway}
                                                            >
                                                                <Stack
                                                                    direction="row"
                                                                    spacing={2}
                                                                    alignItems="flex-start"
                                                                >
                                                                    <Avatar
                                                                        src={notification.sender.avatar?.photoSrc}
                                                                        alt={notification.sender.userName}
                                                                        sx={{ width: 40, height: 40 }}
                                                                    />
                                                                    <Box sx={{ flex: 1 }}>
                                                                        <Typography
                                                                            variant="body2"
                                                                            sx={{
                                                                                fontWeight:
                                                                                    notification.status === "unread"
                                                                                        ? 600
                                                                                        : 400,
                                                                            }}
                                                                        >
                                                                            {notification.sender.userName}
                                                                        </Typography>
                                                                        <Typography
                                                                            variant="body2"
                                                                            color="text.secondary"
                                                                            sx={{
                                                                                mt: 0.5,
                                                                                opacity:
                                                                                    notification.status === "unread"
                                                                                        ? 1
                                                                                        : 0.7,
                                                                            }}
                                                                        >
                                                                            {notification.content}
                                                                        </Typography>
                                                                        <Typography
                                                                            variant="caption"
                                                                            color="text.secondary"
                                                                            sx={{
                                                                                mt: 0.5,
                                                                                display: "block",
                                                                                opacity: 0.8,
                                                                            }}
                                                                        >
                                                                            {formatDistanceToNow(
                                                                                new Date(notification.createdAt),
                                                                                { addSuffix: true },
                                                                            )}
                                                                        </Typography>
                                                                    </Box>
                                                                </Stack>
                                                            </Box>
                                                        ))}
                                                        {hasMore && <div ref={loaderRef} style={{ height: 1 }} />}
                                                    </>
                                                ) : (
                                                    <Box
                                                        sx={{
                                                            py: 4,
                                                            display: "flex",
                                                            flexDirection: "column",
                                                            alignItems: "center",
                                                            gap: 2,
                                                        }}
                                                    >
                                                        <NotificationsActiveIcon
                                                            sx={{
                                                                fontSize: 48,
                                                                color: "text.disabled",
                                                            }}
                                                        />
                                                        <Typography
                                                            variant="body1"
                                                            color="text.secondary"
                                                            align="center"
                                                        >
                                                            No notifications yet
                                                        </Typography>
                                                    </Box>
                                                )}
                                            </Stack>
                                        </Box>
                                    </Paper>
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </Popper>
                </Box>
            </ClickAwayListener>
        </Box>
    );
}


================================================
File: src/components/root/paginationControl/PaginationControl.tsx
================================================
"use client";

import React from "react";
import { Box, Pagination, PaginationItem } from "@mui/material";
import { useQueryState } from "nuqs";

interface PaginationControlProps {
    currentPage: number;
    pageCount: number;
    urlParamName?: string;
}

export default function PaginationControl({ currentPage, pageCount, urlParamName = "page" }: PaginationControlProps) {
    const [page, setPage] = useQueryState(urlParamName, {
        defaultValue: "1",
        parse: (value) => value || "1",
        shallow: false,
    });

    const handleChange = (_event: React.ChangeEvent<unknown>, value: number) => {
        if (value === currentPage) return;
        setPage(value.toString());
    };

    return (
        <Box sx={{ display: "flex", justifyContent: "center" }}>
            <Pagination
                page={currentPage}
                onChange={handleChange}
                count={pageCount}
                showLastButton={true}
                showFirstButton={true}
                variant="outlined"
                shape="rounded"
                size="large"
                renderItem={(item) => (
                    <PaginationItem {...item} disabled={item.page === currentPage || item.disabled} />
                )}
            />
        </Box>
    );
}


================================================
File: src/components/root/review/Review.tsx
================================================
"use client";

import React, { Dispatch, SetStateAction, useState } from "react";
import { format } from "date-fns";
import { Box, Paper, Typography, IconButton, useTheme, Rating, Button } from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import EditIcon from "@mui/icons-material/Edit";
import ThumbUpIcon from "@mui/icons-material/ThumbUp";
import ThumbDownIcon from "@mui/icons-material/ThumbDown";
import { motion } from "framer-motion";
import { useSession } from "next-auth/react";
import { useRouter, usePathname } from "next/navigation";
import Image from "next/image";
import PersonOutlinedIcon from "@mui/icons-material/PersonOutlined";
import type {} from "@mui/material/themeCssVarsAugmentation";

interface IReviewProps {
    review: Review;
    setRating: React.Dispatch<React.SetStateAction<number | null>>;
    ref: any;
    setIsEditMode: Dispatch<SetStateAction<boolean>>;
    isEditMode: boolean;
    setReview: React.Dispatch<React.SetStateAction<string>>;
    type: string;
    data: any;
    handleRemoveReview: () => void;
    handleFocusTextEditor: () => void;
    handleUpvote: (reviewId: number, isAlreadyUpvotedOrDownvoted: boolean) => void;
    handleDownvote: (reviewId: number, isAlreadyUpvotedOrDownvoted: boolean) => void;
}

type Review = {
    id: number;
    content: string;
    createdAt: string;
    updatedAt: string;
    rating: number;
    upvotes: any[];
    downvotes: any[];
    isUpvoted: boolean;
    isDownvoted: boolean;
    _count: {
        upvotes: number;
        downvotes: number;
    };
    user: {
        id: number;
        userName: string;
        avatar: any;
    };
};

const Review: React.FC<IReviewProps> = ({
    review,
    handleRemoveReview,
    isEditMode,
    setIsEditMode,
    setReview,
    setRating,
    handleUpvote,
    handleDownvote,
    ref,
}) => {
    // #region "State, hooks, theme, also colorFunction utils"
    const getRatingLabelAndColor = (rating: number) => {
        if (rating <= 2) {
            return { label: "Very Bad", color: "error.main" };
        }

        if (rating <= 4) {
            return { label: "Bad", color: "warning.main" };
        }

        if (rating <= 6) {
            return { label: "Average", color: "info.main" };
        }

        if (rating <= 8) {
            return { label: "Good", color: "success.light" };
        }

        return { label: "Very Good", color: "success.main" };
    };

    const { data: session } = useSession();

    const [isClickedUpvote, setIsClickedUpvote] = useState(false);
    const [isClickedDownvote, setIsClickedDownvote] = useState(false);

    const router = useRouter();
    const pathname = usePathname();
    const theme = useTheme();

    const { label, color } = getRatingLabelAndColor(review.rating);
    // #endregion

    // #region "Event handlers and other functions"
    async function handleClickUpVoteReview() {
        setIsClickedUpvote(true);

        if (review.isUpvoted) {
            handleUpvote(review.id, true);
        } else {
            handleUpvote(review.id, false);
        }
    }

    async function handleClickDownVoteReview() {
        setIsClickedDownvote(true);

        if (review.isDownvoted) {
            handleDownvote(review.id, true);
        } else {
            handleDownvote(review.id, false);
        }
    }
    // #endregion

    return (
        <Paper
            sx={{
                p: 3,
                mt: 2,
                mx: 3,
                backgroundColor:
                    review.user.id === Number(session?.user?.id)
                        ? theme.vars.palette.blue.dark
                        : theme.vars.palette.background.default,
            }}
        >
            <Box
                sx={{
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    mb: 1,
                }}
            >
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        flexWrap: "wrap",
                        gap: 1,
                        cursor: "pointer",
                    }}
                    onClick={() => {
                        router.push(`/users/${review.user.id}/${review.user.userName}`);
                    }}
                >
                    {review.user.avatar?.photoSrc ? (
                        <Image
                            alt={review.user.userName}
                            height={50}
                            width={50}
                            style={{
                                borderRadius: 20,
                            }}
                            src={review.user.avatar?.photoSrc}
                        />
                    ) : (
                        <PersonOutlinedIcon
                            sx={{
                                fontSize: 24,
                                mr: 1,
                                color: theme.vars.palette.primary.main,
                            }}
                        />
                    )}
                    <Typography
                        variant="h6"
                        sx={{
                            color:
                                review.user.id === Number(session?.user?.id)
                                    ? theme.vars.palette.blue.main
                                    : theme.vars.palette.primary.main,
                            fontWeight: review.user.id === Number(session?.user?.id) ? 900 : 300,
                            letterSpacing: 1,
                        }}
                    >
                        {review.user.userName}
                    </Typography>
                    {review.user.id === Number(session?.user?.id) && (
                        <Typography component={"span"} paddingLeft={1} color="primary">
                            - You
                        </Typography>
                    )}
                </Box>
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        flexWrap: "wrap",
                        gap: 1,
                    }}
                >
                    <Typography variant="body1" sx={{ display: "flex", flexWrap: "wrap" }}>
                        {review.updatedAt && (
                            <Typography component={"span"} color="primary">
                                Edited
                            </Typography>
                        )}
                        {!review.updatedAt ? (
                            <Typography component={"span"} paddingLeft={1}>
                                {format(new Date(review.createdAt), "MMMM dd, yyyy HH:mm")}
                            </Typography>
                        ) : (
                            <Typography component={"span"} paddingLeft={1}>
                                {format(new Date(review.updatedAt), "MMMM dd, yyyy HH:mm")}
                            </Typography>
                        )}
                    </Typography>
                    {review.user.id === Number(session?.user?.id) && !isEditMode && (
                        <IconButton
                            size="medium"
                            color="success"
                            onClick={() => {
                                setIsEditMode(true);
                                setReview(review.content);
                                setRating(review.rating);
                            }}
                        >
                            <EditIcon fontSize="medium" />
                        </IconButton>
                    )}
                    {review.user.id === Number(session?.user?.id) && !isEditMode && (
                        <Box ref={ref} tabIndex={-1}>
                            <IconButton size="medium" color="error" onClick={() => handleRemoveReview()}>
                                <CloseIcon fontSize="medium" />
                            </IconButton>
                        </Box>
                    )}
                </Box>
            </Box>
            <Box
                dangerouslySetInnerHTML={{ __html: review.content }}
                sx={{
                    wordWrap: "break-word",
                    "& img": { maxWidth: "70%", height: "auto" },
                }}
            />
            <Box
                sx={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    mt: 1,
                }}
            >
                <Box sx={{ display: "flex", alignItems: "center" }}>
                    <Typography variant="body1" fontSize={19} fontWeight={900} sx={{ mr: 1, color, letterSpacing: 2 }}>
                        {label}
                    </Typography>
                </Box>
                <Box sx={{ display: "flex", alignItems: "center" }}>
                    <Rating
                        name={`review-rating-${review.id}`}
                        value={review?.rating}
                        readOnly
                        max={10}
                        precision={0.5}
                    />
                    <Typography variant="body2" fontSize={14} fontWeight={700} sx={{ ml: 1 }}>
                        {review?.rating ? review?.rating?.toFixed(1) : "0.0"}
                    </Typography>
                </Box>
            </Box>
            <Box
                sx={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    mt: 1,
                    columnGap: 4,
                }}
            >
                <Box display={"flex"} alignItems={"center"}>
                    <motion.div
                        whileTap={{ scale: 1 }}
                        animate={isClickedUpvote ? { scale: [1, 1.5, 1] } : {}}
                        transition={{ duration: 0.5, ease: "easeInOut" }}
                    >
                        <IconButton
                            size="medium"
                            disabled={session?.user && review.user.id !== Number(session?.user?.id) ? false : true}
                            onClick={async () => {
                                handleClickUpVoteReview();
                            }}
                            sx={{
                                color: review.isUpvoted
                                    ? theme.vars.palette.green.main
                                    : theme.vars.palette.primary.main,
                                pr: 0.5,
                            }}
                        >
                            <ThumbUpIcon fontSize="medium" />
                        </IconButton>
                    </motion.div>
                    <Button
                        disabled={review._count.upvotes === 0}
                        onClick={() => {
                            if (review._count.upvotes > 0) {
                                router.push(`${pathname}/reviews/${review.id}/upvotes`);
                            }
                        }}
                        sx={{
                            "&:hover": {
                                backgroundColor: "transparent",
                                textDecoration: review._count.upvotes > 0 ? "underline" : "none",
                            },
                            color: theme.vars.palette.primary.main,
                            p: 0,
                            minWidth: "auto",
                            ml: 1,
                            cursor: review._count.upvotes > 0 ? "pointer" : "default",
                        }}
                    >
                        <Typography>{review._count.upvotes}</Typography>
                    </Button>
                </Box>
                <Box display={"flex"} alignItems={"center"}>
                    <motion.div
                        whileTap={{ scale: 1 }}
                        animate={isClickedDownvote ? { scale: [1, 1.5, 1] } : {}}
                        transition={{ duration: 0.5, ease: "easeInOut" }}
                    >
                        <IconButton
                            size="medium"
                            disabled={session?.user && review.user.id !== Number(session?.user?.id) ? false : true}
                            onClick={async () => {
                                handleClickDownVoteReview();
                            }}
                            sx={{
                                color: review.isDownvoted
                                    ? theme.vars.palette.red.main
                                    : theme.vars.palette.primary.main,
                                pr: 0.5,
                            }}
                        >
                            <ThumbDownIcon fontSize="medium" />
                        </IconButton>
                    </motion.div>
                    <Button
                        disabled={review._count.downvotes === 0}
                        onClick={() => {
                            if (review._count.downvotes > 0) {
                                router.push(`${pathname}/reviews/${review.id}/downvotes`);
                            }
                        }}
                        sx={{
                            "&:hover": {
                                backgroundColor: "transparent",
                                textDecoration: review._count.downvotes > 0 ? "underline" : "none",
                            },
                            color: theme.vars.palette.primary.main,
                            p: 0,
                            minWidth: "auto",
                            ml: 1,
                            cursor: review._count.downvotes > 0 ? "pointer" : "default",
                        }}
                    >
                        <Typography>{review._count.downvotes}</Typography>
                    </Button>
                </Box>
            </Box>
        </Paper>
    );
};

export default Review;


================================================
File: src/components/root/reviewsHeader/ReviewsHeader.tsx
================================================
import { Box, Stack, Typography } from "@mui/material";
import SortSelect from "../sortSelect/SortSelect";

interface IReviewsProps {
    data: {
        totalReviews: number;
    };
    sortBy: string;
    ascOrDesc: string;
    sortingDataType: string;
}

const ReviewsHeader = ({ data, sortBy, ascOrDesc, sortingDataType }: IReviewsProps) => {
    return (
        <Stack direction="row" justifyContent="space-between" alignItems="center" px={3}>
            <Box>
                <Typography variant="h3" align="center">
                    {data.totalReviews} Reviews
                </Typography>
            </Box>
            <Box>
                <SortSelect sortBy={sortBy} ascOrDesc={ascOrDesc} type="details" dataType={sortingDataType} />
            </Box>
        </Stack>
    );
};

export default ReviewsHeader;


================================================
File: src/components/root/scrollToTop/ScrollToTop.tsx
================================================
"use client";

import { IS_BROWSER } from "@/utils/helpers/utils";
import { KeyboardArrowUp } from "@mui/icons-material";
import { Box, Fab, Zoom, useScrollTrigger, useTheme } from "@mui/material";
import type {} from "@mui/material/themeCssVarsAugmentation";

function ScrollToTop() {
    const theme = useTheme();

    const trigger = useScrollTrigger({
        threshold: 150,
        disableHysteresis: true,
    });

    const scrollToTop = () => {
        if (IS_BROWSER) {
            window.scrollTo({ top: 0, behavior: "smooth" });
        }
    };

    return (
        <Zoom in={trigger}>
            <Box
                role="presentation"
                sx={{
                    position: "fixed",
                    bottom: 32,
                    right: 32,
                    zIndex: 1,
                }}
            >
                <Fab
                    onClick={scrollToTop}
                    size="large"
                    aria-label="Scroll back to top"
                    sx={{
                        color: theme.vars.palette.green.main,
                        backgroundColor: theme.vars.palette.primary.main,
                    }}
                >
                    <KeyboardArrowUp fontSize="large" />
                </Fab>
            </Box>
        </Zoom>
    );
}

export default ScrollToTop;


================================================
File: src/components/root/searchField/SearchAutocomplete.tsx
================================================
"use client";

import { Box, CircularProgress, Typography, useTheme, Button, Divider } from "@mui/material";
import { Actor, Crew, Episode, Movie, Season, Serie, User } from "@prisma/client";
import { Chip, Stack } from "@mui/material";
import { ArrowForward } from "@mui/icons-material";
import SearchResultCard from "./SearchResultCard";

interface SearchAutocompleteProps {
    loading: boolean;
    results: {
        movies: { items: Movie[]; total: number };
        series: { items: Serie[]; total: number };
        actors: { items: Actor[]; total: number };
        crews: { items: Crew[]; total: number };
        seasons: { items: Season[]; total: number };
        episodes: { items: Episode[]; total: number };
        users: { items: User[]; total: number };
    };
    selectedFilters: string[];
    searchTerm: string;
    showInitialState: boolean;
    onFilterChange: (filter: string) => void;
    onShowMore: () => void;
    onClose: () => void;
    onResultClick: () => void;
}

const SearchAutocomplete = ({
    loading,
    results,
    selectedFilters,
    onFilterChange,
    searchTerm,
    onShowMore,
    onClose,
    onResultClick,
    showInitialState,
}: SearchAutocompleteProps) => {
    const theme = useTheme();

    const filters = [
        { label: "All", value: "all" },
        { label: "Movies", value: "movies" },
        { label: "Series", value: "series" },
        { label: "Actors", value: "actors" },
        { label: "Crew", value: "crew" },
        { label: "Seasons", value: "seasons" },
        { label: "Episodes", value: "episodes" },
        { label: "Users", value: "users" },
    ];

    const shouldShowSection = (type: string) => {
        if (selectedFilters.includes("all")) return true;
        return selectedFilters.includes(type.toLowerCase());
    };

    const hasAnyResults = Object.values(results).some((category) => category.items.length > 0);

    const NoResultsMessage = () =>
        searchTerm ? (
            <Box
                sx={{
                    py: 4,
                    textAlign: "center",
                    color: theme.vars.palette.text.secondary,
                }}
            >
                <Typography variant="body1">No results found for &quot;{searchTerm}&quot;</Typography>
                <Typography variant="caption">
                    Try adjusting your search or filters to find what you&apos;re looking for
                </Typography>
            </Box>
        ) : null;

    const NoSectionResults = ({ section }: { section: string }) => (
        <Typography
            variant="body2"
            sx={{
                py: 1,
                px: 2,
                color: theme.vars.palette.text.secondary,
                fontStyle: "italic",
            }}
        >
            No {section.toLowerCase()} found
        </Typography>
    );

    const SectionTitle = ({
        title,
        shownCount,
        totalCount,
    }: {
        title: string;
        shownCount: number;
        totalCount: number;
    }) => (
        <Typography
            variant="subtitle1"
            sx={{
                textAlign: "center",
                fontWeight: 600,
                color: theme.vars.palette.text.primary,
                mb: 1.5,
                position: "relative",
                "&::after": {
                    content: '""',
                    position: "absolute",
                    bottom: -8,
                    left: "50%",
                    transform: "translateX(-50%)",
                    width: 40,
                    height: 2,
                    bgcolor: theme.vars.palette.primary.main,
                    borderRadius: 1,
                },
            }}
        >
            {title}{" "}
            {totalCount > 0 && (
                <Box
                    component="span"
                    sx={{
                        fontSize: "0.85em",
                        color: theme.vars.palette.text.secondary,
                        ml: 1,
                    }}
                >
                    ({shownCount} of {totalCount})
                </Box>
            )}
        </Typography>
    );

    const LoadingState = () => (
        <Box
            sx={{
                position: "absolute",
                top: "100%",
                left: 0,
                right: 0,
                bgcolor: "background.paper",
                borderRadius: 1,
                boxShadow: theme.shadows[3],
                p: 2,
                zIndex: 1000,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                minHeight: 100,
            }}
        >
            <CircularProgress size={24} />
        </Box>
    );

    const InitialState = () => (
        <Box sx={{ py: 4, textAlign: "center", color: theme.vars.palette.text.secondary }}>
            <Typography variant="body1">Select a category and start typing to search</Typography>
            <Typography variant="caption">You can search across movies, series, actors, and more</Typography>
        </Box>
    );

    const getTotalResults = () => {
        return Object.values(results).reduce((sum, category) => {
            return sum + (category?.total || 0);
        }, 0);
    };

    const getFilterSpecificResults = () => {
        const selectedCategories = selectedFilters.includes("all")
            ? filters.filter((f) => f.value !== "all")
            : filters.filter((f) => selectedFilters.includes(f.value));

        const counts = selectedCategories
            .map((filter) => {
                const key = filter.value === "crew" ? "crews" : `${filter.value}`;
                const category = results[key.toLowerCase() as keyof typeof results];

                if (!category) return null;

                return {
                    label: filter.label,
                    count: category.total || 0,
                };
            })
            .filter((item): item is { label: string; count: number } => item !== null && item.count > 0);

        if (counts.length === 0) return "";

        if (selectedFilters.includes("all")) {
            return `View all ${getTotalResults()} results`;
        }

        const totalCount = counts.reduce((sum, item) => sum + item.count, 0);

        if (counts.length === 1) {
            return `View all ${totalCount} ${counts[0].label.toLowerCase()} results`;
        }

        const categoriesText = counts
            .map((item, index) => {
                if (index === counts.length - 1) {
                    return `and all ${item.count} ${item.label.toLowerCase()}`;
                }

                return `${item.count} ${item.label.toLowerCase()}`;
            })
            .join(counts.length > 2 ? ", " : " ");

        return `View all ${categoriesText} results`;
    };

    if (loading) {
        return <LoadingState />;
    }

    return (
        <Box
            sx={{
                position: "absolute",
                top: "100%",
                left: 0,
                right: 0,
                bgcolor: "background.paper",
                borderRadius: 1,
                boxShadow: theme.shadows[3],
                p: 2,
                zIndex: 1000,
                maxHeight: "80vh",
                overflowY: "auto",
            }}
        >
            <Stack
                direction="row"
                spacing={1}
                sx={{
                    mb: 2,
                    pb: 2,
                    borderBottom: 1,
                    borderColor: "divider",
                    flexWrap: "wrap",
                    gap: 1,
                    justifyContent: "center",
                }}
            >
                {filters.map((filter) => (
                    <Chip
                        key={filter.value}
                        label={filter.label}
                        onClick={() => onFilterChange(filter.value)}
                        color={selectedFilters.includes(filter.value) ? "primary" : "default"}
                        variant={selectedFilters.includes(filter.value) ? "filled" : "outlined"}
                        sx={{
                            borderRadius: 1,
                            minWidth: filter.value === "all" ? 80 : "auto",
                            "&:hover": {
                                bgcolor: selectedFilters.includes(filter.value)
                                    ? theme.vars.palette.primary.main
                                    : theme.vars.palette.action.hover,
                            },
                        }}
                    />
                ))}
            </Stack>

            {showInitialState ? (
                <InitialState />
            ) : !hasAnyResults ? (
                <NoResultsMessage />
            ) : (
                <Stack spacing={3} sx={{ width: "100%" }}>
                    {shouldShowSection("movies") && (
                        <Box>
                            <SectionTitle
                                title="Movies"
                                shownCount={results.movies.items.length}
                                totalCount={results.movies.total}
                            />
                            <Box sx={{ mt: 1 }}>
                                {results.movies.items.length > 0 ? (
                                    <Stack spacing={1}>
                                        {results.movies.items.map((movie) => (
                                            <SearchResultCard
                                                key={movie.id}
                                                data={movie}
                                                type="movie"
                                                onResultClick={onResultClick}
                                            />
                                        ))}
                                    </Stack>
                                ) : (
                                    <NoSectionResults section="Movies" />
                                )}
                            </Box>
                        </Box>
                    )}
                    {shouldShowSection("movies") && shouldShowSection("series") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("series") && (
                        <Box>
                            <SectionTitle
                                title="Series"
                                shownCount={results.series.items.length}
                                totalCount={results.series.total}
                            />
                            {results.series.items.length > 0 ? (
                                <Stack spacing={1}>
                                    {results.series.items.map((serie) => (
                                        <SearchResultCard
                                            key={serie.id}
                                            data={serie}
                                            type="serie"
                                            onResultClick={onResultClick}
                                        />
                                    ))}
                                </Stack>
                            ) : (
                                <NoSectionResults section="Series" />
                            )}
                        </Box>
                    )}
                    {shouldShowSection("series") && shouldShowSection("actors") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("actors") && (
                        <Box>
                            <SectionTitle
                                title="Actors"
                                shownCount={results.actors.items.length}
                                totalCount={results.actors.total}
                            />
                            <Box sx={{ mt: 1 }}>
                                {results.actors.items.length > 0 ? (
                                    <Stack spacing={1}>
                                        {results.actors.items.map((actor) => (
                                            <SearchResultCard
                                                key={actor.id}
                                                data={actor}
                                                type="actor"
                                                path="actors"
                                                onResultClick={onResultClick}
                                            />
                                        ))}
                                    </Stack>
                                ) : (
                                    <NoSectionResults section="Actors" />
                                )}
                            </Box>
                        </Box>
                    )}
                    {shouldShowSection("actors") && shouldShowSection("crew") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("crew") && (
                        <Box>
                            <SectionTitle
                                title="Crew"
                                shownCount={results.crews.items.length}
                                totalCount={results.crews.total}
                            />
                            <Box sx={{ mt: 1 }}>
                                {results.crews.items.length > 0 ? (
                                    <Stack spacing={1}>
                                        {results.crews.items.map((crewMember) => (
                                            <SearchResultCard
                                                key={crewMember.id}
                                                data={crewMember}
                                                type="crew"
                                                path="crew"
                                                onResultClick={onResultClick}
                                            />
                                        ))}
                                    </Stack>
                                ) : (
                                    <NoSectionResults section="Crew" />
                                )}
                            </Box>
                        </Box>
                    )}
                    {shouldShowSection("crew") && shouldShowSection("seasons") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("seasons") && (
                        <Box>
                            <SectionTitle
                                title="Seasons"
                                shownCount={results.seasons.items.length}
                                totalCount={results.seasons.total}
                            />
                            {results.seasons.items.length > 0 ? (
                                <Stack spacing={1}>
                                    {results.seasons.items.map((season) => (
                                        <SearchResultCard
                                            key={season.id}
                                            data={season}
                                            type="season"
                                            onResultClick={onResultClick}
                                        />
                                    ))}
                                </Stack>
                            ) : (
                                <NoSectionResults section="Seasons" />
                            )}
                        </Box>
                    )}
                    {shouldShowSection("seasons") && shouldShowSection("episodes") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("episodes") && (
                        <Box>
                            <SectionTitle
                                title="Episodes"
                                shownCount={results.episodes.items.length}
                                totalCount={results.episodes.total}
                            />
                            {results.episodes.items.length > 0 ? (
                                <Stack spacing={1}>
                                    {results.episodes.items.map((episode) => (
                                        <SearchResultCard
                                            key={episode.id}
                                            data={episode}
                                            type="episode"
                                            onResultClick={onResultClick}
                                        />
                                    ))}
                                </Stack>
                            ) : (
                                <NoSectionResults section="Episodes" />
                            )}
                        </Box>
                    )}
                    {shouldShowSection("episodes") && shouldShowSection("users") && (
                        <Divider sx={{ my: 1, width: "100%" }} />
                    )}
                    {shouldShowSection("users") && (
                        <Box>
                            <SectionTitle
                                title="Users"
                                shownCount={results.users.items.length}
                                totalCount={results.users.total}
                            />
                            {results.users.items.length > 0 ? (
                                <Stack spacing={1}>
                                    {results.users.items.map((user) => (
                                        <SearchResultCard
                                            key={user.id}
                                            data={user}
                                            type="user"
                                            onResultClick={onResultClick}
                                        />
                                    ))}
                                </Stack>
                            ) : (
                                <NoSectionResults section="Users" />
                            )}
                        </Box>
                    )}
                    {hasAnyResults && (
                        <Box
                            sx={{
                                mt: 2,
                                pt: 2,
                                borderTop: 1,
                                borderColor: "divider",
                                textAlign: "center",
                            }}
                        >
                            <Button
                                onClick={() => {
                                    onShowMore();
                                    onClose();
                                }}
                                variant="text"
                                endIcon={<ArrowForward />}
                                sx={{
                                    textTransform: "none",
                                    color: theme.vars.palette.primary.main,
                                }}
                            >
                                {`${getFilterSpecificResults()} for "${searchTerm}"`}
                            </Button>
                        </Box>
                    )}
                </Stack>
            )}
        </Box>
    );
};

export default SearchAutocomplete;


================================================
File: src/components/root/searchField/SearchField.tsx
================================================
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { TextField, InputAdornment, useTheme, IconButton, Box, ClickAwayListener } from "@mui/material";
import { Clear, Search } from "@mui/icons-material";
import SearchAutocomplete from "./SearchAutocomplete";
import { useDebounce } from "@/hooks/useDebounce";
import { showToast } from "@/utils/helpers/toast";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { Movie, Serie, Actor, Crew, Season, Episode, User } from "@prisma/client";
import { useQueryState } from "nuqs";
import { useRouter } from "next/navigation";

interface SearchResults {
    movies: { items: Movie[]; total: number };
    series: { items: Serie[]; total: number };
    actors: { items: Actor[]; total: number };
    crews: { items: Crew[]; total: number };
    seasons: { items: Season[]; total: number };
    episodes: { items: Episode[]; total: number };
    users: { items: User[]; total: number };
}

const emptyResults = {
    movies: { items: [], total: 0 },
    series: { items: [], total: 0 },
    actors: { items: [], total: 0 },
    crews: { items: [], total: 0 },
    seasons: { items: [], total: 0 },
    episodes: { items: [], total: 0 },
    users: { items: [], total: 0 },
};

const filters = [
    { label: "All", value: "all" },
    { label: "Movies", value: "movies" },
    { label: "Series", value: "series" },
    { label: "Actors", value: "actors" },
    { label: "Crew", value: "crew" },
    { label: "Seasons", value: "seasons" },
    { label: "Episodes", value: "episodes" },
    { label: "Users", value: "users" },
];

const SearchField = () => {
    const router = useRouter();

    const [filtersSearch, setFiltersSearch] = useQueryState("filters", {
        defaultValue: "all",
        parse: (value) => value || "all",
        history: "push",
        shallow: false,
    });

    const getInitialFilters = () => {
        const urlFilters = filtersSearch?.split(",") || [];
        return urlFilters.length > 0 ? urlFilters : ["all"];
    };

    const [term, setTerm] = useQueryState("term", {
        defaultValue: "",
        parse: (value) => value || "",
        shallow: false,
    });

    const [inputValue, setInputValue] = useState(term);
    const [selectedFilters, setSelectedFilters] = useState<string[]>(getInitialFilters());
    const [loading, setLoading] = useState(false);
    const [showResults, setShowResults] = useState(false);
    const [results, setResults] = useState<SearchResults>(emptyResults);

    const debouncedSearch = useDebounce(inputValue, 50);
    const theme = useTheme();

    const handleSearch = () => {
        if (inputValue) {
            router.push(`/search?term=${encodeURIComponent(inputValue)}&filters=${selectedFilters.join(",")}`);
        } else {
            router.push("/search");
        }

        setShowResults(false);
    };

    const handleClear = () => {
        setInputValue("");
        setResults(emptyResults);
        setLoading(false);
        setShowResults(true);
        setSelectedFilters(["all"]);
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        handleSearch();
    };

    const handleFilterChange = (filter: string) => {
        if (filter === "all") {
            setSelectedFilters(["all"]);
            return;
        }

        const newFilters = selectedFilters.filter((f) => f !== "all");

        if (selectedFilters.includes(filter)) {
            const updatedFilters = newFilters.filter((f) => f !== filter);

            // If no filters are selected, default to "all"
            setSelectedFilters(updatedFilters.length === 0 ? ["all"] : updatedFilters);
        } else {
            // Checking if adding this filter would make all filters selected
            const potentialFilters = [...newFilters, filter];
            const allFiltersExceptAll = filters.filter((f) => f.value !== "all").map((f) => f.value);

            if (potentialFilters.length === allFiltersExceptAll.length) {
                setSelectedFilters(["all"]);
            } else {
                setSelectedFilters(potentialFilters);
            }
        }
    };

    const handleShowMore = () => {
        handleSearch();
    };

    const fetchResults = useCallback(async () => {
        // No fetch if search term is empty or only whitespace
        if (!debouncedSearch?.trim()) {
            setResults(emptyResults);
            setLoading(false);
            return;
        }

        setLoading(true);

        try {
            const response = await fetch(
                `/api/search/all?term=${encodeURIComponent(debouncedSearch.trim())}&filters=${selectedFilters.join(",")}`,
                {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json",
                    },
                },
            );

            if (!response.ok) {
                showToast("error", "Failed to fetch search results");
                return;
            }

            const data = await response.json();

            setResults({
                movies: data.movies || { items: [], total: 0 },
                series: data.series || { items: [], total: 0 },
                actors: data.actors || { items: [], total: 0 },
                crews: data.crews || { items: [], total: 0 },
                seasons: data.seasons || { items: [], total: 0 },
                episodes: data.episodes || { items: [], total: 0 },
                users: data.users || { items: [], total: 0 },
            });
        } catch (error) {
            console.error("Error fetching search results:", error);
            showToast("error", "Failed to fetch search results. Please try again later.");
        } finally {
            setLoading(false);
        }
    }, [debouncedSearch, selectedFilters]);

    useEffect(() => {
        fetchResults();
    }, [fetchResults]);

    // Updated selected filters when URL params change
    useEffect(() => {
        const urlFilters = filtersSearch?.split(",") || [];

        if (urlFilters.length > 0) {
            setSelectedFilters(urlFilters);
        }
    }, [filtersSearch]);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        setInputValue(value);

        // Showing results panel even if empty
        setShowResults(true);

        // Only setting loading if we have a non-empty, non-whitespace search term
        if (value.trim()) {
            setLoading(true);
        } else {
            setLoading(false);
            setResults(emptyResults);
        }
    };

    const handleFocus = () => {
        setShowResults(true);

        // Only fetching if there's a valid search term
        if (inputValue.trim()) {
            fetchResults();
        }
    };

    const handleClose = () => {
        setShowResults(false);
    };

    const handleReset = () => {
        setInputValue("");
        setResults(emptyResults);
        setShowResults(false);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === "Enter") {
            handleSearch();
            handleClose();
        }
    };

    return (
        <ClickAwayListener onClickAway={handleClose}>
            <Box sx={{ position: "relative", width: "100%" }}>
                <form onSubmit={handleSubmit} style={{ display: "flex" }}>
                    <TextField
                        placeholder="Search for anything..."
                        size="small"
                        value={inputValue}
                        onChange={handleInputChange}
                        onFocus={handleFocus}
                        onKeyDown={handleKeyDown}
                        sx={{
                            width: "100%",
                            "& .MuiInputBase-root": {
                                minWidth: 300,
                                transition: "width 0.2s",
                                width: showResults ? "100%" : 300,
                            },
                        }}
                        slotProps={{
                            input: {
                                sx: { py: 0.5, color: theme.vars.palette.primary.main },
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <IconButton type="submit" size="small" aria-label="search">
                                            <Search />
                                        </IconButton>
                                    </InputAdornment>
                                ),
                                endAdornment: inputValue && (
                                    <InputAdornment position="end">
                                        <Clear
                                            sx={{ cursor: "pointer" }}
                                            onClick={handleClear}
                                            aria-label="clear search"
                                        />
                                    </InputAdornment>
                                ),
                            },
                        }}
                    />
                </form>
                {showResults && (
                    <SearchAutocomplete
                        loading={loading}
                        results={results}
                        selectedFilters={selectedFilters}
                        onFilterChange={handleFilterChange}
                        searchTerm={inputValue}
                        onShowMore={handleShowMore}
                        onClose={handleClose}
                        onResultClick={handleReset}
                        showInitialState={!inputValue}
                    />
                )}
            </Box>
        </ClickAwayListener>
    );
};

export default SearchField;


================================================
File: src/components/root/searchField/SearchResultCard.tsx
================================================
"use client";

import React from "react";
import { Box, Typography, useTheme } from "@mui/material";
import Image from "next/image";
import Link from "next/link";
import { useParams } from "next/navigation";

type ResultType = "movie" | "serie" | "season" | "episode" | "actor" | "crew" | "user";

type PathType = "movies" | "actors" | "crew" | null;

interface BaseResultData {
    id: number;
    photoSrcProd?: string;
    description?: string;
    dateAired?: string;
}

interface MediaResultData extends BaseResultData {
    title: string;
}

interface PersonResultData extends BaseResultData {
    fullname: string;
    debut: string;
}

interface UserResultData extends BaseResultData {
    userName: string;
    bio?: string;
}

type ResultData = MediaResultData | PersonResultData | UserResultData;

interface SearchResultCardProps {
    data: ResultData;
    type: ResultType;
    path?: PathType;
    onResultClick: () => void;
}

const SearchResultCard = ({ data, type, path, onResultClick }: SearchResultCardProps) => {
    const theme = useTheme();
    const params = useParams();

    const getPath = (): string => {
        const formatTitle = (title: string) => encodeURIComponent(title.split(" ").join("-"));

        switch (type) {
            case "serie":
                return `/series/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            case "movie":
                return `/movies/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            case "actor":
                if (path === "movies") {
                    return `/movies/${data.id}/${formatTitle((data as MediaResultData).title)}`;
                } else if (path === "actors") {
                    return `/actors/${data.id}/${formatTitle((data as PersonResultData).fullname)}`;
                }

                return `/series/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            case "crew":
                if (path === "movies") {
                    return `/movies/${data.id}/${formatTitle((data as MediaResultData).title)}`;
                } else if (path === "crew") {
                    return `/crew/${data.id}/${formatTitle((data as PersonResultData).fullname)}`;
                }

                return `/series/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            case "season": {
                const serieId = typeof params.serieId === "string" ? params.serieId : "";
                const serieTitle = typeof params.serieTitle === "string" ? formatTitle(params.serieTitle) : "";
                return `/series/${serieId}/${serieTitle}/seasons/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            }

            case "episode": {
                const serieId = typeof params.serieId === "string" ? params.serieId : "";
                const serieTitle = typeof params.serieTitle === "string" ? formatTitle(params.serieTitle) : "";
                const seasonId = typeof params.seasonId === "string" ? params.seasonId : "";
                const seasonTitle = typeof params.seasonTitle === "string" ? formatTitle(params.seasonTitle) : "";
                return `/series/${serieId}/${serieTitle}/seasons/${seasonId}/${seasonTitle}/episodes/${data.id}/${formatTitle((data as MediaResultData).title)}`;
            }

            case "user":
                return `/users/${data.id}/${formatTitle((data as UserResultData).userName)}`;
            default:
                return "/";
        }
    };

    const getDisplayTitle = () => {
        if (type === "actor" || type === "crew") {
            const personData = data as PersonResultData;
            return `${personData.fullname}${personData.debut ? ` (${personData.debut})` : ""}`;
        }

        if (type === "user") {
            return (data as UserResultData).userName;
        }

        const mediaData = data as MediaResultData;
        return `${mediaData.title}${mediaData.dateAired ? ` (${mediaData.dateAired.split("/")[2]})` : ""}`;
    };

    const getDescription = () => {
        if (type === "user") {
            return (data as UserResultData).bio;
        }

        return data.description;
    };

    return (
        <Link href={getPath()} style={{ textDecoration: "none" }} onClick={onResultClick}>
            <Box
                sx={{
                    display: "flex",
                    gap: 1.5,
                    p: 1.5,
                    borderRadius: 1,
                    transition: "all 0.2s",
                    "&:hover": {
                        bgcolor: theme.vars.palette.action.hover,
                    },
                }}
            >
                <Box
                    sx={{
                        position: "relative",
                        width: 45,
                        height: 65,
                        flexShrink: 0,
                        borderRadius: 0.5,
                        overflow: "hidden",
                    }}
                >
                    <Image
                        src={data.photoSrcProd || "/images/placeholder.jpg"}
                        alt={data.description || "No description available"}
                        fill
                        sizes="45px"
                        style={{ objectFit: "cover" }}
                        priority
                    />
                </Box>
                <Box sx={{ overflow: "hidden" }}>
                    <Typography
                        variant="subtitle2"
                        sx={{
                            fontWeight: 600,
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                            color: theme.vars.palette.text.primary,
                            mb: 0.5,
                        }}
                    >
                        {getDisplayTitle()}
                    </Typography>
                    {getDescription() && (
                        <Typography
                            variant="caption"
                            sx={{
                                color: theme.vars.palette.text.secondary,
                                display: "-webkit-box",
                                WebkitLineClamp: 2,
                                WebkitBoxOrient: "vertical",
                                overflow: "hidden",
                                lineHeight: 1.2,
                            }}
                        >
                            {getDescription()}
                        </Typography>
                    )}
                </Box>
            </Box>
        </Link>
    );
};

export default SearchResultCard;


================================================
File: src/components/root/sortSelect/SortSelect.tsx
================================================
"use client";

import React from "react";
import { Box, Select, MenuItem, SvgIcon, Typography, FormControl, InputLabel } from "@mui/material";
import SwapVertIcon from "@mui/icons-material/SwapVert";
import { useSorting } from "@/hooks/useSorting";
import { getSortOptions } from "@/components/root/sortSelect/getSortingOptions";

interface ISortSelectProps {
    sortBy: string;
    ascOrDesc: string;
    type: string;
    dataType: string;
}

export default function SortSelect({ sortBy, ascOrDesc, type, dataType }: ISortSelectProps) {
    const handleChangeSorting = useSorting(dataType);
    const sortOptions = getSortOptions(type, dataType);

    const getDefaultSortByField = (typeEntity: string): string => {
        switch (typeEntity) {
            case "movies":
            case "episodes":
            case "seasons":
            case "series":
                return "title";
            case "actors":
            case "crew":
                return "fullname";
            case "users":
                return "userName";
            case "genres":
                return "name";
            case "details":
                return "createdAt";
            default:
                return "createdAt";
        }
    };

    const defaultValue = getDefaultSortByField(dataType);

    const handleSortTypeChange = (event: any) => {
        const newSortBy = event.target.value as string;
        handleChangeSorting({ sortBy: newSortBy, ascOrDesc: ascOrDesc || "asc" });
    };

    const handleOrderChange = (event: any) => {
        const newAscOrDesc = event.target.value as string;
        handleChangeSorting({ sortBy, ascOrDesc: newAscOrDesc });
    };

    return (
        <Box sx={{ display: "flex", alignItems: "start", gap: 2 }}>
            <FormControl>
                <InputLabel
                    id="sort-by-label"
                    sx={{
                        fontSize: 20,
                    }}
                >
                    Sort By
                </InputLabel>
                <Select
                    labelId="sort-by-label"
                    value={sortBy || defaultValue}
                    sx={{
                        mt: 2,
                    }}
                    onChange={handleSortTypeChange}
                    displayEmpty
                    renderValue={(value) => (
                        <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                            <SvgIcon fontSize="small">
                                <SwapVertIcon />
                            </SvgIcon>
                            <Typography fontSize="15px">
                                {sortOptions.find((option) => option.value === value)?.label}
                            </Typography>
                        </Box>
                    )}
                >
                    {sortOptions.map((option) => (
                        <MenuItem key={option.value} value={option.value}>
                            {option.label}
                        </MenuItem>
                    ))}
                </Select>
            </FormControl>
            <FormControl>
                <InputLabel
                    id="ordering-label"
                    sx={{
                        fontSize: 20,
                    }}
                >
                    Ordering
                </InputLabel>
                <Select
                    labelId="ordering-label"
                    value={ascOrDesc || "asc"}
                    onChange={handleOrderChange}
                    sx={{
                        mt: 2,
                    }}
                >
                    <MenuItem value="asc">Ascending</MenuItem>
                    <MenuItem value="desc">Descending</MenuItem>
                </Select>
            </FormControl>
        </Box>
    );
}


================================================
File: src/components/root/sortSelect/getSortingOptions.tsx
================================================
interface SortOption {
    value: string;
    label: string;
}

export const getSortOptions = (type: string, dataType: string): SortOption[] => {
    if (dataType === "actors" || dataType === "crew") {
        return [
            { value: "fullname", label: "Full Name" },
            { value: "debut", label: "Debut" },
        ];
    }

    if (dataType === "users") {
        return [
            { value: "userName", label: "Username" },
            { value: "email", label: "Email" },
        ];
    }

    if (dataType === "seasons") {
        return [
            { value: "title", label: "Title" },
            { value: "ratingImdb", label: "Rating Imdb" },
        ];
    }

    if (dataType === "movies" || dataType === "series" || dataType === "episodes") {
        return [
            { value: "title", label: "Title" },
            { value: "ratingImdb", label: "Rating Imdb" },
            { value: "duration", label: "Duration" },
        ];
    }

    if (type === "list") {
        const listOptions: SortOption[] = [];
        return listOptions;
    } else {
        return [
            { value: "createdAt", label: "Created At" },
            { value: "rating", label: "Rating" },
        ];
    }
};


================================================
File: src/components/root/tabPanel/TabPanel.tsx
================================================
"use client";

import { Box } from "@mui/material";
import { motion } from "framer-motion";

interface ITabPanelProps {
    index: number;
    value: number;
    children: React.ReactNode;
}

export default function TabPanel(props: ITabPanelProps) {
    const { children, value, index } = props;

    return (
        <Box
            role="tabpanel"
            hidden={value !== index}
            id={`tabpanel-${index}`}
            aria-labelledby={`tab-${index}`}
            sx={{
                width: "100%",
            }}
        >
            {value === index && (
                <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -10 }}
                    transition={{ duration: 0.2 }}
                >
                    <Box>{children}</Box>
                </motion.div>
            )}
        </Box>
    );
}


================================================
File: src/components/root/textEditor/TextEditor.tsx
================================================
"use client";

import React, { useEffect } from "react";
import { useTheme } from "@mui/material/styles";
import Rating from "@mui/material/Rating";
import Box from "@mui/material/Box";
import { Typography } from "@mui/material";
// import { Quill } from "react-quill-new";
// import { IS_BROWSER } from "@/utils/helpers/utils";
import dynamic from "next/dynamic";
const ReactQuill = dynamic(() => import("react-quill-new"), { ssr: false });
// const QuillResizeImage = dynamic(() => import("quill-resize-image"), { ssr: false });
// import QuillResizeImage from "quill-resize-image";
import "react-quill-new/dist/quill.snow.css";

interface ITextEditorProps {
    value: string;
    ref?: any;
    rating?: number | null;
    setRating?: React.Dispatch<React.SetStateAction<number | null>>;
    isDisabled?: boolean;
    type: string;
    onChange: (value: string) => void;
}

const modules = {
    toolbar: [
        [{ header: [1, 2, 3, 4, 5, 6, false] }],
        [{ font: [] }],
        [{ size: ["small", false, "large", "huge"] }],
        ["bold", "italic", "underline", "strike"],
        [{ color: [] }, { background: [] }],
        [{ align: ["", "center", "right", "justify"] }],
        [{ list: "ordered" }, { list: "bullet" }],
        [{ indent: "-1" }, { indent: "+1" }],
        [{ script: "sub" }, { script: "super" }],
        ["blockquote", "code-block"],
        ["link", "image", "video"],
        [{ direction: "rtl" }],
    ],
    // resize: {
    //     locale: {},
    // },
    clipboard: {
        matchVisual: false,
    },
    keyboard: {
        bindings: {
            tab: false,
            "list autofill": true,
        },
    },
};

const formats = [
    "header",
    "font",
    "size",
    "bold",
    "italic",
    "underline",
    "strike",
    "color",
    "background",
    "align",
    "list",
    "indent",
    "script",
    "blockquote",
    "code-block",
    "link",
    "image",
    "video",
    "direction",
];

// if (IS_BROWSER) {
//     Quill.register("modules/resize", QuillResizeImage);
// }

const TextEditor: React.FC<ITextEditorProps> = ({ value, onChange, rating, setRating, ref, isDisabled, type }) => {
    const theme = useTheme();

    useEffect(() => {
        const resizeImages = () => {
            const quillEditor = ref?.current?.getEditor?.();

            if (quillEditor) {
                const images = quillEditor.container.querySelectorAll("img");

                images.forEach((img: HTMLImageElement) => {
                    img.style.maxWidth = "50%";
                    img.style.maxHeight = "auto";
                });
            }
        };

        const editorInstance = ref?.current?.getEditor?.();

        if (editorInstance) {
            resizeImages();
            editorInstance.on("text-change", resizeImages);
        }

        return () => {
            if (editorInstance) {
                editorInstance.off("text-change", resizeImages);
            }
        };
    }, [ref, value]);

    return (
        <Box sx={{ opacity: isDisabled ? 0.7 : 1, pointerEvents: isDisabled ? "none" : "auto" }}>
            <Box
                sx={{
                    ".ql-toolbar": {
                        backgroundColor: theme.vars.palette.secondary.light,
                        border: `1px solid ${theme.vars.palette.primary.light}`,
                        borderTopLeftRadius: "8px",
                        borderTopRightRadius: "8px",
                        "& .ql-stroke": {
                            stroke: theme.vars.palette.primary.main,
                        },
                        "& .ql-fill": {
                            fill: theme.vars.palette.primary.main,
                        },
                        "& .ql-picker": {
                            color: theme.vars.palette.primary.main,
                        },
                        "& .ql-picker-options": {
                            backgroundColor: theme.vars.palette.secondary.light,
                            border: `1px solid ${theme.vars.palette.primary.light}`,
                        },
                        "& button:hover .ql-stroke": {
                            stroke: theme.vars.palette.blue.main,
                        },
                        "& button:hover .ql-fill": {
                            fill: theme.vars.palette.blue.main,
                        },
                        "& .ql-picker-label:hover": {
                            color: theme.vars.palette.blue.main,
                        },
                        "& .ql-color .ql-picker-options": {
                            padding: "5px",
                            width: "152px",
                        },
                        "& .ql-color .ql-picker-item": {
                            width: "16px",
                            height: "16px",
                            margin: "2px",
                        },
                        "& .ql-background .ql-picker-options": {
                            padding: "5px",
                            width: "152px",
                        },
                        "& .ql-background .ql-picker-item": {
                            width: "16px",
                            height: "16px",
                            margin: "2px",
                        },
                        "& .ql-size .ql-picker-options": {
                            minWidth: "100px",
                        },
                        "& .ql-align .ql-picker-options": {
                            minWidth: "100px",
                        },
                    },
                    ".ql-container": {
                        backgroundColor: theme.vars.palette.secondary.light,
                        border: `1px solid ${theme.vars.palette.primary.light}`,
                        borderBottomLeftRadius: "8px",
                        borderBottomRightRadius: "8px",
                        fontSize: "16px",
                        minHeight: "200px",
                    },
                    ".ql-editor": {
                        color: theme.vars.palette.primary.main,
                        padding: "20px",
                        "&.ql-blank::before": {
                            color: theme.vars.palette.primary.main,
                            opacity: 0.6,
                            fontStyle: "normal",
                            fontSize: "16px",
                            left: "20px",
                            right: "20px",
                        },
                        "p, h1, h2, h3": {
                            color: theme.vars.palette.primary.main,
                            margin: "0 0 0.5em 0",
                        },
                        h1: { fontSize: "2em" },
                        h2: { fontSize: "1.5em" },
                        h3: { fontSize: "1.17em" },
                        a: {
                            color: theme.vars.palette.blue.main,
                            textDecoration: "underline",
                        },
                        blockquote: {
                            borderLeft: `4px solid ${theme.vars.palette.primary.main}`,
                            color: theme.vars.palette.primary.main,
                            opacity: 0.9,
                            margin: "0.5em 0",
                            padding: "0.5em 1em",
                        },
                        ul: {
                            color: theme.vars.palette.primary.main,
                        },
                        ol: {
                            color: theme.vars.palette.primary.main,
                        },
                        "& pre.ql-syntax": {
                            backgroundColor: theme.vars.palette.secondary.dark,
                            color: theme.vars.palette.primary.light,
                            padding: "1em",
                            borderRadius: "4px",
                            fontFamily: "monospace",
                            fontSize: "14px",
                            overflow: "auto",
                        },
                        "& sup": {
                            fontSize: "0.75em",
                            verticalAlign: "super",
                        },
                        "& sub": {
                            fontSize: "0.75em",
                            verticalAlign: "sub",
                        },
                        "&[dir='rtl']": {
                            textAlign: "right",
                        },
                        "& .ql-indent-1": { paddingLeft: "3em" },
                        "& .ql-indent-2": { paddingLeft: "6em" },
                        "& .ql-indent-3": { paddingLeft: "9em" },
                        "& .ql-indent-4": { paddingLeft: "12em" },
                        "& .ql-indent-5": { paddingLeft: "15em" },
                        "& .ql-align-center": { textAlign: "center" },
                        "& .ql-align-right": { textAlign: "right" },
                        "& .ql-align-justify": { textAlign: "justify" },
                        wordWrap: "break-word",
                        overflowWrap: "break-word",
                        minWidth: "100%",
                        whiteSpace: "pre-wrap",
                    },
                }}
            >
                <ReactQuill
                    theme="snow"
                    value={value}
                    onChange={onChange}
                    modules={modules}
                    formats={formats}
                    readOnly={isDisabled}
                    // @ts-expect-error ref
                    ref={ref!}
                />
            </Box>
            {type === "review" && (
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "flex-start",
                        mt: 2,
                    }}
                >
                    <Rating
                        name="review-rating"
                        value={rating}
                        onChange={(event, newValue) => {
                            setRating!(newValue);
                        }}
                        size="medium"
                        max={10}
                        precision={0.5}
                        readOnly={isDisabled}
                    />
                    <Typography
                        variant="body2"
                        fontSize={16}
                        fontWeight={700}
                        sx={{
                            ml: 1,
                            color: theme.vars.palette.primary.main,
                        }}
                    >
                        {rating?.toFixed(1)}
                    </Typography>
                </Box>
            )}
        </Box>
    );
};

export default TextEditor;


================================================
File: src/components/root/textEditorButtons/TextEditorButtons.tsx
================================================
"use client";

import { WarningOutlined, CheckOutlined, SendOutlined, SaveOutlined, CancelOutlined } from "@mui/icons-material";
import { Box, Button, Typography, useTheme, CircularProgress } from "@mui/material";
import * as CONSTANTS from "@/constants/Constants";
import { useModal } from "@/providers/ModalProvider";
import type {} from "@mui/material/themeCssVarsAugmentation";
import { useTransition } from "react";

interface ITextEditorButtonsProps {
    isEditMode: boolean;
    setOpen: React.Dispatch<React.SetStateAction<boolean>>;
    setIsEditMode: React.Dispatch<React.SetStateAction<boolean>>;
    setReview: React.Dispatch<React.SetStateAction<string>>;
    setIsSubmitting: React.Dispatch<React.SetStateAction<boolean>>;
    onSubmitReview(): Promise<void>;
    handleFocusReview: () => void;
    onSubmitUpdateReview(): Promise<void>;
}

export function TextEditorButtons({
    isEditMode,
    onSubmitReview,
    setOpen,
    setIsEditMode,
    setReview,
    handleFocusReview,
    onSubmitUpdateReview,
    setIsSubmitting,
}: ITextEditorButtonsProps) {
    const { openModal } = useModal();
    const theme = useTheme();

    const [isPending, startTransition] = useTransition();

    const handleSubmit = () => {
        if (isPending) return;

        setIsSubmitting(true);

        startTransition(async () => {
            try {
                await onSubmitReview();
            } finally {
                setIsSubmitting(false);
            }
        });
    };

    const handleUpdate = () => {
        if (isPending) return;

        setIsSubmitting(true);

        startTransition(async () => {
            try {
                await onSubmitUpdateReview();
            } finally {
                setIsSubmitting(false);
            }
        });
    };

    return (
        <>
            {!isEditMode ? (
                <Box display={"flex"} justifyContent={"end"} marginTop={2}>
                    <Button
                        onClick={handleSubmit}
                        variant="contained"
                        disabled={isPending}
                        startIcon={isPending ? <CircularProgress size={20} color="inherit" /> : <SendOutlined />}
                        sx={{
                            display: "flex",
                            placeSelf: "end",
                            fontSize: 18,
                            fontWeight: 900,
                            padding: 1.5,
                            textTransform: "capitalize",
                            border: "none",
                            backgroundColor: theme.vars.palette.green.light,
                            color: theme.vars.palette.primary.dark,
                            "&:hover": {
                                backgroundColor: theme.vars.palette.green.main,
                                color: theme.vars.palette.greyAccent.main,
                            },
                            "&:disabled": {
                                backgroundColor: theme.vars.palette.green.light,
                                opacity: 0.7,
                            },
                            minWidth: 150,
                        }}
                    >
                        <Typography
                            component={"span"}
                            sx={{
                                color: theme.vars.palette.primary.dark,
                            }}
                        >
                            {isPending ? "Submitting..." : "Submit Review"}
                        </Typography>
                    </Button>
                </Box>
            ) : (
                <Box
                    display={"flex"}
                    flexDirection={"row"}
                    columnGap={1}
                    justifyContent={"end"}
                    alignItems={"center"}
                    marginTop={2}
                >
                    <Button
                        onClick={() => {
                            openModal({
                                onClose: () => setOpen(false),
                                title: "Discard Changes",
                                actions: [
                                    {
                                        label: CONSTANTS.MODAL__DELETE__NO,
                                        onClick: () => setOpen(false),
                                        color: "error",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#ff5252",
                                        },
                                        icon: <WarningOutlined />,
                                    },
                                    {
                                        label: CONSTANTS.MODAL__DELETE__YES,
                                        onClick: async () => {
                                            setIsEditMode(false);
                                            setReview("");
                                            handleFocusReview();
                                        },
                                        type: "submit",
                                        color: "success",
                                        variant: "contained",
                                        sx: {
                                            bgcolor: "#30969f",
                                        },
                                        icon: <CheckOutlined />,
                                    },
                                ],
                                subTitle: "Are you sure that you want to discard changes on this review ?",
                            });
                        }}
                        color="error"
                        variant="contained"
                        disabled={isPending}
                        startIcon={<CancelOutlined />}
                        sx={{
                            display: "flex",
                            placeSelf: "end",
                            fontSize: 18,
                            fontWeight: 900,
                            padding: 1.5,
                            textTransform: "capitalize",
                            "&:disabled": {
                                opacity: 0.7,
                            },
                        }}
                    >
                        <Typography component={"span"}>Discard Changes</Typography>
                    </Button>
                    <Button
                        onClick={handleUpdate}
                        color="success"
                        variant="contained"
                        disabled={isPending}
                        startIcon={isPending ? <CircularProgress size={20} color="inherit" /> : <SaveOutlined />}
                        sx={{
                            display: "flex",
                            placeSelf: "end",
                            fontSize: 18,
                            fontWeight: 900,
                            padding: 1.5,
                            textTransform: "capitalize",
                            "&:disabled": {
                                opacity: 0.7,
                            },
                            minWidth: 150,
                        }}
                    >
                        <Typography component={"span"}>{isPending ? "Saving..." : "Save Changes"}</Typography>
                    </Button>
                </Box>
            )}
        </>
    );
}

export default TextEditorButtons;


================================================
File: src/components/root/textEditorForm/TextEditorForm.tsx
================================================
"use client";

import { Box } from "@mui/material";
import TextEditor from "../textEditor/TextEditor";
import { TextEditorButtons } from "../textEditorButtons/TextEditorButtons";
import { useState } from "react";

interface ITextEditorFormProps {
    review: string;
    rating: number | null;
    isEditMode: boolean;
    textEditorRef: React.MutableRefObject<any>;
    setIsEditMode: React.Dispatch<React.SetStateAction<boolean>>;
    setRating: React.Dispatch<React.SetStateAction<number | null>>;
    setOpen: React.Dispatch<React.SetStateAction<boolean>>;
    setReview: React.Dispatch<React.SetStateAction<string>>;
    onSubmitReview(): Promise<void>;
    onSubmitUpdateReview(): Promise<void>;
    handleFocusReview: () => void;
}

export function TextEditorForm({
    review,
    setReview,
    textEditorRef,
    rating,
    setIsEditMode,
    onSubmitReview,
    handleFocusReview,
    setRating,
    isEditMode,
    setOpen,
    onSubmitUpdateReview,
}: ITextEditorFormProps) {
    const [isSubmitting, setIsSubmitting] = useState(false);

    return (
        <Box marginTop={4} px={4}>
            <Box marginBottom={1}>
                <TextEditor
                    value={review}
                    onChange={setReview}
                    ref={textEditorRef}
                    rating={rating}
                    setRating={setRating}
                    isDisabled={isSubmitting}
                    type="review"
                />
            </Box>
            <TextEditorButtons
                isEditMode={isEditMode}
                setOpen={setOpen}
                setIsEditMode={setIsEditMode}
                setReview={setReview}
                onSubmitReview={onSubmitReview}
                handleFocusReview={handleFocusReview}
                onSubmitUpdateReview={onSubmitUpdateReview}
                setIsSubmitting={setIsSubmitting}
            />
        </Box>
    );
}

export default TextEditorForm;


================================================
File: src/components/root/themeToggleButton/ThemeToggleButton.tsx
================================================
"use client";

import React, { useEffect, useState } from "react";
import { IconButton, useColorScheme } from "@mui/material";
import { DarkMode, LightMode } from "@mui/icons-material";

const SwitchThemeButton = () => {
    const { colorScheme, setColorScheme } = useColorScheme();
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
    }, []);

    function handleModeChange() {
        setColorScheme(colorScheme === "light" ? "dark" : "light");
    }

    if (!mounted) {
        return (
            <IconButton sx={{ visibility: "hidden" }}>
                <DarkMode />
            </IconButton>
        );
    }

    return (
        <IconButton
            onClick={handleModeChange}
            sx={{
                transition: "transform 0.3s ease-in-out",
                "&:hover": {
                    transform: "rotate(180deg)",
                },
            }}
        >
            {colorScheme === "dark" ? <LightMode /> : <DarkMode />}
        </IconButton>
    );
};

export default SwitchThemeButton;


================================================
File: src/constants/Constants.ts
================================================
export const LOGIN__SUCCESS = "You are logged in succesfully!";
export const LOGIN__FAILURE = "Credentials are wrong, either the email or the password!";

export const UPDATE__SUCCESS = "Record is updated succesfully!";
export const UPDATE__FAILURE = "Record is not updated succesfully!";

export const DELETE__SUCCESS = "Record is deleted succesfully!";
export const DELETE__FAILURE = "Record is not deleted succesfully!";

export const ADD__SUCCESS = "Record is created succesfully!";
export const ADD__FAILURE = "Record is not created succesfully!";

export const USER__ADD__TITLE = "User";
export const USER__ADD__SUBTITLE = "Add a User";

export const USER__EDIT__TITLE = "User";
export const USER__EDIT__SUBTITLE = "View and edit user details";

export const MOVIE__EDIT__TITLE = "Movie";
export const MOVIE__EDIT__SUBTITLE = "View and edit movie details";

export const MOVIE__ADD__TITLE = "Movie";
export const MOVIE__ADD__SUBTITLE = "Add a Movie";

export const SERIE__ADD__TITLE = "Serie";
export const SERIE__ADD__SUBTITLE = "Add a Serie";

export const GENRE__ADD__TITLE = "Genre";
export const GENRE__ADD__SUBTITLE = "Add a Genre";

export const GLOBAL__ERROR = "An error occurred:";

export const FORM__UPDATE__BUTTON = "Save";
export const FORM__DELETE__BUTTON = "Delete";
export const FORM__RESET__BUTTON = "Reset";
export const MODAL__DELETE__YES = "Yes";
export const MODAL__DELETE__NO = "No";


================================================
File: src/hooks/useDebounce.ts
================================================
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}


================================================
File: src/hooks/usePageDetailsData.ts
================================================
"use client";

import { useState, useRef } from "react";
import { useSession } from "next-auth/react";
import { useModal } from "@/providers/ModalProvider";

/* 
    This hook is used to store the data of the page details, because i use movie, serie, actor, season, episode, crew
    so i needed a custom hook to extract all those data
*/
export function usePageDetailsData() {
    const { data: session } = useSession();

    const [review, setReview] = useState<string>("");
    const [rating, setRating] = useState<number | null>(null);
    const [isEditMode, setIsEditMode] = useState<boolean>(false);
    const [open, setOpen] = useState<boolean>(false);
    const [openVotesModal, setIsOpenVotesModal] = useState(false);

    const { openModal } = useModal();
    const textEditorRef = useRef<any>(null);
    const reviewRef = useRef<any>(null);

    return {
        session,
        review,
        setReview,
        rating,
        setRating,
        isEditMode,
        setIsEditMode,
        open,
        setOpen,
        openVotesModal,
        setIsOpenVotesModal,
        openModal,
        textEditorRef,
        reviewRef,
    };
}


================================================
File: src/hooks/useSorting.ts
================================================
"use client";

import { useQueryState } from "nuqs";

type SortingOptions = {
    sortBy: string;
    ascOrDesc: string;
};

const getDefaultSortByField = (type: string): string => {
    switch (type) {
        case "movie":
        case "episode":
        case "season":
        case "serie":
            return "title";
        case "actor":
        case "crew":
            return "fullName";
        case "user":
            return "userName";
        case "genre":
            return "name";
        case "details":
            return "createdAt";
        default:
            return "createdAt";
    }
};

export function useSorting(type: string) {
    const defaultSortBy = getDefaultSortByField(type);

    const [typeSortBy, setTypeSortBy] = useQueryState(`${type}SortBy`, {
        defaultValue: defaultSortBy,
        parse: (value) => value || defaultSortBy,
        shallow: false,
    });

    const [sortByDefault, setSortByDefault] = useQueryState("sortBy", {
        defaultValue: defaultSortBy,
        parse: (value) => value || defaultSortBy,
        shallow: false,
    });

    const [typeAscOrDesc, setTypeAscOrDesc] = useQueryState(`${type}AscOrDesc`, {
        defaultValue: "asc",
        parse: (value) => value || "asc",
        shallow: false,
    });

    const [ascOrDescDefault, setAscOrDescDefault] = useQueryState("ascOrDesc", {
        defaultValue: "asc",
        parse: (value) => value || "asc",
        shallow: false,
    });

    function handleChangeSorting({ sortBy, ascOrDesc }: SortingOptions) {
        if (!sortBy) {
            if (type !== "details") {
                setTypeSortBy(null);
                setTypeAscOrDesc(null);
            } else {
                setSortByDefault(null);
                setAscOrDescDefault(null);
            }
        } else {
            if (type !== "details") {
                setTypeSortBy(sortBy);
                setTypeAscOrDesc(ascOrDesc);
            } else {
                setSortByDefault(sortBy);
                setAscOrDescDefault(ascOrDesc);
            }
        }
    }

    return handleChangeSorting;
}


================================================
File: src/layouts/AdminLayout.tsx
================================================
"use client";

import React from "react";
import { Box, Grid2 as Grid } from "@mui/material";
import Sidebar from "@/components/admin/sidebar/Sidebar";
import TopBar from "@/components/admin/topBar/TopBar";
import { SidebarItems } from "@/components/admin/sidebar/components/SidebarItems";
import { useStore } from "@/store/store";
import { NuqsAdapter } from "nuqs/adapters/next/app";

interface IAdminLayoutProps {
    children: React.ReactNode;
}

export default function AdminLayout({ children }: Readonly<IAdminLayoutProps>) {
    const { isOpenSidebarAdmin } = useStore();

    return (
        <Grid container component={"main"}>
            {isOpenSidebarAdmin && (
                <Grid size={{ xs: 12, md: 2 }}>
                    <Sidebar sidebarItems={SidebarItems} />
                </Grid>
            )}
            <Grid size={{ xs: 12, md: isOpenSidebarAdmin ? 10 : 12 }}>
                <TopBar />
                <Box
                    sx={{
                        ml: 4,
                    }}
                >
                    <NuqsAdapter>{children}</NuqsAdapter>
                </Box>
            </Grid>
        </Grid>
    );
}


================================================
File: src/layouts/MainLayout.tsx
================================================
import React from "react";
import { Grid2 as Grid } from "@mui/material";
import ScrollToTop from "@/components/root/scrollToTop/ScrollToTop";
import Header from "@/components/root/header/Header";
import Footer from "@/components/root/footer/Footer";
import { NuqsAdapter } from "nuqs/adapters/next/app";

interface IMainLayoutProps {
    children: React.ReactNode;
}

export default function MainLayout({ children }: Readonly<IMainLayoutProps>) {
    return (
        <Grid container>
            <Grid size={{ xs: 12 }}>
                <NuqsAdapter>
                    <Header />
                    <main style={{ paddingTop: 50, paddingBottom: 22 }}>{children}</main>
                    <ScrollToTop />
                    <Footer />
                </NuqsAdapter>
            </Grid>
        </Grid>
    );
}


================================================
File: src/providers/AuthProvider.tsx
================================================
"use client";

import { SessionProvider } from "next-auth/react";

interface IAuthProviderProps {
    children?: React.ReactNode;
}

export const AuthProvider = ({ children }: IAuthProviderProps) => {
    return <SessionProvider>{children}</SessionProvider>;
};


================================================
File: src/providers/ModalProvider.tsx
================================================
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import Modal from "@/components/admin/modal/Modal";

interface IModalProviderProps {
    children: ReactNode;
}

type ModalContextType = {
    modalProps: any;
    openModal: (props: any) => void;
    closeModal: () => void;
};

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export const useModal = () => {
    const context = useContext(ModalContext);

    if (!context) {
        throw new Error("useModal must be used within a ModalProvider");
    }

    return context;
};

export const ModalProvider: React.FC<IModalProviderProps> = ({ children }) => {
    const [modalProps, setModalProps] = useState<any | null>(null);

    const openModal = (props: any) => {
        setModalProps(props);
    };

    const closeModal = () => {
        setModalProps(null);
    };

    return (
        <ModalContext.Provider value={{ modalProps, openModal, closeModal }}>
            {children}
            {modalProps && <Modal {...modalProps} onClose={closeModal} />}
        </ModalContext.Provider>
    );
};


================================================
File: src/providers/RightPanelProvider.tsx
================================================
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import RightPanel from "@/components/admin/rightPanel/RightPanel";

type RightPanelContextType = {
    rightPanelProps: any;
    openRightPanel: (props: any) => void;
    closeRightPanel: () => void;
};

interface IRightPanelProviderProps {
    children: ReactNode;
}

const RightPanelContext = createContext<RightPanelContextType | undefined>(undefined);

export const useRightPanel = () => {
    const context = useContext(RightPanelContext);

    if (!context) {
        throw new Error("useRightPanel must be used within a RightPanelProvider");
    }

    return context;
};

export const RightPanelProvider: React.FC<IRightPanelProviderProps> = ({ children }) => {
    const [rightPanelProps, setRightPanelProps] = useState<any | null>(null);

    const openRightPanel = (props: any) => {
        setRightPanelProps(props);
    };

    const closeRightPanel = () => {
        setRightPanelProps(null);
    };

    return (
        <RightPanelContext.Provider value={{ rightPanelProps, openRightPanel, closeRightPanel }}>
            {children}
            {rightPanelProps && <RightPanel {...rightPanelProps} onClose={closeRightPanel} />}
        </RightPanelContext.Provider>
    );
};


================================================
File: src/providers/ThemeProvider.tsx
================================================
import React, { ReactNode } from "react";
import { ThemeProvider } from "@mui/material/styles";
import { AppRouterCacheProvider } from "@mui/material-nextjs/v14-appRouter";
import CssBaseline from "@mui/material/CssBaseline";
import { theme } from "@/utils/theme/theme";

interface IMUIThemeProviderProps {
    children: ReactNode;
}

export function MUIThemeProvider({ children }: IMUIThemeProviderProps) {
    return (
        <AppRouterCacheProvider>
            <ThemeProvider theme={theme} disableTransitionOnChange defaultMode="dark">
                <CssBaseline />
                {children}
            </ThemeProvider>
        </AppRouterCacheProvider>
    );
}


================================================
File: src/providers/ToastProvider.tsx
================================================
"use client";

import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

interface IToastProviderProps {
    children: React.ReactNode;
}

const ToastProvider = ({ children }: IToastProviderProps) => {
    return (
        <>
            {children}
            <ToastContainer position="bottom-left" autoClose={3000} />
        </>
    );
};

export default ToastProvider;


================================================
File: src/schemas/actor.schema.ts
================================================
import { z } from "zod";

export const actorSchema = z.object({
    fullname: z.string().min(1, { message: "required" }),
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    description: z.string().min(1, { message: "required" }),
    debut: z.string().min(1, { message: "required" }),
});


================================================
File: src/schemas/auth.schema.ts
================================================
import { z } from "zod";

export const loginSchema = z.object({
    email: z.string().email("Invalid email format").min(1, "Email is a required field"),
    password: z
        .string()
        .min(8, "Password must be at least 8 characters")
        .regex(
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
            "Password must be at least 8 characters, contain at least one uppercase letter, one lowercase, one number, and one special character",
        )
        .min(1, "Password is a required field"),
});

export const registerSchema = z
    .object({
        userName: z
            .string()
            .min(3, "Username must be at least 3 characters")
            .max(20, "Username can't be longer than 20 characters")
            .regex(/^[a-zA-Z0-9_]+$/, "Username can only contain letters, numbers, and underscores")
            .min(1, "Username is a required field"),
        email: z.string().email("Invalid email format").min(1, "Email is a required field"),
        password: z
            .string()
            .min(8, "Password must be at least 8 characters")
            .regex(
                /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
                "Password must be at least 8 characters, contain at least one uppercase letter, one lowercase, one number, and one special character",
            )
            .min(1, "Password is a required field"),
        confirmPassword: z.string().min(1, "Please confirm your password"),
        acceptTerms: z.boolean().refine((val) => val === true, {
            message: "You must accept the Terms of Service and Privacy Policy",
        }),
    })
    .superRefine((data, ctx) => {
        if (data.password !== data.confirmPassword) {
            ctx.addIssue({
                code: "custom",
                path: ["confirmPassword"],
                message: "Passwords must match",
            });
        }
    });

export const contactSchema = z.object({
    name: z.string().min(1, "Name is required"),
    email: z.string().email("Invalid email format").min(1, "Email is required"),
    subject: z.string().min(1, "Subject is required"),
    message: z.string().min(10, "Message must be at least 10 characters long"),
});

export type ContactFormData = z.infer<typeof contactSchema>;

export const resetPasswordSchema = z.object({
    email: z.string().email({ message: "Invalid email format" }).min(1, { message: "Email is a required field" }),
});


================================================
File: src/schemas/crew.schema.ts
================================================
import { z } from "zod";

export const crewSchema = z.object({
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    role: z.coerce.number().min(1, { message: "required" }),
    description: z.string().min(1, { message: "required" }),
    debut: z.coerce.number().min(1, { message: "required" }),
    fullname: z.string().min(1, { message: "required" }),
});


================================================
File: src/schemas/episode.schema.ts
================================================
import { z } from "zod";

export const episodeSchema = z.object({
    title: z.string().min(1, { message: "required" }),
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    trailerSrc: z.string().min(1, { message: "required" }),
    description: z.string().min(1, { message: "required" }),
    duration: z.coerce.number().min(1, { message: "required" }),
    dateAired: z.string().min(1, { message: "required" }),
    ratingImdb: z.coerce.number().min(0).max(10),
    seasonId: z.coerce.number().min(1, { message: "required" }),
});


================================================
File: src/schemas/genre.schema.ts
================================================
import { z } from "zod";

export const genreSchema = z.object({
    name: z.string().min(1, { message: "required" }),
});


================================================
File: src/schemas/movie.schema.ts
================================================
import { z } from "zod";

export const movieSchema = z.object({
    title: z.string().min(1, { message: "required" }),
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    trailerSrc: z.string().min(1, { message: "required" }),
    duration: z.coerce.number().min(1, { message: "required" }),
    dateAired: z.string().min(1, { message: "required" }),
    ratingImdb: z.coerce.number().min(1, { message: "required" }),
    description: z.string().min(1, { message: "required" }),
});


================================================
File: src/schemas/season.schema.ts
================================================
import { z } from "zod";

export const seasonSchema = z.object({
    title: z.string().min(1, { message: "required" }),
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    trailerSrc: z.string().min(1, { message: "required" }),
    description: z.string().min(1, { message: "required" }),
    dateAired: z.string().min(1, { message: "required" }),
    ratingImdb: z.coerce.number().min(0).max(10),
    serieId: z.coerce.number().min(1, { message: "required" }),
});


================================================
File: src/schemas/serie.schema.ts
================================================
import { z } from "zod";

export const serieSchema = z.object({
    title: z.string().min(1, { message: "required" }),
    photoSrc: z.string().min(1, { message: "required" }),
    photoSrcProd: z.string().min(1, { message: "required" }),
    ratingImdb: z.coerce.number().min(1, { message: "required" }),
    dateAired: z.string().min(1, { message: "required" }),
});


================================================
File: src/schemas/user.schema.ts
================================================
import { z } from "zod";

export const userSchema = z.object({
    userName: z.string().min(1, { message: "required" }),
    email: z.string().min(1, { message: "required" }),
});

export const addUserSchema = z.object({
    userName: z.string().min(1, { message: "required" }),
    email: z.string().min(1, { message: "required" }),
    password: z.string().min(1, { message: "required" }),
});


================================================
File: src/store/store.ts
================================================
"use client";

import AppStoreState from "@/types/IStore";
import { create } from "zustand";
import { devtools } from "zustand/middleware";

export const useStore = create<AppStoreState>()(
    devtools(
        (set): AppStoreState => ({
            isOpenSidebarAdmin: true,
            setIsOpenSidebarAdmin: (data) => set({ isOpenSidebarAdmin: data }),
            isDrawerOpen: false,
            setIsDrawerOpen: (data) => set({ isDrawerOpen: data }),
            isEditModeReview: false,
            setIsEditModeReview: (data) => set({ isEditModeReview: data }),
        }),
    ),
);


================================================
File: src/types/IStore.ts
================================================
export default interface AppStoreState {
    isOpenSidebarAdmin: boolean;
    setIsOpenSidebarAdmin: (data: boolean) => void;
    isDrawerOpen: boolean;
    setIsDrawerOpen: (data: boolean) => void;
    isEditModeReview: boolean;
    setIsEditModeReview: (data: boolean) => void;
}


================================================
File: src/types/filterOperators.ts
================================================
export type FilterOperator = "equals" | ">" | "=" | "<" | "gt" | "lt" | "contains";


================================================
File: src/types/next-auth.d.ts
================================================
import NextAuth from "next-auth";

declare module "next-auth" {
    /**
     * Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context
     */
    interface Session {
        user: {
            id: string;
            email: string;
            userName: string;
            role: string;
        };
    }

    interface User {
        id: string;
        email: string;
        userName: string;
        role: string;
    }
}

declare module "next-auth/jwt" {
    interface JWT {
        id: string;
        userName: string;
        role: string;
    }
}


================================================
File: src/utils/features/actorFeaturesUtils.ts
================================================
import { addFavoriteActorToUser, removeFavoriteActorToUser } from "@/actions/user/userBookmarks.actions";
import { showToast } from "@/utils/helpers/toast";
import { Actor } from "@prisma/client";
import { Session } from "next-auth";

export async function onBookmarkActor(session: Session, actor: Actor) {
    if (!session?.user || !actor) return;

    try {
        await addFavoriteActorToUser(Number(session.user.id), actor.id);
        showToast("success", "Actor added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding actor to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding actor to favorites.");
            showToast("error", "An unexpected error occurred while adding the actor to favorites.");
        }
    }
}

export async function onRemoveBookmarkActor(session: Session, actor: Actor) {
    if (!session?.user || !actor) return;

    try {
        await removeFavoriteActorToUser(Number(session.user.id), actor.id);
        showToast("success", "Actor removed from favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error removing actor from favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error removing actor from favorites.");
            showToast("error", "An unexpected error occurred while removing the actor from favorites.");
        }
    }
}


================================================
File: src/utils/features/crewFeaturesUtils.ts
================================================
import { addFavoriteCrewToUser, removeFavoriteCrewToUser } from "@/actions/user/userBookmarks.actions";
import { showToast } from "@/utils/helpers/toast";
import { Crew } from "@prisma/client";
import { Session } from "next-auth";

export async function onBookmarkCrew(session: Session, crew: Crew) {
    if (!session?.user || !crew) return;

    try {
        await addFavoriteCrewToUser(Number(session.user.id), crew.id);
        showToast("success", "Crew added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding crew to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding crew to favorites.");
            showToast("error", "An unexpected error occurred while adding the crew to favorites.");
        }
    }
}

export async function onRemoveBookmarkCrew(session: Session, crew: Crew) {
    if (!session?.user || !crew) return;

    try {
        await removeFavoriteCrewToUser(Number(session.user.id), crew.id);
        showToast("success", "Crew removed from favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error removing crew from favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error removing crew from favorites.");
            showToast("error", "An unexpected error occurred while removing the crew from favorites.");
        }
    }
}


================================================
File: src/utils/features/episodeFeaturesUtils.ts
================================================
import { addFavoriteEpisodeToUser, removeFavoriteEpisodeToUser } from "@/actions/user/userBookmarks.actions";
import { showToast } from "@/utils/helpers/toast";
import { Session } from "next-auth";

export async function onBookmarkEpisode(session: Session, episode: any) {
    if (!session?.user || !episode) return;

    try {
        await addFavoriteEpisodeToUser(Number(session.user.id), episode.id);
        showToast("success", "Episode added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding episode to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding episode to favorites.");
            showToast("error", "An unexpected error occurred while adding the episode to favorites.");
        }
    }
}

export async function onRemoveBookmarkEpisode(session: Session, episode: any) {
    if (!session?.user || !episode) return;

    try {
        await removeFavoriteEpisodeToUser(Number(session.user.id), episode.id, `/episodes/${episode.title}`);
        showToast("success", "Episode removed from favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error removing episode from favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error removing episode from favorites.");
            showToast("error", "An unexpected error occurred while removing the episode from favorites.");
        }
    }
}


================================================
File: src/utils/features/movieFeaturesUtils.ts
================================================
import { addFavoriteMovieToUser, removeFavoriteMovieToUser } from "@/actions/user/userBookmarks.actions";
import { showToast } from "@/utils/helpers/toast";
import { Movie } from "@prisma/client";
import { Session } from "next-auth";

export async function onBookmarkMovie(session: Session, movie: Movie) {
    if (!session?.user || !movie) return;

    try {
        await addFavoriteMovieToUser(Number(session.user.id), movie.id);
        showToast("success", "Movie added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding movie to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding movie to favorites.");
            showToast("error", "An unexpected error occurred while adding the movie to favorites.");
        }
    }
}

export async function onRemoveBookmarkMovie(session: Session, movie: Movie) {
    if (!session?.user || !movie) return;

    try {
        await removeFavoriteMovieToUser(Number(session.user.id), movie.id, `/movies/${movie.title}`);
        showToast("success", "Movie removed from favorites!");
    } catch (error: any) {
        console.error(`Error removing movie from favorites: ${error.message}`);
        showToast("error", `An error occurred: ${error.message}`);
    }
}


================================================
File: src/utils/features/seasonFeaturesUtils.ts
================================================
import { addFavoriteSeasonToUser, removeFavoriteSeasonToUser } from "@/actions/user/userBookmarks.actions";
import { Season } from "@prisma/client";
import { Session } from "next-auth";
import { showToast } from "@/utils/helpers/toast";

export async function onBookmarkSeason(session: Session, season: Season) {
    if (!session?.user || !season) return;

    try {
        await addFavoriteSeasonToUser(Number(session.user.id), season.id);
        showToast("success", "Season added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding season to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding season to favorites.");
            showToast("error", "An unexpected error occurred while adding the season to favorites.");
        }
    }
}

export async function onRemoveBookmarkSeason(session: Session, season: Season) {
    if (!session?.user || !season) return;

    try {
        await removeFavoriteSeasonToUser(Number(session.user.id), season.id, `/seasons/${season.title}`);
        showToast("success", "Season removed from favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error removing season from favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error removing season from favorites.");
            showToast("error", "An unexpected error occurred while removing the season from favorites.");
        }
    }
}


================================================
File: src/utils/features/serieFeaturesUtils.ts
================================================
import { addFavoriteSerieToUser, removeFavoriteSerieToUser } from "@/actions/user/userBookmarks.actions";
import { showToast } from "@/utils/helpers/toast";
import { Serie } from "@prisma/client";
import { Session } from "next-auth";

export async function onBookmarkSerie(session: Session, serie: Serie) {
    if (!session?.user || !serie) return;

    try {
        await addFavoriteSerieToUser(Number(session.user.id), serie.id);
        showToast("success", "Serie added to favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error adding serie to favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error adding serie to favorites.");
            showToast("error", "An unexpected error occurred while adding the serie to favorites.");
        }
    }
}

export async function onRemoveBookmarkSerie(session: Session, serie: Serie) {
    if (!session?.user || !serie) return;

    try {
        await removeFavoriteSerieToUser(Number(session.user.id), serie.id, `/series/${serie.title}`);
        showToast("success", "Serie removed from favorites!");
    } catch (error) {
        if (error instanceof Error) {
            console.error(`Error removing serie from favorites: ${error.message}`);
            showToast("error", `An error occurred: ${error.message}`);
        } else {
            console.error("Unknown error removing serie from favorites.");
            showToast("error", "An unexpected error occurred while removing the serie from favorites.");
        }
    }
}


================================================
File: src/utils/helpers/toast.ts
================================================
import { toast, ToastContent, ToastOptions, Slide, Id } from "react-toastify";

export const defaultToastOptions: ToastOptions = {
    position: "top-right",
    autoClose: 3500,
    hideProgressBar: true,
    closeOnClick: true,
    pauseOnHover: true,
    draggable: true,
    progress: undefined,
    theme: "colored",
    transition: Slide,
};

type ToastType = "success" | "error" | "info" | "warning" | "default";

export const showToast = (type: ToastType, content: ToastContent, options: Partial<ToastOptions> = {}): Id => {
    const optionsToApply = { ...defaultToastOptions, ...options };

    switch (type) {
        case "success":
            return toast.success(content, optionsToApply);
        case "error":
            return toast.error(content, optionsToApply);
        case "info":
            return toast.info(content, optionsToApply);
        case "warning":
            return toast.warn(content, optionsToApply);
        case "default":
            return toast(content, optionsToApply);
        default:
            return toast(content, optionsToApply);
    }
};


================================================
File: src/utils/helpers/utils.ts
================================================
import { parse, format } from "date-fns";

export const IS_BROWSER = typeof window !== "undefined" && typeof window?.document !== "undefined";

export const ensureStartsWith = (stringToCheck: string, startsWith: string) => {
    stringToCheck.startsWith(startsWith) ? stringToCheck : `${startsWith}${stringToCheck}`;
};

export const formatDate = (dateString: string) => {
    const date = parse(dateString, "dd/mm/yyyy", new Date());
    return format(date, "dd MMMM, yyyy");
};


================================================
File: src/utils/theme/theme.tsx
================================================
"use client";

import { createTheme, responsiveFontSizes } from "@mui/material/styles";

const darkColorTokens = {
    grey: {
        100: "#e0e0e0",
        200: "#c2c2c2",
        300: "#a3a3a3",
        400: "#858585",
        500: "#666666",
        600: "#525252",
        700: "#3d3d3d",
        800: "#292929",
        900: "#141414",
        1000: "#212529",
        1100: "#a3acb4",
        1200: "#e7e7e8",
        1300: "#90979f",
        1400: "#eef0ef",
        1500: "#9ba2a9",
    },
    primary: {
        100: "#d0d1d5",
        200: "#a1a4ab",
        300: "#727681",
        400: "#1F2A40",
        500: "#141b2d",
        600: "#101624",
        700: "#868dfb",
        800: "#080b12",
        900: "#040509",
        1000: "#2c3033",
        1100: "#2a2a2a",
    },
    greenAccent: {
        100: "#dbf5ee",
        200: "#b7ebde",
        300: "#94e2cd",
        400: "#70d8bd",
        500: "#4cceac",
        600: "#3da58a",
        700: "#2e7c67",
        800: "#1e5245",
        900: "#0f2922",
    },
    redAccent: {
        100: "#f8dcdb",
        200: "#f1b9b7",
        300: "#e99592",
        400: "#e2726e",
        500: "#db4f4a",
        600: "#af3f3b",
        700: "#832f2c",
        800: "#58201e",
        900: "#2c100f",
    },
    blueAccent: {
        100: "#e1e2fe",
        200: "#c3c6fd",
        300: "#a4a9fc",
        400: "#868dfb",
        500: "#6870fa",
        600: "#535ac8",
        700: "#3e4396",
        800: "#2a2d64",
        900: "#151632",
    },
};

const lightColorTokens = {
    grey: {
        100: "#141414",
        200: "#292929",
        300: "#3d3d3d",
        400: "#525252",
        500: "#666666",
        600: "#858585",
        700: "#a3a3a3",
        800: "#c2c2c2",
        900: "#e0e0e0",
    },
    primary: {
        100: "#040509",
        200: "#080b12",
        300: "#0c101b",
        400: "#f2f0f0",
        500: "#141b2d",
        600: "#1F2A40",
        700: "#FFF",
        800: "#a1a4ab",
        900: "#F5F5F5",
    },
    greenAccent: {
        100: "#0f2922",
        200: "#1e5245",
        300: "#2e7c67",
        400: "#3da58a",
        500: "#4cceac",
        600: "#70d8bd",
        700: "#94e2cd",
        800: "#b7ebde",
        900: "#dbf5ee",
    },
    redAccent: {
        100: "#2c100f",
        200: "#58201e",
        300: "#832f2c",
        400: "#af3f3b",
        500: "#db4f4a",
        600: "#e2726e",
        700: "#e99592",
        800: "#f1b9b7",
        900: "#f8dcdb",
    },
    blueAccent: {
        100: "#151632",
        200: "#2a2d64",
        300: "#3e4396",
        400: "#535ac8",
        500: "#6870fa",
        600: "#868dfb",
        700: "#a4a9fc",
        800: "#c3c6fd",
        900: "#e1e2fe",
    },
};

export const theme = responsiveFontSizes(
    createTheme({
        colorSchemes: {
            light: {
                palette: {
                    primary: {
                        main: lightColorTokens.primary[100],
                        dark: lightColorTokens.primary[900],
                        light: lightColorTokens.primary[200],
                    },
                    blue: {
                        main: lightColorTokens.blueAccent[700],
                    },
                    red: {
                        main: lightColorTokens.redAccent[500],
                    },
                    green: {
                        main: lightColorTokens.greenAccent[700],
                        light: lightColorTokens.greenAccent[400],
                    },
                    secondary: {
                        main: lightColorTokens.primary[500],
                        light: lightColorTokens.primary[400],
                        dark: lightColorTokens.primary[600],
                    },
                    background: {
                        default: "#fcfcfc",
                        paper: "#ffffff",
                    },
                    greyAccent: {
                        main: lightColorTokens.grey[100],
                    },
                    stats: {
                        boxShadow: "rgba(0, 0, 0, 0.1)",
                        hoverShadow: "rgba(0, 0, 0, 0.15)",
                        iconBg: "rgba(33, 150, 243, 0.08)",
                        borderColor: "rgba(0, 0, 0, 0.1)",
                    },
                },
            },
            dark: {
                palette: {
                    primary: {
                        main: darkColorTokens.primary[100],
                        dark: darkColorTokens.primary[900],
                        light: darkColorTokens.primary[200],
                    },
                    blue: {
                        main: darkColorTokens.blueAccent[700],
                    },
                    red: {
                        main: darkColorTokens.redAccent[500],
                    },
                    green: {
                        main: darkColorTokens.greenAccent[700],
                        light: darkColorTokens.greenAccent[400],
                    },
                    secondary: {
                        main: darkColorTokens.primary[500],
                        light: darkColorTokens.primary[400],
                        dark: darkColorTokens.primary[600],
                    },
                    background: {
                        default: darkColorTokens.primary[500],
                        paper: darkColorTokens.primary[400],
                    },
                    greyAccent: {
                        main: darkColorTokens.grey[100],
                    },
                    stats: {
                        boxShadow: "rgba(0, 0, 0, 0.3)",
                        hoverShadow: "rgba(0, 0, 0, 0.4)",
                        iconBg: "rgba(144, 202, 249, 0.08)",
                        borderColor: "rgba(255, 255, 255, 0.1)",
                    },
                },
            },
        },
        cssVariables: {
            colorSchemeSelector: "class",
        },
        typography: {
            fontSize: 12,
            h1: {
                fontSize: 45,
                "@media (max-width:600px)": {
                    fontSize: "42px",
                },
            },
            h2: {
                fontSize: 35,
                "@media (max-width:600px)": {
                    fontSize: "32px",
                },
            },
            h3: {
                fontSize: 24,
                "@media (max-width:600px)": {
                    fontSize: "20px",
                },
            },
            h4: {
                fontSize: 20,
                "@media (max-width:600px)": {
                    fontSize: "18px",
                },
            },
            h5: {
                fontSize: 16,
                "@media (max-width:600px)": {
                    fontSize: "14px",
                },
            },
            h6: {
                fontSize: 14,
                "@media (max-width:600px)": {
                    fontSize: "12px",
                },
            },
            body1: {
                fontSize: 16,
                "@media (max-width:600px)": {
                    fontSize: "14px",
                },
            },
            body2: {
                fontSize: 14,
                "@media (max-width:600px)": {
                    fontSize: "12px",
                },
            },
        },
        components: {
            MuiButton: {
                defaultProps: {
                    disableRipple: true,
                    disableFocusRipple: true,
                    disableTouchRipple: true,
                },
            },
            MuiListItemButton: {
                defaultProps: {
                    disableRipple: true,
                    disableTouchRipple: true,
                },
            },
            MuiIconButton: {
                defaultProps: {
                    disableRipple: true,
                    disableFocusRipple: true,
                    disableTouchRipple: true,
                },
            },
            MuiTab: {
                defaultProps: {
                    disableRipple: true,
                    disableFocusRipple: true,
                    disableTouchRipple: true,
                },
            },
            MuiTypography: {
                styleOverrides: {
                    root: {
                        span: {
                            fontSize: "12px",
                            "@media (max-width:600px)": {
                                fontSize: "10px",
                            },
                        },
                    },
                },
            },
        },
    }),
);


